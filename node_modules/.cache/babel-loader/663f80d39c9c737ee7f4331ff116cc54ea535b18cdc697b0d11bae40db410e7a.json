{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ClampToEdgeWrapping, LinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, MirroredRepeatWrapping, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, RepeatWrapping, Vector2 } from 'three';\nimport { toVector2D } from '../../model-viewer-base.js';\nimport { Filter, Wrap } from '../../three-components/gltf-instance/gltf-2.0.js';\nimport { $correlatedObjects, $onUpdate, ThreeDOMElement } from './three-dom-element.js';\n// Convertion between gltf standards and threejs standards.\nconst wrapModeToWrapping = new Map([[Wrap.Repeat, RepeatWrapping], [Wrap.ClampToEdge, ClampToEdgeWrapping], [Wrap.MirroredRepeat, MirroredRepeatWrapping]]);\nconst wrappingToWrapMode = new Map([[RepeatWrapping, Wrap.Repeat], [ClampToEdgeWrapping, Wrap.ClampToEdge], [MirroredRepeatWrapping, Wrap.MirroredRepeat]]);\nconst minFilterToMinification = new Map([[Filter.Nearest, NearestFilter], [Filter.Linear, LinearFilter], [Filter.NearestMipmapNearest, NearestMipmapNearestFilter], [Filter.LinearMipmapNearest, LinearMipmapNearestFilter], [Filter.NearestMipmapLinear, NearestMipmapLinearFilter], [Filter.LinearMipmapLinear, LinearMipmapLinearFilter]]);\nconst minificationToMinFilter = new Map([[NearestFilter, Filter.Nearest], [LinearFilter, Filter.Linear], [NearestMipmapNearestFilter, Filter.NearestMipmapNearest], [LinearMipmapNearestFilter, Filter.LinearMipmapNearest], [NearestMipmapLinearFilter, Filter.NearestMipmapLinear], [LinearMipmapLinearFilter, Filter.LinearMipmapLinear]]);\nconst magFilterToMagnification = new Map([[Filter.Nearest, NearestFilter], [Filter.Linear, LinearFilter]]);\nconst magnificationToMagFilter = new Map([[NearestFilter, Filter.Nearest], [LinearFilter, Filter.Linear]]);\n// Checks for threejs standards.\nconst isMinFilter = (() => {\n  return value => minificationToMinFilter.has(value);\n})();\nconst isMagFilter = (() => {\n  return value => magnificationToMagFilter.has(value);\n})();\nconst isWrapping = (() => {\n  return value => wrappingToWrapMode.has(value);\n})();\nconst isValidSamplerValue = (property, value) => {\n  switch (property) {\n    case 'minFilter':\n      return isMinFilter(value);\n    case 'magFilter':\n      return isMagFilter(value);\n    case 'wrapS':\n    case 'wrapT':\n      return isWrapping(value);\n    case 'rotation':\n    case 'repeat':\n    case 'offset':\n      return true;\n    default:\n      throw new Error(`Cannot configure property \"${property}\" on Sampler`);\n  }\n};\nconst $threeTexture = Symbol('threeTexture');\nconst $threeTextures = Symbol('threeTextures');\nconst $setProperty = Symbol('setProperty');\n/**\n * Sampler facade implementation for Three.js textures\n */\nexport class Sampler extends ThreeDOMElement {\n  get [$threeTexture]() {\n    var _a;\n    return (_a = this[$correlatedObjects]) === null || _a === void 0 ? void 0 : _a.values().next().value;\n  }\n  get [$threeTextures]() {\n    return this[$correlatedObjects];\n  }\n  constructor(onUpdate, texture) {\n    super(onUpdate, new Set(texture ? [texture] : []));\n  }\n  get name() {\n    return this[$threeTexture].name || '';\n  }\n  get minFilter() {\n    return minificationToMinFilter.get(this[$threeTexture].minFilter);\n  }\n  get magFilter() {\n    return magnificationToMagFilter.get(this[$threeTexture].magFilter);\n  }\n  get wrapS() {\n    return wrappingToWrapMode.get(this[$threeTexture].wrapS);\n  }\n  get wrapT() {\n    return wrappingToWrapMode.get(this[$threeTexture].wrapT);\n  }\n  get rotation() {\n    return this[$threeTexture].rotation;\n  }\n  get scale() {\n    return toVector2D(this[$threeTexture].repeat);\n  }\n  get offset() {\n    return toVector2D(this[$threeTexture].offset);\n  }\n  setMinFilter(filter) {\n    this[$setProperty]('minFilter', minFilterToMinification.get(filter));\n  }\n  setMagFilter(filter) {\n    this[$setProperty]('magFilter', magFilterToMagnification.get(filter));\n  }\n  setWrapS(mode) {\n    this[$setProperty]('wrapS', wrapModeToWrapping.get(mode));\n  }\n  setWrapT(mode) {\n    this[$setProperty]('wrapT', wrapModeToWrapping.get(mode));\n  }\n  setRotation(rotation) {\n    if (rotation == null) {\n      // Reset rotation.\n      rotation = 0;\n    }\n    this[$setProperty]('rotation', rotation);\n  }\n  setScale(scale) {\n    if (scale == null) {\n      // Reset scale.\n      scale = {\n        u: 1,\n        v: 1\n      };\n    }\n    this[$setProperty]('repeat', new Vector2(scale.u, scale.v));\n  }\n  setOffset(offset) {\n    if (offset == null) {\n      // Reset offset.\n      offset = {\n        u: 0,\n        v: 0\n      };\n    }\n    this[$setProperty]('offset', new Vector2(offset.u, offset.v));\n  }\n  [$setProperty](property, value) {\n    if (isValidSamplerValue(property, value)) {\n      for (const texture of this[$threeTextures]) {\n        texture[property] = value;\n        texture.needsUpdate = true;\n      }\n    }\n    this[$onUpdate]();\n  }\n}","map":{"version":3,"names":["ClampToEdgeWrapping","LinearFilter","LinearMipmapLinearFilter","LinearMipmapNearestFilter","MirroredRepeatWrapping","NearestFilter","NearestMipmapLinearFilter","NearestMipmapNearestFilter","RepeatWrapping","Vector2","toVector2D","Filter","Wrap","$correlatedObjects","$onUpdate","ThreeDOMElement","wrapModeToWrapping","Map","Repeat","ClampToEdge","MirroredRepeat","wrappingToWrapMode","minFilterToMinification","Nearest","Linear","NearestMipmapNearest","LinearMipmapNearest","NearestMipmapLinear","LinearMipmapLinear","minificationToMinFilter","magFilterToMagnification","magnificationToMagFilter","isMinFilter","value","has","isMagFilter","isWrapping","isValidSamplerValue","property","Error","$threeTexture","Symbol","$threeTextures","$setProperty","Sampler","_a","values","next","constructor","onUpdate","texture","Set","name","minFilter","get","magFilter","wrapS","wrapT","rotation","scale","repeat","offset","setMinFilter","filter","setMagFilter","setWrapS","mode","setWrapT","setRotation","setScale","u","v","setOffset","needsUpdate"],"sources":["/Users/leandrodisconzi/CascadeProjects/geodome-website/node_modules/@google/model-viewer/lib/features/scene-graph/sampler.js"],"sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ClampToEdgeWrapping, LinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, MirroredRepeatWrapping, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, RepeatWrapping, Vector2 } from 'three';\nimport { toVector2D } from '../../model-viewer-base.js';\nimport { Filter, Wrap } from '../../three-components/gltf-instance/gltf-2.0.js';\nimport { $correlatedObjects, $onUpdate, ThreeDOMElement } from './three-dom-element.js';\n// Convertion between gltf standards and threejs standards.\nconst wrapModeToWrapping = new Map([\n    [Wrap.Repeat, RepeatWrapping],\n    [Wrap.ClampToEdge, ClampToEdgeWrapping],\n    [Wrap.MirroredRepeat, MirroredRepeatWrapping]\n]);\nconst wrappingToWrapMode = new Map([\n    [RepeatWrapping, Wrap.Repeat],\n    [ClampToEdgeWrapping, Wrap.ClampToEdge],\n    [MirroredRepeatWrapping, Wrap.MirroredRepeat]\n]);\nconst minFilterToMinification = new Map([\n    [Filter.Nearest, NearestFilter],\n    [Filter.Linear, LinearFilter],\n    [Filter.NearestMipmapNearest, NearestMipmapNearestFilter],\n    [Filter.LinearMipmapNearest, LinearMipmapNearestFilter],\n    [Filter.NearestMipmapLinear, NearestMipmapLinearFilter],\n    [Filter.LinearMipmapLinear, LinearMipmapLinearFilter]\n]);\nconst minificationToMinFilter = new Map([\n    [NearestFilter, Filter.Nearest],\n    [LinearFilter, Filter.Linear],\n    [NearestMipmapNearestFilter, Filter.NearestMipmapNearest],\n    [LinearMipmapNearestFilter, Filter.LinearMipmapNearest],\n    [NearestMipmapLinearFilter, Filter.NearestMipmapLinear],\n    [LinearMipmapLinearFilter, Filter.LinearMipmapLinear]\n]);\nconst magFilterToMagnification = new Map([[Filter.Nearest, NearestFilter], [Filter.Linear, LinearFilter]]);\nconst magnificationToMagFilter = new Map([[NearestFilter, Filter.Nearest], [LinearFilter, Filter.Linear]]);\n// Checks for threejs standards.\nconst isMinFilter = (() => {\n    return (value) => minificationToMinFilter.has(value);\n})();\nconst isMagFilter = (() => {\n    return (value) => magnificationToMagFilter.has(value);\n})();\nconst isWrapping = (() => {\n    return (value) => wrappingToWrapMode.has(value);\n})();\nconst isValidSamplerValue = (property, value) => {\n    switch (property) {\n        case 'minFilter':\n            return isMinFilter(value);\n        case 'magFilter':\n            return isMagFilter(value);\n        case 'wrapS':\n        case 'wrapT':\n            return isWrapping(value);\n        case 'rotation':\n        case 'repeat':\n        case 'offset':\n            return true;\n        default:\n            throw new Error(`Cannot configure property \"${property}\" on Sampler`);\n    }\n};\nconst $threeTexture = Symbol('threeTexture');\nconst $threeTextures = Symbol('threeTextures');\nconst $setProperty = Symbol('setProperty');\n/**\n * Sampler facade implementation for Three.js textures\n */\nexport class Sampler extends ThreeDOMElement {\n    get [$threeTexture]() {\n        var _a;\n        return (_a = this[$correlatedObjects]) === null || _a === void 0 ? void 0 : _a.values().next().value;\n    }\n    get [$threeTextures]() {\n        return this[$correlatedObjects];\n    }\n    constructor(onUpdate, texture) {\n        super(onUpdate, new Set(texture ? [texture] : []));\n    }\n    get name() {\n        return this[$threeTexture].name || '';\n    }\n    get minFilter() {\n        return minificationToMinFilter.get(this[$threeTexture].minFilter);\n    }\n    get magFilter() {\n        return magnificationToMagFilter.get(this[$threeTexture].magFilter);\n    }\n    get wrapS() {\n        return wrappingToWrapMode.get(this[$threeTexture].wrapS);\n    }\n    get wrapT() {\n        return wrappingToWrapMode.get(this[$threeTexture].wrapT);\n    }\n    get rotation() {\n        return this[$threeTexture].rotation;\n    }\n    get scale() {\n        return toVector2D(this[$threeTexture].repeat);\n    }\n    get offset() {\n        return toVector2D(this[$threeTexture].offset);\n    }\n    setMinFilter(filter) {\n        this[$setProperty]('minFilter', minFilterToMinification.get(filter));\n    }\n    setMagFilter(filter) {\n        this[$setProperty]('magFilter', magFilterToMagnification.get(filter));\n    }\n    setWrapS(mode) {\n        this[$setProperty]('wrapS', wrapModeToWrapping.get(mode));\n    }\n    setWrapT(mode) {\n        this[$setProperty]('wrapT', wrapModeToWrapping.get(mode));\n    }\n    setRotation(rotation) {\n        if (rotation == null) {\n            // Reset rotation.\n            rotation = 0;\n        }\n        this[$setProperty]('rotation', rotation);\n    }\n    setScale(scale) {\n        if (scale == null) {\n            // Reset scale.\n            scale = { u: 1, v: 1 };\n        }\n        this[$setProperty]('repeat', new Vector2(scale.u, scale.v));\n    }\n    setOffset(offset) {\n        if (offset == null) {\n            // Reset offset.\n            offset = { u: 0, v: 0 };\n        }\n        this[$setProperty]('offset', new Vector2(offset.u, offset.v));\n    }\n    [$setProperty](property, value) {\n        if (isValidSamplerValue(property, value)) {\n            for (const texture of this[$threeTextures]) {\n                texture[property] = value;\n                texture.needsUpdate = true;\n            }\n        }\n        this[$onUpdate]();\n    }\n}\n//# sourceMappingURL=sampler.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}