{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport const numberNode = (value, unit) => ({\n  type: 'number',\n  number: value,\n  unit\n});\n/**\n * Given a string representing a comma-separated set of CSS-like expressions,\n * parses and returns an array of ASTs that correspond to those expressions.\n *\n * Currently supported syntax includes:\n *\n *  - functions (top-level and nested)\n *  - calc() arithmetic operators\n *  - numbers with units\n *  - hexadecimal-encoded colors in 3, 6 or 8 digit form\n *  - idents\n *\n * All syntax is intended to match the parsing rules and semantics of the actual\n * CSS spec as closely as possible.\n *\n * @see https://www.w3.org/TR/CSS2/\n * @see https://www.w3.org/TR/css-values-3/\n */\nexport const parseExpressions = (() => {\n  const cache = {};\n  const MAX_PARSE_ITERATIONS = 1000; // Arbitrarily large\n  return inputString => {\n    const cacheKey = inputString;\n    if (cacheKey in cache) {\n      return cache[cacheKey];\n    }\n    const expressions = [];\n    let parseIterations = 0;\n    while (inputString) {\n      if (++parseIterations > MAX_PARSE_ITERATIONS) {\n        // Avoid a potentially infinite loop due to typos:\n        inputString = '';\n        break;\n      }\n      const expressionParseResult = parseExpression(inputString);\n      const expression = expressionParseResult.nodes[0];\n      if (expression == null || expression.terms.length === 0) {\n        break;\n      }\n      expressions.push(expression);\n      inputString = expressionParseResult.remainingInput;\n    }\n    return cache[cacheKey] = expressions;\n  };\n})();\n/**\n * Parse a single expression. For the purposes of our supported syntax, an\n * expression is the set of semantically meaningful terms that appear before the\n * next comma, or between the parens of a function invocation.\n */\nconst parseExpression = (() => {\n  const IS_IDENT_RE = /^(\\-\\-|[a-z\\u0240-\\uffff])/i;\n  const IS_OPERATOR_RE = /^([\\*\\+\\/]|[\\-]\\s)/i;\n  const IS_EXPRESSION_END_RE = /^[\\),]/;\n  const FUNCTION_ARGUMENTS_FIRST_TOKEN = '(';\n  const HEX_FIRST_TOKEN = '#';\n  return inputString => {\n    const terms = [];\n    while (inputString.length) {\n      inputString = inputString.trim();\n      if (IS_EXPRESSION_END_RE.test(inputString)) {\n        break;\n      } else if (inputString[0] === FUNCTION_ARGUMENTS_FIRST_TOKEN) {\n        const {\n          nodes,\n          remainingInput\n        } = parseFunctionArguments(inputString);\n        inputString = remainingInput;\n        terms.push({\n          type: 'function',\n          name: {\n            type: 'ident',\n            value: 'calc'\n          },\n          arguments: nodes\n        });\n      } else if (IS_IDENT_RE.test(inputString)) {\n        const identParseResult = parseIdent(inputString);\n        const identNode = identParseResult.nodes[0];\n        inputString = identParseResult.remainingInput;\n        if (inputString[0] === FUNCTION_ARGUMENTS_FIRST_TOKEN) {\n          const {\n            nodes,\n            remainingInput\n          } = parseFunctionArguments(inputString);\n          terms.push({\n            type: 'function',\n            name: identNode,\n            arguments: nodes\n          });\n          inputString = remainingInput;\n        } else {\n          terms.push(identNode);\n        }\n      } else if (IS_OPERATOR_RE.test(inputString)) {\n        // Operators are always a single character, so just pluck them out:\n        terms.push({\n          type: 'operator',\n          value: inputString[0]\n        });\n        inputString = inputString.slice(1);\n      } else {\n        const {\n          nodes,\n          remainingInput\n        } = inputString[0] === HEX_FIRST_TOKEN ? parseHex(inputString) : parseNumber(inputString);\n        // The remaining string may not have had any meaningful content. Exit\n        // early if this is the case:\n        if (nodes.length === 0) {\n          break;\n        }\n        terms.push(nodes[0]);\n        inputString = remainingInput;\n      }\n    }\n    return {\n      nodes: [{\n        type: 'expression',\n        terms\n      }],\n      remainingInput: inputString\n    };\n  };\n})();\n/**\n * An ident is something like a function name or the keyword \"auto\".\n */\nconst parseIdent = (() => {\n  const NOT_IDENT_RE = /[^a-z0-9_\\-\\u0240-\\uffff]/i;\n  return inputString => {\n    const match = inputString.match(NOT_IDENT_RE);\n    const ident = match == null ? inputString : inputString.substr(0, match.index);\n    const remainingInput = match == null ? '' : inputString.substr(match.index);\n    return {\n      nodes: [{\n        type: 'ident',\n        value: ident\n      }],\n      remainingInput\n    };\n  };\n})();\n/**\n * Parses a number. A number value can be expressed with an integer or\n * non-integer syntax, and usually includes a unit (but does not strictly\n * require one for our purposes).\n */\nconst parseNumber = (() => {\n  // @see https://www.w3.org/TR/css-syntax/#number-token-diagram\n  const VALUE_RE = /[\\+\\-]?(\\d+[\\.]\\d+|\\d+|[\\.]\\d+)([eE][\\+\\-]?\\d+)?/;\n  const UNIT_RE = /^[a-z%]+/i;\n  const ALLOWED_UNITS = /^(m|mm|cm|rad|deg|[%])$/;\n  return inputString => {\n    const valueMatch = inputString.match(VALUE_RE);\n    const value = valueMatch == null ? '0' : valueMatch[0];\n    inputString = value == null ? inputString : inputString.slice(value.length);\n    const unitMatch = inputString.match(UNIT_RE);\n    let unit = unitMatch != null && unitMatch[0] !== '' ? unitMatch[0] : null;\n    const remainingInput = unitMatch == null ? inputString : inputString.slice(unit.length);\n    if (unit != null && !ALLOWED_UNITS.test(unit)) {\n      unit = null;\n    }\n    return {\n      nodes: [{\n        type: 'number',\n        number: parseFloat(value) || 0,\n        unit: unit\n      }],\n      remainingInput\n    };\n  };\n})();\n/**\n * Parses a hexadecimal-encoded color in 3, 6 or 8 digit form.\n */\nconst parseHex = (() => {\n  // TODO(cdata): right now we don't actually enforce the number of digits\n  const HEX_RE = /^[a-f0-9]*/i;\n  return inputString => {\n    inputString = inputString.slice(1).trim();\n    const hexMatch = inputString.match(HEX_RE);\n    const nodes = hexMatch == null ? [] : [{\n      type: 'hex',\n      value: hexMatch[0]\n    }];\n    return {\n      nodes,\n      remainingInput: hexMatch == null ? inputString : inputString.slice(hexMatch[0].length)\n    };\n  };\n})();\n/**\n * Parses arguments passed to a function invocation (e.g., the expressions\n * within a matched set of parens).\n */\nconst parseFunctionArguments = inputString => {\n  const expressionNodes = [];\n  // Consume the opening paren\n  inputString = inputString.slice(1).trim();\n  while (inputString.length) {\n    const expressionParseResult = parseExpression(inputString);\n    expressionNodes.push(expressionParseResult.nodes[0]);\n    inputString = expressionParseResult.remainingInput.trim();\n    if (inputString[0] === ',') {\n      inputString = inputString.slice(1).trim();\n    } else if (inputString[0] === ')') {\n      // Consume the closing paren and stop parsing\n      inputString = inputString.slice(1);\n      break;\n    }\n  }\n  return {\n    nodes: expressionNodes,\n    remainingInput: inputString\n  };\n};\nconst $visitedTypes = Symbol('visitedTypes');\n/**\n * An ASTWalker walks an array of ASTs such as the type produced by\n * parseExpressions and invokes a callback for a configured set of nodes that\n * the user wishes to \"visit\" during the walk.\n */\nexport class ASTWalker {\n  constructor(visitedTypes) {\n    this[$visitedTypes] = visitedTypes;\n  }\n  /**\n   * Walk the given set of ASTs, and invoke the provided callback for nodes that\n   * match the filtered set that the ASTWalker was constructed with.\n   */\n  walk(ast, callback) {\n    const remaining = ast.slice();\n    while (remaining.length) {\n      const next = remaining.shift();\n      if (this[$visitedTypes].indexOf(next.type) > -1) {\n        callback(next);\n      }\n      switch (next.type) {\n        case 'expression':\n          remaining.unshift(...next.terms);\n          break;\n        case 'function':\n          remaining.unshift(next.name, ...next.arguments);\n          break;\n      }\n    }\n  }\n}\nexport const ZERO = Object.freeze({\n  type: 'number',\n  number: 0,\n  unit: null\n});","map":{"version":3,"names":["numberNode","value","unit","type","number","parseExpressions","cache","MAX_PARSE_ITERATIONS","inputString","cacheKey","expressions","parseIterations","expressionParseResult","parseExpression","expression","nodes","terms","length","push","remainingInput","IS_IDENT_RE","IS_OPERATOR_RE","IS_EXPRESSION_END_RE","FUNCTION_ARGUMENTS_FIRST_TOKEN","HEX_FIRST_TOKEN","trim","test","parseFunctionArguments","name","arguments","identParseResult","parseIdent","identNode","slice","parseHex","parseNumber","NOT_IDENT_RE","match","ident","substr","index","VALUE_RE","UNIT_RE","ALLOWED_UNITS","valueMatch","unitMatch","parseFloat","HEX_RE","hexMatch","expressionNodes","$visitedTypes","Symbol","ASTWalker","constructor","visitedTypes","walk","ast","callback","remaining","next","shift","indexOf","unshift","ZERO","Object","freeze"],"sources":["/Users/leandrodisconzi/CascadeProjects/geodome-website/node_modules/@google/model-viewer/lib/styles/parsers.js"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport const numberNode = (value, unit) => ({ type: 'number', number: value, unit });\n/**\n * Given a string representing a comma-separated set of CSS-like expressions,\n * parses and returns an array of ASTs that correspond to those expressions.\n *\n * Currently supported syntax includes:\n *\n *  - functions (top-level and nested)\n *  - calc() arithmetic operators\n *  - numbers with units\n *  - hexadecimal-encoded colors in 3, 6 or 8 digit form\n *  - idents\n *\n * All syntax is intended to match the parsing rules and semantics of the actual\n * CSS spec as closely as possible.\n *\n * @see https://www.w3.org/TR/CSS2/\n * @see https://www.w3.org/TR/css-values-3/\n */\nexport const parseExpressions = (() => {\n    const cache = {};\n    const MAX_PARSE_ITERATIONS = 1000; // Arbitrarily large\n    return (inputString) => {\n        const cacheKey = inputString;\n        if (cacheKey in cache) {\n            return cache[cacheKey];\n        }\n        const expressions = [];\n        let parseIterations = 0;\n        while (inputString) {\n            if (++parseIterations > MAX_PARSE_ITERATIONS) {\n                // Avoid a potentially infinite loop due to typos:\n                inputString = '';\n                break;\n            }\n            const expressionParseResult = parseExpression(inputString);\n            const expression = expressionParseResult.nodes[0];\n            if (expression == null || expression.terms.length === 0) {\n                break;\n            }\n            expressions.push(expression);\n            inputString = expressionParseResult.remainingInput;\n        }\n        return cache[cacheKey] = expressions;\n    };\n})();\n/**\n * Parse a single expression. For the purposes of our supported syntax, an\n * expression is the set of semantically meaningful terms that appear before the\n * next comma, or between the parens of a function invocation.\n */\nconst parseExpression = (() => {\n    const IS_IDENT_RE = /^(\\-\\-|[a-z\\u0240-\\uffff])/i;\n    const IS_OPERATOR_RE = /^([\\*\\+\\/]|[\\-]\\s)/i;\n    const IS_EXPRESSION_END_RE = /^[\\),]/;\n    const FUNCTION_ARGUMENTS_FIRST_TOKEN = '(';\n    const HEX_FIRST_TOKEN = '#';\n    return (inputString) => {\n        const terms = [];\n        while (inputString.length) {\n            inputString = inputString.trim();\n            if (IS_EXPRESSION_END_RE.test(inputString)) {\n                break;\n            }\n            else if (inputString[0] === FUNCTION_ARGUMENTS_FIRST_TOKEN) {\n                const { nodes, remainingInput } = parseFunctionArguments(inputString);\n                inputString = remainingInput;\n                terms.push({\n                    type: 'function',\n                    name: { type: 'ident', value: 'calc' },\n                    arguments: nodes\n                });\n            }\n            else if (IS_IDENT_RE.test(inputString)) {\n                const identParseResult = parseIdent(inputString);\n                const identNode = identParseResult.nodes[0];\n                inputString = identParseResult.remainingInput;\n                if (inputString[0] === FUNCTION_ARGUMENTS_FIRST_TOKEN) {\n                    const { nodes, remainingInput } = parseFunctionArguments(inputString);\n                    terms.push({ type: 'function', name: identNode, arguments: nodes });\n                    inputString = remainingInput;\n                }\n                else {\n                    terms.push(identNode);\n                }\n            }\n            else if (IS_OPERATOR_RE.test(inputString)) {\n                // Operators are always a single character, so just pluck them out:\n                terms.push({ type: 'operator', value: inputString[0] });\n                inputString = inputString.slice(1);\n            }\n            else {\n                const { nodes, remainingInput } = inputString[0] === HEX_FIRST_TOKEN ?\n                    parseHex(inputString) :\n                    parseNumber(inputString);\n                // The remaining string may not have had any meaningful content. Exit\n                // early if this is the case:\n                if (nodes.length === 0) {\n                    break;\n                }\n                terms.push(nodes[0]);\n                inputString = remainingInput;\n            }\n        }\n        return { nodes: [{ type: 'expression', terms }], remainingInput: inputString };\n    };\n})();\n/**\n * An ident is something like a function name or the keyword \"auto\".\n */\nconst parseIdent = (() => {\n    const NOT_IDENT_RE = /[^a-z0-9_\\-\\u0240-\\uffff]/i;\n    return (inputString) => {\n        const match = inputString.match(NOT_IDENT_RE);\n        const ident = match == null ? inputString : inputString.substr(0, match.index);\n        const remainingInput = match == null ? '' : inputString.substr(match.index);\n        return { nodes: [{ type: 'ident', value: ident }], remainingInput };\n    };\n})();\n/**\n * Parses a number. A number value can be expressed with an integer or\n * non-integer syntax, and usually includes a unit (but does not strictly\n * require one for our purposes).\n */\nconst parseNumber = (() => {\n    // @see https://www.w3.org/TR/css-syntax/#number-token-diagram\n    const VALUE_RE = /[\\+\\-]?(\\d+[\\.]\\d+|\\d+|[\\.]\\d+)([eE][\\+\\-]?\\d+)?/;\n    const UNIT_RE = /^[a-z%]+/i;\n    const ALLOWED_UNITS = /^(m|mm|cm|rad|deg|[%])$/;\n    return (inputString) => {\n        const valueMatch = inputString.match(VALUE_RE);\n        const value = valueMatch == null ? '0' : valueMatch[0];\n        inputString = value == null ? inputString : inputString.slice(value.length);\n        const unitMatch = inputString.match(UNIT_RE);\n        let unit = unitMatch != null && unitMatch[0] !== '' ? unitMatch[0] : null;\n        const remainingInput = unitMatch == null ? inputString : inputString.slice(unit.length);\n        if (unit != null && !ALLOWED_UNITS.test(unit)) {\n            unit = null;\n        }\n        return {\n            nodes: [{\n                    type: 'number',\n                    number: parseFloat(value) || 0,\n                    unit: unit\n                }],\n            remainingInput\n        };\n    };\n})();\n/**\n * Parses a hexadecimal-encoded color in 3, 6 or 8 digit form.\n */\nconst parseHex = (() => {\n    // TODO(cdata): right now we don't actually enforce the number of digits\n    const HEX_RE = /^[a-f0-9]*/i;\n    return (inputString) => {\n        inputString = inputString.slice(1).trim();\n        const hexMatch = inputString.match(HEX_RE);\n        const nodes = hexMatch == null ? [] : [{ type: 'hex', value: hexMatch[0] }];\n        return {\n            nodes,\n            remainingInput: hexMatch == null ? inputString :\n                inputString.slice(hexMatch[0].length)\n        };\n    };\n})();\n/**\n * Parses arguments passed to a function invocation (e.g., the expressions\n * within a matched set of parens).\n */\nconst parseFunctionArguments = (inputString) => {\n    const expressionNodes = [];\n    // Consume the opening paren\n    inputString = inputString.slice(1).trim();\n    while (inputString.length) {\n        const expressionParseResult = parseExpression(inputString);\n        expressionNodes.push(expressionParseResult.nodes[0]);\n        inputString = expressionParseResult.remainingInput.trim();\n        if (inputString[0] === ',') {\n            inputString = inputString.slice(1).trim();\n        }\n        else if (inputString[0] === ')') {\n            // Consume the closing paren and stop parsing\n            inputString = inputString.slice(1);\n            break;\n        }\n    }\n    return { nodes: expressionNodes, remainingInput: inputString };\n};\nconst $visitedTypes = Symbol('visitedTypes');\n/**\n * An ASTWalker walks an array of ASTs such as the type produced by\n * parseExpressions and invokes a callback for a configured set of nodes that\n * the user wishes to \"visit\" during the walk.\n */\nexport class ASTWalker {\n    constructor(visitedTypes) {\n        this[$visitedTypes] = visitedTypes;\n    }\n    /**\n     * Walk the given set of ASTs, and invoke the provided callback for nodes that\n     * match the filtered set that the ASTWalker was constructed with.\n     */\n    walk(ast, callback) {\n        const remaining = ast.slice();\n        while (remaining.length) {\n            const next = remaining.shift();\n            if (this[$visitedTypes].indexOf(next.type) > -1) {\n                callback(next);\n            }\n            switch (next.type) {\n                case 'expression':\n                    remaining.unshift(...next.terms);\n                    break;\n                case 'function':\n                    remaining.unshift(next.name, ...next.arguments);\n                    break;\n            }\n        }\n    }\n}\nexport const ZERO = Object.freeze({ type: 'number', number: 0, unit: null });\n//# sourceMappingURL=parsers.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}