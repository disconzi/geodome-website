{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c, _d;\nimport { ASTWalker } from './parsers.js';\nconst $instances = Symbol('instances');\nconst $activateListener = Symbol('activateListener');\nconst $deactivateListener = Symbol('deactivateListener');\nconst $notifyInstances = Symbol('notifyInstances');\nconst $notify = Symbol('notify');\nconst $scrollCallback = Symbol('callback');\n/**\n * This internal helper is intended to work as a reference-counting manager of\n * scroll event listeners. Only one scroll listener is ever registered for all\n * instances of the class, and when the last ScrollObserver \"disconnects\", that\n * event listener is removed. This spares us from thrashing\n * the {add,remove}EventListener API (the binding cost of these methods has been\n * known to show up in performance analyses) as well as potential memory leaks.\n */\nclass ScrollObserver {\n  constructor(callback) {\n    this[$scrollCallback] = callback;\n  }\n  static [$notifyInstances]() {\n    for (const instance of ScrollObserver[$instances]) {\n      instance[$notify]();\n    }\n  }\n  static [(_a = $instances, $activateListener)]() {\n    window.addEventListener('scroll', this[$notifyInstances], {\n      passive: true\n    });\n  }\n  static [$deactivateListener]() {\n    window.removeEventListener('scroll', this[$notifyInstances]);\n  }\n  /**\n   * Listen for scroll events. The configured callback (passed to the\n   * constructor) will be invoked for subsequent global scroll events.\n   */\n  observe() {\n    if (ScrollObserver[$instances].size === 0) {\n      ScrollObserver[$activateListener]();\n    }\n    ScrollObserver[$instances].add(this);\n  }\n  /**\n   * Stop listening for scroll events.\n   */\n  disconnect() {\n    ScrollObserver[$instances].delete(this);\n    if (ScrollObserver[$instances].size === 0) {\n      ScrollObserver[$deactivateListener]();\n    }\n  }\n  [$notify]() {\n    this[$scrollCallback]();\n  }\n}\nScrollObserver[_a] = new Set();\nconst $computeStyleCallback = Symbol('computeStyleCallback');\nconst $astWalker = Symbol('astWalker');\nconst $dependencies = Symbol('dependencies');\nconst $onScroll = Symbol('onScroll');\n/**\n * The StyleEffector is configured with a callback that will be invoked at the\n * optimal time that some array of CSS expression ASTs ought to be evaluated.\n *\n * For example, our CSS-like expression syntax supports usage of the env()\n * function to incorporate the current top-level scroll position into a CSS\n * expression: env(window-scroll-y).\n *\n * This \"environment variable\" will change dynamically as the user scrolls the\n * page. If an AST contains such a usage of env(), we would have to evaluate the\n * AST on every frame in order to be sure that the computed style stays up to\n * date.\n *\n * The StyleEffector spares us from evaluating the expressions on every frame by\n * correlating specific parts of an AST with observers of the external effects\n * that they refer to (if any). So, if the AST contains env(window-scroll-y),\n * the StyleEffector manages the lifetime of a global scroll event listener and\n * notifies the user at the optimal time to evaluate the computed style.\n */\nexport class StyleEffector {\n  constructor(callback) {\n    this[_b] = {};\n    this[_c] = new ASTWalker(['function']);\n    this[_d] = () => {\n      this[$computeStyleCallback]({\n        relatedState: 'window-scroll'\n      });\n    };\n    this[$computeStyleCallback] = callback;\n  }\n  /**\n   * Sets the expressions that govern when the StyleEffector callback will be\n   * invoked.\n   */\n  observeEffectsFor(ast) {\n    const newDependencies = {};\n    const oldDependencies = this[$dependencies];\n    this[$astWalker].walk(ast, functionNode => {\n      const {\n        name\n      } = functionNode;\n      const firstArgument = functionNode.arguments[0];\n      const firstTerm = firstArgument.terms[0];\n      if (name.value !== 'env' || firstTerm == null || firstTerm.type !== 'ident') {\n        return;\n      }\n      switch (firstTerm.value) {\n        case 'window-scroll-y':\n          if (newDependencies['window-scroll'] == null) {\n            const observer = 'window-scroll' in oldDependencies ? oldDependencies['window-scroll'] : new ScrollObserver(this[$onScroll]);\n            observer.observe();\n            delete oldDependencies['window-scroll'];\n            newDependencies['window-scroll'] = observer;\n          }\n          break;\n      }\n    });\n    for (const environmentState in oldDependencies) {\n      const observer = oldDependencies[environmentState];\n      observer.disconnect();\n    }\n    this[$dependencies] = newDependencies;\n  }\n  /**\n   * Disposes of the StyleEffector by disconnecting all observers of external\n   * effects.\n   */\n  dispose() {\n    for (const environmentState in this[$dependencies]) {\n      const observer = this[$dependencies][environmentState];\n      observer.disconnect();\n    }\n  }\n}\n_b = $dependencies, _c = $astWalker, _d = $onScroll;","map":{"version":3,"names":["_a","_b","_c","_d","ASTWalker","$instances","Symbol","$activateListener","$deactivateListener","$notifyInstances","$notify","$scrollCallback","ScrollObserver","constructor","callback","instance","window","addEventListener","passive","removeEventListener","observe","size","add","disconnect","delete","Set","$computeStyleCallback","$astWalker","$dependencies","$onScroll","StyleEffector","relatedState","observeEffectsFor","ast","newDependencies","oldDependencies","walk","functionNode","name","firstArgument","arguments","firstTerm","terms","value","type","observer","environmentState","dispose"],"sources":["/Users/leandrodisconzi/CascadeProjects/geodome-website/node_modules/@google/model-viewer/lib/styles/style-effector.js"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c, _d;\nimport { ASTWalker } from './parsers.js';\nconst $instances = Symbol('instances');\nconst $activateListener = Symbol('activateListener');\nconst $deactivateListener = Symbol('deactivateListener');\nconst $notifyInstances = Symbol('notifyInstances');\nconst $notify = Symbol('notify');\nconst $scrollCallback = Symbol('callback');\n/**\n * This internal helper is intended to work as a reference-counting manager of\n * scroll event listeners. Only one scroll listener is ever registered for all\n * instances of the class, and when the last ScrollObserver \"disconnects\", that\n * event listener is removed. This spares us from thrashing\n * the {add,remove}EventListener API (the binding cost of these methods has been\n * known to show up in performance analyses) as well as potential memory leaks.\n */\nclass ScrollObserver {\n    constructor(callback) {\n        this[$scrollCallback] = callback;\n    }\n    static [$notifyInstances]() {\n        for (const instance of ScrollObserver[$instances]) {\n            instance[$notify]();\n        }\n    }\n    static [(_a = $instances, $activateListener)]() {\n        window.addEventListener('scroll', this[$notifyInstances], { passive: true });\n    }\n    static [$deactivateListener]() {\n        window.removeEventListener('scroll', this[$notifyInstances]);\n    }\n    /**\n     * Listen for scroll events. The configured callback (passed to the\n     * constructor) will be invoked for subsequent global scroll events.\n     */\n    observe() {\n        if (ScrollObserver[$instances].size === 0) {\n            ScrollObserver[$activateListener]();\n        }\n        ScrollObserver[$instances].add(this);\n    }\n    /**\n     * Stop listening for scroll events.\n     */\n    disconnect() {\n        ScrollObserver[$instances].delete(this);\n        if (ScrollObserver[$instances].size === 0) {\n            ScrollObserver[$deactivateListener]();\n        }\n    }\n    [$notify]() {\n        this[$scrollCallback]();\n    }\n    ;\n}\nScrollObserver[_a] = new Set();\nconst $computeStyleCallback = Symbol('computeStyleCallback');\nconst $astWalker = Symbol('astWalker');\nconst $dependencies = Symbol('dependencies');\nconst $onScroll = Symbol('onScroll');\n/**\n * The StyleEffector is configured with a callback that will be invoked at the\n * optimal time that some array of CSS expression ASTs ought to be evaluated.\n *\n * For example, our CSS-like expression syntax supports usage of the env()\n * function to incorporate the current top-level scroll position into a CSS\n * expression: env(window-scroll-y).\n *\n * This \"environment variable\" will change dynamically as the user scrolls the\n * page. If an AST contains such a usage of env(), we would have to evaluate the\n * AST on every frame in order to be sure that the computed style stays up to\n * date.\n *\n * The StyleEffector spares us from evaluating the expressions on every frame by\n * correlating specific parts of an AST with observers of the external effects\n * that they refer to (if any). So, if the AST contains env(window-scroll-y),\n * the StyleEffector manages the lifetime of a global scroll event listener and\n * notifies the user at the optimal time to evaluate the computed style.\n */\nexport class StyleEffector {\n    constructor(callback) {\n        this[_b] = {};\n        this[_c] = new ASTWalker(['function']);\n        this[_d] = () => {\n            this[$computeStyleCallback]({ relatedState: 'window-scroll' });\n        };\n        this[$computeStyleCallback] = callback;\n    }\n    /**\n     * Sets the expressions that govern when the StyleEffector callback will be\n     * invoked.\n     */\n    observeEffectsFor(ast) {\n        const newDependencies = {};\n        const oldDependencies = this[$dependencies];\n        this[$astWalker].walk(ast, functionNode => {\n            const { name } = functionNode;\n            const firstArgument = functionNode.arguments[0];\n            const firstTerm = firstArgument.terms[0];\n            if (name.value !== 'env' || firstTerm == null ||\n                firstTerm.type !== 'ident') {\n                return;\n            }\n            switch (firstTerm.value) {\n                case 'window-scroll-y':\n                    if (newDependencies['window-scroll'] == null) {\n                        const observer = 'window-scroll' in oldDependencies ?\n                            oldDependencies['window-scroll'] :\n                            new ScrollObserver(this[$onScroll]);\n                        observer.observe();\n                        delete oldDependencies['window-scroll'];\n                        newDependencies['window-scroll'] = observer;\n                    }\n                    break;\n            }\n        });\n        for (const environmentState in oldDependencies) {\n            const observer = oldDependencies[environmentState];\n            observer.disconnect();\n        }\n        this[$dependencies] = newDependencies;\n    }\n    /**\n     * Disposes of the StyleEffector by disconnecting all observers of external\n     * effects.\n     */\n    dispose() {\n        for (const environmentState in this[$dependencies]) {\n            const observer = this[$dependencies][environmentState];\n            observer.disconnect();\n        }\n    }\n}\n_b = $dependencies, _c = $astWalker, _d = $onScroll;\n//# sourceMappingURL=style-effector.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}