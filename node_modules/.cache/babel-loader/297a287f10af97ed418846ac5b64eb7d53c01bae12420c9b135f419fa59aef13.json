{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { HDRJPGLoader } from '@monogrid/gainmap-js';\nimport { BackSide, BoxGeometry, CubeCamera, EquirectangularReflectionMapping, HalfFloatType, LinearSRGBColorSpace, Mesh, NoBlending, NoToneMapping, RGBAFormat, Scene, ShaderMaterial, SRGBColorSpace, TextureLoader, Vector3, WebGLCubeRenderTarget } from 'three';\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\nimport { deserializeUrl, timePasses } from '../utilities.js';\nimport EnvironmentScene from './EnvironmentScene.js';\nconst GENERATED_SIGMA = 0.04;\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\nconst HDR_FILE_RE = /\\.hdr(\\.js)?$/;\nexport default class TextureUtils {\n  constructor(threeRenderer) {\n    this.threeRenderer = threeRenderer;\n    this.lottieLoaderUrl = '';\n    this.withCredentials = false;\n    this._ldrLoader = null;\n    this._imageLoader = null;\n    this._hdrLoader = null;\n    this._lottieLoader = null;\n    this.generatedEnvironmentMap = null;\n    this.generatedEnvironmentMapAlt = null;\n    this.skyboxCache = new Map();\n    this.blurMaterial = null;\n    this.blurScene = null;\n  }\n  get ldrLoader() {\n    if (this._ldrLoader == null) {\n      this._ldrLoader = new TextureLoader();\n    }\n    this._ldrLoader.setWithCredentials(this.withCredentials);\n    return this._ldrLoader;\n  }\n  get imageLoader() {\n    if (this._imageLoader == null) {\n      this._imageLoader = new HDRJPGLoader(this.threeRenderer);\n    }\n    this._imageLoader.setWithCredentials(this.withCredentials);\n    return this._imageLoader;\n  }\n  get hdrLoader() {\n    if (this._hdrLoader == null) {\n      this._hdrLoader = new RGBELoader();\n      this._hdrLoader.setDataType(HalfFloatType);\n    }\n    this._hdrLoader.setWithCredentials(this.withCredentials);\n    return this._hdrLoader;\n  }\n  async getLottieLoader() {\n    if (this._lottieLoader == null) {\n      const {\n        LottieLoader\n      } = await import(/* webpackIgnore: true */this.lottieLoaderUrl);\n      this._lottieLoader = new LottieLoader();\n    }\n    this._lottieLoader.setWithCredentials(this.withCredentials);\n    return this._lottieLoader;\n  }\n  async loadImage(url) {\n    const texture = await new Promise((resolve, reject) => this.ldrLoader.load(url, resolve, () => {}, reject));\n    texture.name = url;\n    texture.flipY = false;\n    return texture;\n  }\n  async loadLottie(url, quality) {\n    const loader = await this.getLottieLoader();\n    loader.setQuality(quality);\n    const texture = await new Promise((resolve, reject) => loader.load(url, resolve, () => {}, reject));\n    texture.name = url;\n    return texture;\n  }\n  async loadEquirect(url, progressCallback = () => {}) {\n    try {\n      const isHDR = HDR_FILE_RE.test(url);\n      const loader = isHDR ? this.hdrLoader : this.imageLoader;\n      const texture = await new Promise((resolve, reject) => loader.load(url, result => {\n        const {\n          renderTarget\n        } = result;\n        if (renderTarget != null) {\n          const {\n            texture\n          } = renderTarget;\n          result.dispose(false);\n          resolve(texture);\n        } else {\n          resolve(result);\n        }\n      }, event => {\n        progressCallback(event.loaded / event.total * 0.9);\n      }, reject));\n      progressCallback(1.0);\n      texture.name = url;\n      texture.mapping = EquirectangularReflectionMapping;\n      if (!isHDR) {\n        texture.colorSpace = SRGBColorSpace;\n      }\n      return texture;\n    } finally {\n      if (progressCallback) {\n        progressCallback(1);\n      }\n    }\n  }\n  /**\n   * Returns a { skybox, environmentMap } object with the targets/textures\n   * accordingly. `skybox` is a WebGLRenderCubeTarget, and `environmentMap`\n   * is a Texture from a WebGLRenderCubeTarget.\n   */\n  async generateEnvironmentMapAndSkybox(skyboxUrl = null, environmentMapUrl = null, progressCallback = () => {}) {\n    const useAltEnvironment = environmentMapUrl !== 'legacy';\n    if (environmentMapUrl === 'legacy' || environmentMapUrl === 'neutral') {\n      environmentMapUrl = null;\n    }\n    environmentMapUrl = deserializeUrl(environmentMapUrl);\n    let skyboxLoads = Promise.resolve(null);\n    let environmentMapLoads;\n    // If we have a skybox URL, attempt to load it as a cubemap\n    if (!!skyboxUrl) {\n      skyboxLoads = this.loadEquirectFromUrl(skyboxUrl, progressCallback);\n    }\n    if (!!environmentMapUrl) {\n      // We have an available environment map URL\n      environmentMapLoads = this.loadEquirectFromUrl(environmentMapUrl, progressCallback);\n    } else if (!!skyboxUrl) {\n      // Fallback to deriving the environment map from an available skybox\n      environmentMapLoads = this.loadEquirectFromUrl(skyboxUrl, progressCallback);\n    } else {\n      // Fallback to generating the environment map\n      environmentMapLoads = useAltEnvironment ? this.loadGeneratedEnvironmentMapAlt() : this.loadGeneratedEnvironmentMap();\n    }\n    const [environmentMap, skybox] = await Promise.all([environmentMapLoads, skyboxLoads]);\n    if (environmentMap == null) {\n      throw new Error('Failed to load environment map.');\n    }\n    return {\n      environmentMap,\n      skybox\n    };\n  }\n  /**\n   * Loads an equirect Texture from a given URL, for use as a skybox.\n   */\n  async loadEquirectFromUrl(url, progressCallback) {\n    if (!this.skyboxCache.has(url)) {\n      const skyboxMapLoads = this.loadEquirect(url, progressCallback);\n      this.skyboxCache.set(url, skyboxMapLoads);\n    }\n    return this.skyboxCache.get(url);\n  }\n  async GenerateEnvironmentMap(scene, name) {\n    await timePasses();\n    const renderer = this.threeRenderer;\n    const cubeTarget = new WebGLCubeRenderTarget(256, {\n      generateMipmaps: false,\n      type: HalfFloatType,\n      format: RGBAFormat,\n      colorSpace: LinearSRGBColorSpace,\n      depthBuffer: true\n    });\n    const cubeCamera = new CubeCamera(0.1, 100, cubeTarget);\n    const generatedEnvironmentMap = cubeCamera.renderTarget.texture;\n    generatedEnvironmentMap.name = name;\n    const outputColorSpace = renderer.outputColorSpace;\n    const toneMapping = renderer.toneMapping;\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputColorSpace = LinearSRGBColorSpace;\n    cubeCamera.update(renderer, scene);\n    this.blurCubemap(cubeTarget, GENERATED_SIGMA);\n    renderer.toneMapping = toneMapping;\n    renderer.outputColorSpace = outputColorSpace;\n    return generatedEnvironmentMap;\n  }\n  /**\n   * Loads a dynamically generated environment map.\n   */\n  async loadGeneratedEnvironmentMap() {\n    if (this.generatedEnvironmentMap == null) {\n      this.generatedEnvironmentMap = this.GenerateEnvironmentMap(new EnvironmentScene('legacy'), 'legacy');\n    }\n    return this.generatedEnvironmentMap;\n  }\n  /**\n   * Loads a dynamically generated environment map, designed to be neutral and\n   * color-preserving. Shows less contrast around the different sides of the\n   * object.\n   */\n  async loadGeneratedEnvironmentMapAlt() {\n    if (this.generatedEnvironmentMapAlt == null) {\n      this.generatedEnvironmentMapAlt = this.GenerateEnvironmentMap(new EnvironmentScene('neutral'), 'neutral');\n    }\n    return this.generatedEnvironmentMapAlt;\n  }\n  blurCubemap(cubeTarget, sigma) {\n    if (this.blurMaterial == null) {\n      this.blurMaterial = this.getBlurShader(MAX_SAMPLES);\n      const box = new BoxGeometry();\n      const blurMesh = new Mesh(box, this.blurMaterial);\n      this.blurScene = new Scene();\n      this.blurScene.add(blurMesh);\n    }\n    const tempTarget = cubeTarget.clone();\n    this.halfblur(cubeTarget, tempTarget, sigma, 'latitudinal');\n    this.halfblur(tempTarget, cubeTarget, sigma, 'longitudinal');\n    // Disposing this target after we're done with it somehow corrupts Safari's\n    // whole graphics driver. It's random, but occurs more frequently on\n    // lower-powered GPUs (macbooks with intel graphics, older iPhones). It goes\n    // beyond just messing up the PMREM, as it also occasionally causes\n    // visible corruption on the canvas and even on the rest of the page.\n    /** tempTarget.dispose(); */\n  }\n  halfblur(targetIn, targetOut, sigmaRadians, direction) {\n    // Number of standard deviations at which to cut off the discrete\n    // approximation.\n    const STANDARD_DEVIATIONS = 3;\n    const pixels = targetIn.width;\n    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n    if (samples > MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n    }\n    const weights = [];\n    let sum = 0;\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp(-x * x / 2);\n      weights.push(weight);\n      if (i == 0) {\n        sum += weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n    const blurUniforms = this.blurMaterial.uniforms;\n    blurUniforms['envMap'].value = targetIn.texture;\n    blurUniforms['samples'].value = samples;\n    blurUniforms['weights'].value = weights;\n    blurUniforms['latitudinal'].value = direction === 'latitudinal';\n    blurUniforms['dTheta'].value = radiansPerPixel;\n    const cubeCamera = new CubeCamera(0.1, 100, targetOut);\n    cubeCamera.update(this.threeRenderer, this.blurScene);\n  }\n  getBlurShader(maxSamples) {\n    const weights = new Float32Array(maxSamples);\n    const poleAxis = new Vector3(0, 1, 0);\n    const shaderMaterial = new ShaderMaterial({\n      name: 'SphericalGaussianBlur',\n      defines: {\n        'n': maxSamples\n      },\n      uniforms: {\n        'envMap': {\n          value: null\n        },\n        'samples': {\n          value: 1\n        },\n        'weights': {\n          value: weights\n        },\n        'latitudinal': {\n          value: false\n        },\n        'dTheta': {\n          value: 0\n        },\n        'poleAxis': {\n          value: poleAxis\n        }\n      },\n      vertexShader: /* glsl */`\n      \n      varying vec3 vOutputDirection;\n  \n      void main() {\n  \n        vOutputDirection = vec3( position );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  \n      }\n    `,\n      fragmentShader: /* glsl */`\n        varying vec3 vOutputDirection;\n  \n        uniform samplerCube envMap;\n        uniform int samples;\n        uniform float weights[ n ];\n        uniform bool latitudinal;\n        uniform float dTheta;\n        uniform vec3 poleAxis;\n  \n        vec3 getSample( float theta, vec3 axis ) {\n  \n          float cosTheta = cos( theta );\n          // Rodrigues' axis-angle rotation\n          vec3 sampleDirection = vOutputDirection * cosTheta\n            + cross( axis, vOutputDirection ) * sin( theta )\n            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n  \n          return vec3( textureCube( envMap, sampleDirection ) );\n  \n        }\n  \n        void main() {\n  \n          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n  \n          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n  \n            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n  \n          }\n  \n          axis = normalize( axis );\n  \n          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n  \n          for ( int i = 1; i < n; i++ ) {\n  \n            if ( i >= samples ) {\n  \n              break;\n  \n            }\n  \n            float theta = dTheta * float( i );\n            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n  \n          }\n        }\n      `,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      side: BackSide\n    });\n    return shaderMaterial;\n  }\n  async dispose() {\n    for (const [, promise] of this.skyboxCache) {\n      const skybox = await promise;\n      skybox.dispose();\n    }\n    if (this.generatedEnvironmentMap != null) {\n      (await this.generatedEnvironmentMap).dispose();\n      this.generatedEnvironmentMap = null;\n    }\n    if (this.generatedEnvironmentMapAlt != null) {\n      (await this.generatedEnvironmentMapAlt).dispose();\n      this.generatedEnvironmentMapAlt = null;\n    }\n    if (this.blurMaterial != null) {\n      this.blurMaterial.dispose();\n    }\n  }\n}","map":{"version":3,"names":["HDRJPGLoader","BackSide","BoxGeometry","CubeCamera","EquirectangularReflectionMapping","HalfFloatType","LinearSRGBColorSpace","Mesh","NoBlending","NoToneMapping","RGBAFormat","Scene","ShaderMaterial","SRGBColorSpace","TextureLoader","Vector3","WebGLCubeRenderTarget","RGBELoader","deserializeUrl","timePasses","EnvironmentScene","GENERATED_SIGMA","MAX_SAMPLES","HDR_FILE_RE","TextureUtils","constructor","threeRenderer","lottieLoaderUrl","withCredentials","_ldrLoader","_imageLoader","_hdrLoader","_lottieLoader","generatedEnvironmentMap","generatedEnvironmentMapAlt","skyboxCache","Map","blurMaterial","blurScene","ldrLoader","setWithCredentials","imageLoader","hdrLoader","setDataType","getLottieLoader","LottieLoader","loadImage","url","texture","Promise","resolve","reject","load","name","flipY","loadLottie","quality","loader","setQuality","loadEquirect","progressCallback","isHDR","test","result","renderTarget","dispose","event","loaded","total","mapping","colorSpace","generateEnvironmentMapAndSkybox","skyboxUrl","environmentMapUrl","useAltEnvironment","skyboxLoads","environmentMapLoads","loadEquirectFromUrl","loadGeneratedEnvironmentMapAlt","loadGeneratedEnvironmentMap","environmentMap","skybox","all","Error","has","skyboxMapLoads","set","get","GenerateEnvironmentMap","scene","renderer","cubeTarget","generateMipmaps","type","format","depthBuffer","cubeCamera","outputColorSpace","toneMapping","update","blurCubemap","sigma","getBlurShader","box","blurMesh","add","tempTarget","clone","halfblur","targetIn","targetOut","sigmaRadians","direction","STANDARD_DEVIATIONS","pixels","width","radiansPerPixel","isFinite","Math","PI","sigmaPixels","samples","floor","console","warn","weights","sum","i","x","weight","exp","push","length","blurUniforms","uniforms","value","maxSamples","Float32Array","poleAxis","shaderMaterial","defines","vertexShader","fragmentShader","blending","depthTest","depthWrite","side","promise"],"sources":["/Users/leandrodisconzi/CascadeProjects/geodome-website/node_modules/@google/model-viewer/lib/three-components/TextureUtils.js"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { HDRJPGLoader } from '@monogrid/gainmap-js';\nimport { BackSide, BoxGeometry, CubeCamera, EquirectangularReflectionMapping, HalfFloatType, LinearSRGBColorSpace, Mesh, NoBlending, NoToneMapping, RGBAFormat, Scene, ShaderMaterial, SRGBColorSpace, TextureLoader, Vector3, WebGLCubeRenderTarget } from 'three';\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\nimport { deserializeUrl, timePasses } from '../utilities.js';\nimport EnvironmentScene from './EnvironmentScene.js';\nconst GENERATED_SIGMA = 0.04;\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\nconst HDR_FILE_RE = /\\.hdr(\\.js)?$/;\nexport default class TextureUtils {\n    constructor(threeRenderer) {\n        this.threeRenderer = threeRenderer;\n        this.lottieLoaderUrl = '';\n        this.withCredentials = false;\n        this._ldrLoader = null;\n        this._imageLoader = null;\n        this._hdrLoader = null;\n        this._lottieLoader = null;\n        this.generatedEnvironmentMap = null;\n        this.generatedEnvironmentMapAlt = null;\n        this.skyboxCache = new Map();\n        this.blurMaterial = null;\n        this.blurScene = null;\n    }\n    get ldrLoader() {\n        if (this._ldrLoader == null) {\n            this._ldrLoader = new TextureLoader();\n        }\n        this._ldrLoader.setWithCredentials(this.withCredentials);\n        return this._ldrLoader;\n    }\n    get imageLoader() {\n        if (this._imageLoader == null) {\n            this._imageLoader = new HDRJPGLoader(this.threeRenderer);\n        }\n        this._imageLoader.setWithCredentials(this.withCredentials);\n        return this._imageLoader;\n    }\n    get hdrLoader() {\n        if (this._hdrLoader == null) {\n            this._hdrLoader = new RGBELoader();\n            this._hdrLoader.setDataType(HalfFloatType);\n        }\n        this._hdrLoader.setWithCredentials(this.withCredentials);\n        return this._hdrLoader;\n    }\n    async getLottieLoader() {\n        if (this._lottieLoader == null) {\n            const { LottieLoader } = await import(/* webpackIgnore: true */ this.lottieLoaderUrl);\n            this._lottieLoader = new LottieLoader();\n        }\n        this._lottieLoader.setWithCredentials(this.withCredentials);\n        return this._lottieLoader;\n    }\n    async loadImage(url) {\n        const texture = await new Promise((resolve, reject) => this.ldrLoader.load(url, resolve, () => { }, reject));\n        texture.name = url;\n        texture.flipY = false;\n        return texture;\n    }\n    async loadLottie(url, quality) {\n        const loader = await this.getLottieLoader();\n        loader.setQuality(quality);\n        const texture = await new Promise((resolve, reject) => loader.load(url, resolve, () => { }, reject));\n        texture.name = url;\n        return texture;\n    }\n    async loadEquirect(url, progressCallback = () => { }) {\n        try {\n            const isHDR = HDR_FILE_RE.test(url);\n            const loader = isHDR ? this.hdrLoader : this.imageLoader;\n            const texture = await new Promise((resolve, reject) => loader.load(url, (result) => {\n                const { renderTarget } = result;\n                if (renderTarget != null) {\n                    const { texture } = renderTarget;\n                    result.dispose(false);\n                    resolve(texture);\n                }\n                else {\n                    resolve(result);\n                }\n            }, (event) => {\n                progressCallback(event.loaded / event.total * 0.9);\n            }, reject));\n            progressCallback(1.0);\n            texture.name = url;\n            texture.mapping = EquirectangularReflectionMapping;\n            if (!isHDR) {\n                texture.colorSpace = SRGBColorSpace;\n            }\n            return texture;\n        }\n        finally {\n            if (progressCallback) {\n                progressCallback(1);\n            }\n        }\n    }\n    /**\n     * Returns a { skybox, environmentMap } object with the targets/textures\n     * accordingly. `skybox` is a WebGLRenderCubeTarget, and `environmentMap`\n     * is a Texture from a WebGLRenderCubeTarget.\n     */\n    async generateEnvironmentMapAndSkybox(skyboxUrl = null, environmentMapUrl = null, progressCallback = () => { }) {\n        const useAltEnvironment = environmentMapUrl !== 'legacy';\n        if (environmentMapUrl === 'legacy' || environmentMapUrl === 'neutral') {\n            environmentMapUrl = null;\n        }\n        environmentMapUrl = deserializeUrl(environmentMapUrl);\n        let skyboxLoads = Promise.resolve(null);\n        let environmentMapLoads;\n        // If we have a skybox URL, attempt to load it as a cubemap\n        if (!!skyboxUrl) {\n            skyboxLoads = this.loadEquirectFromUrl(skyboxUrl, progressCallback);\n        }\n        if (!!environmentMapUrl) {\n            // We have an available environment map URL\n            environmentMapLoads =\n                this.loadEquirectFromUrl(environmentMapUrl, progressCallback);\n        }\n        else if (!!skyboxUrl) {\n            // Fallback to deriving the environment map from an available skybox\n            environmentMapLoads =\n                this.loadEquirectFromUrl(skyboxUrl, progressCallback);\n        }\n        else {\n            // Fallback to generating the environment map\n            environmentMapLoads = useAltEnvironment ?\n                this.loadGeneratedEnvironmentMapAlt() :\n                this.loadGeneratedEnvironmentMap();\n        }\n        const [environmentMap, skybox] = await Promise.all([environmentMapLoads, skyboxLoads]);\n        if (environmentMap == null) {\n            throw new Error('Failed to load environment map.');\n        }\n        return { environmentMap, skybox };\n    }\n    /**\n     * Loads an equirect Texture from a given URL, for use as a skybox.\n     */\n    async loadEquirectFromUrl(url, progressCallback) {\n        if (!this.skyboxCache.has(url)) {\n            const skyboxMapLoads = this.loadEquirect(url, progressCallback);\n            this.skyboxCache.set(url, skyboxMapLoads);\n        }\n        return this.skyboxCache.get(url);\n    }\n    async GenerateEnvironmentMap(scene, name) {\n        await timePasses();\n        const renderer = this.threeRenderer;\n        const cubeTarget = new WebGLCubeRenderTarget(256, {\n            generateMipmaps: false,\n            type: HalfFloatType,\n            format: RGBAFormat,\n            colorSpace: LinearSRGBColorSpace,\n            depthBuffer: true\n        });\n        const cubeCamera = new CubeCamera(0.1, 100, cubeTarget);\n        const generatedEnvironmentMap = cubeCamera.renderTarget.texture;\n        generatedEnvironmentMap.name = name;\n        const outputColorSpace = renderer.outputColorSpace;\n        const toneMapping = renderer.toneMapping;\n        renderer.toneMapping = NoToneMapping;\n        renderer.outputColorSpace = LinearSRGBColorSpace;\n        cubeCamera.update(renderer, scene);\n        this.blurCubemap(cubeTarget, GENERATED_SIGMA);\n        renderer.toneMapping = toneMapping;\n        renderer.outputColorSpace = outputColorSpace;\n        return generatedEnvironmentMap;\n    }\n    /**\n     * Loads a dynamically generated environment map.\n     */\n    async loadGeneratedEnvironmentMap() {\n        if (this.generatedEnvironmentMap == null) {\n            this.generatedEnvironmentMap =\n                this.GenerateEnvironmentMap(new EnvironmentScene('legacy'), 'legacy');\n        }\n        return this.generatedEnvironmentMap;\n    }\n    /**\n     * Loads a dynamically generated environment map, designed to be neutral and\n     * color-preserving. Shows less contrast around the different sides of the\n     * object.\n     */\n    async loadGeneratedEnvironmentMapAlt() {\n        if (this.generatedEnvironmentMapAlt == null) {\n            this.generatedEnvironmentMapAlt = this.GenerateEnvironmentMap(new EnvironmentScene('neutral'), 'neutral');\n        }\n        return this.generatedEnvironmentMapAlt;\n    }\n    blurCubemap(cubeTarget, sigma) {\n        if (this.blurMaterial == null) {\n            this.blurMaterial = this.getBlurShader(MAX_SAMPLES);\n            const box = new BoxGeometry();\n            const blurMesh = new Mesh(box, this.blurMaterial);\n            this.blurScene = new Scene();\n            this.blurScene.add(blurMesh);\n        }\n        const tempTarget = cubeTarget.clone();\n        this.halfblur(cubeTarget, tempTarget, sigma, 'latitudinal');\n        this.halfblur(tempTarget, cubeTarget, sigma, 'longitudinal');\n        // Disposing this target after we're done with it somehow corrupts Safari's\n        // whole graphics driver. It's random, but occurs more frequently on\n        // lower-powered GPUs (macbooks with intel graphics, older iPhones). It goes\n        // beyond just messing up the PMREM, as it also occasionally causes\n        // visible corruption on the canvas and even on the rest of the page.\n        /** tempTarget.dispose(); */\n    }\n    halfblur(targetIn, targetOut, sigmaRadians, direction) {\n        // Number of standard deviations at which to cut off the discrete\n        // approximation.\n        const STANDARD_DEVIATIONS = 3;\n        const pixels = targetIn.width;\n        const radiansPerPixel = isFinite(sigmaRadians) ?\n            Math.PI / (2 * pixels) :\n            2 * Math.PI / (2 * MAX_SAMPLES - 1);\n        const sigmaPixels = sigmaRadians / radiansPerPixel;\n        const samples = isFinite(sigmaRadians) ?\n            1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) :\n            MAX_SAMPLES;\n        if (samples > MAX_SAMPLES) {\n            console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n        }\n        const weights = [];\n        let sum = 0;\n        for (let i = 0; i < MAX_SAMPLES; ++i) {\n            const x = i / sigmaPixels;\n            const weight = Math.exp(-x * x / 2);\n            weights.push(weight);\n            if (i == 0) {\n                sum += weight;\n            }\n            else if (i < samples) {\n                sum += 2 * weight;\n            }\n        }\n        for (let i = 0; i < weights.length; i++) {\n            weights[i] = weights[i] / sum;\n        }\n        const blurUniforms = this.blurMaterial.uniforms;\n        blurUniforms['envMap'].value = targetIn.texture;\n        blurUniforms['samples'].value = samples;\n        blurUniforms['weights'].value = weights;\n        blurUniforms['latitudinal'].value = direction === 'latitudinal';\n        blurUniforms['dTheta'].value = radiansPerPixel;\n        const cubeCamera = new CubeCamera(0.1, 100, targetOut);\n        cubeCamera.update(this.threeRenderer, this.blurScene);\n    }\n    getBlurShader(maxSamples) {\n        const weights = new Float32Array(maxSamples);\n        const poleAxis = new Vector3(0, 1, 0);\n        const shaderMaterial = new ShaderMaterial({\n            name: 'SphericalGaussianBlur',\n            defines: { 'n': maxSamples },\n            uniforms: {\n                'envMap': { value: null },\n                'samples': { value: 1 },\n                'weights': { value: weights },\n                'latitudinal': { value: false },\n                'dTheta': { value: 0 },\n                'poleAxis': { value: poleAxis }\n            },\n            vertexShader: /* glsl */ `\n      \n      varying vec3 vOutputDirection;\n  \n      void main() {\n  \n        vOutputDirection = vec3( position );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  \n      }\n    `,\n            fragmentShader: /* glsl */ `\n        varying vec3 vOutputDirection;\n  \n        uniform samplerCube envMap;\n        uniform int samples;\n        uniform float weights[ n ];\n        uniform bool latitudinal;\n        uniform float dTheta;\n        uniform vec3 poleAxis;\n  \n        vec3 getSample( float theta, vec3 axis ) {\n  \n          float cosTheta = cos( theta );\n          // Rodrigues' axis-angle rotation\n          vec3 sampleDirection = vOutputDirection * cosTheta\n            + cross( axis, vOutputDirection ) * sin( theta )\n            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n  \n          return vec3( textureCube( envMap, sampleDirection ) );\n  \n        }\n  \n        void main() {\n  \n          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n  \n          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n  \n            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n  \n          }\n  \n          axis = normalize( axis );\n  \n          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n  \n          for ( int i = 1; i < n; i++ ) {\n  \n            if ( i >= samples ) {\n  \n              break;\n  \n            }\n  \n            float theta = dTheta * float( i );\n            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n  \n          }\n        }\n      `,\n            blending: NoBlending,\n            depthTest: false,\n            depthWrite: false,\n            side: BackSide\n        });\n        return shaderMaterial;\n    }\n    async dispose() {\n        for (const [, promise] of this.skyboxCache) {\n            const skybox = await promise;\n            skybox.dispose();\n        }\n        if (this.generatedEnvironmentMap != null) {\n            (await this.generatedEnvironmentMap).dispose();\n            this.generatedEnvironmentMap = null;\n        }\n        if (this.generatedEnvironmentMapAlt != null) {\n            (await this.generatedEnvironmentMapAlt).dispose();\n            this.generatedEnvironmentMapAlt = null;\n        }\n        if (this.blurMaterial != null) {\n            this.blurMaterial.dispose();\n        }\n    }\n}\n//# sourceMappingURL=TextureUtils.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}