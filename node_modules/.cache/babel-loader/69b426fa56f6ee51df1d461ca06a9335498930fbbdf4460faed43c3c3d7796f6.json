{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c, _d, _e, _f;\nimport { Mesh } from 'three';\nimport { $setActive, $variantSet, Material } from './material.js';\nimport { Node, PrimitiveNode } from './nodes/primitive-node.js';\nimport { $correlatedObjects } from './three-dom-element.js';\nexport const $materials = Symbol('materials');\nconst $hierarchy = Symbol('hierarchy');\nconst $roots = Symbol('roots');\nexport const $primitivesList = Symbol('primitives');\nexport const $loadVariant = Symbol('loadVariant');\nexport const $prepareVariantsForExport = Symbol('prepareVariantsForExport');\nexport const $switchVariant = Symbol('switchVariant');\nexport const $materialFromPoint = Symbol('materialFromPoint');\nexport const $nodeFromPoint = Symbol('nodeFromPoint');\nexport const $nodeFromIndex = Symbol('nodeFromIndex');\nexport const $variantData = Symbol('variantData');\nexport const $availableVariants = Symbol('availableVariants');\nconst $modelOnUpdate = Symbol('modelOnUpdate');\nconst $cloneMaterial = Symbol('cloneMaterial');\n// Holds onto temporary scene context information needed to perform lazy loading\n// of a resource.\nexport class LazyLoader {\n  constructor(gltf, gltfElementMap, mapKey, doLazyLoad) {\n    this.gltf = gltf;\n    this.gltfElementMap = gltfElementMap;\n    this.mapKey = mapKey;\n    this.doLazyLoad = doLazyLoad;\n  }\n}\n/**\n * A Model facades the top-level GLTF object returned by Three.js' GLTFLoader.\n * Currently, the model only bothers itself with the materials in the Three.js\n * scene graph.\n */\nexport class Model {\n  constructor(correlatedSceneGraph, onUpdate = () => {}) {\n    this[_a] = new Array();\n    this[_b] = new Array();\n    this[_c] = new Array();\n    this[_d] = new Array();\n    this[_e] = () => {};\n    this[_f] = new Map();\n    this[$modelOnUpdate] = onUpdate;\n    const {\n      gltf,\n      threeGLTF,\n      gltfElementMap\n    } = correlatedSceneGraph;\n    for (const [i, material] of gltf.materials.entries()) {\n      const correlatedMaterial = gltfElementMap.get(material);\n      if (correlatedMaterial != null) {\n        this[$materials].push(new Material(onUpdate, i, true, this[$variantData], correlatedMaterial, material.name));\n      } else {\n        const elementArray = gltf['materials'] || [];\n        const gltfMaterialDef = elementArray[i];\n        // Loads the three.js material.\n        const capturedMatIndex = i;\n        const materialLoadCallback = async () => {\n          const threeMaterial = await threeGLTF.parser.getDependency('material', capturedMatIndex);\n          // Adds correlation, maps the variant gltf-def to the\n          // three material set containing the variant material.\n          const threeMaterialSet = new Set();\n          gltfElementMap.set(gltfMaterialDef, threeMaterialSet);\n          threeMaterialSet.add(threeMaterial);\n          return {\n            set: threeMaterialSet,\n            material: threeMaterial\n          };\n        };\n        // Configures the material for lazy loading.\n        this[$materials].push(new Material(onUpdate, i, false, this[$variantData], correlatedMaterial, material.name, new LazyLoader(gltf, gltfElementMap, gltfMaterialDef, materialLoadCallback)));\n      }\n    }\n    // Creates a hierarchy of Nodes. Allows not just for switching which\n    // material is applied to a mesh but also exposes a way to provide API\n    // for switching materials and general assignment/modification.\n    // Prepares for scene iteration.\n    const parentMap = new Map();\n    const nodeStack = new Array();\n    for (const object of threeGLTF.scene.children) {\n      nodeStack.push(object);\n    }\n    // Walks the hierarchy and creates a node tree.\n    while (nodeStack.length > 0) {\n      const object = nodeStack.pop();\n      let node = null;\n      if (object instanceof Mesh) {\n        node = new PrimitiveNode(object, this.materials, this[$variantData], correlatedSceneGraph);\n        this[$primitivesList].push(node);\n      } else {\n        node = new Node(object.name);\n      }\n      const parent = parentMap.get(object);\n      if (parent != null) {\n        parent.children.push(node);\n      } else {\n        this[$roots].push(node);\n      }\n      this[$hierarchy].push(node);\n      for (const child of object.children) {\n        nodeStack.push(child);\n        parentMap.set(object, node);\n      }\n    }\n  }\n  /**\n   * Materials are listed in the order of the GLTF materials array, plus a\n   * default material at the end if one is used.\n   *\n   * TODO(#1003): How do we handle non-active scenes?\n   */\n  get materials() {\n    return this[$materials];\n  }\n  [(_a = $materials, _b = $hierarchy, _c = $roots, _d = $primitivesList, _e = $modelOnUpdate, _f = $variantData, $availableVariants)]() {\n    const variants = Array.from(this[$variantData].values());\n    variants.sort((a, b) => {\n      return a.index - b.index;\n    });\n    return variants.map(data => {\n      return data.name;\n    });\n  }\n  getMaterialByName(name) {\n    const matches = this[$materials].filter(material => {\n      return material.name === name;\n    });\n    if (matches.length > 0) {\n      return matches[0];\n    }\n    return null;\n  }\n  [$nodeFromIndex](mesh, primitive) {\n    const found = this[$hierarchy].find(node => {\n      if (node instanceof PrimitiveNode) {\n        const {\n          meshes,\n          primitives\n        } = node.mesh.userData.associations;\n        if (meshes == mesh && primitives == primitive) {\n          return true;\n        }\n      }\n      return false;\n    });\n    return found == null ? null : found;\n  }\n  [$nodeFromPoint](hit) {\n    return this[$hierarchy].find(node => {\n      if (node instanceof PrimitiveNode) {\n        const primitive = node;\n        if (primitive.mesh === hit.object) {\n          return true;\n        }\n      }\n      return false;\n    });\n  }\n  /**\n   * Intersects a ray with the Model and returns the first material whose\n   * object was intersected.\n   */\n  [$materialFromPoint](hit) {\n    return this[$nodeFromPoint](hit).getActiveMaterial();\n  }\n  /**\n   * Switches model variant to the variant name provided, or switches to\n   * default/initial materials if 'null' is provided.\n   */\n  async [$switchVariant](variantName) {\n    for (const primitive of this[$primitivesList]) {\n      await primitive.enableVariant(variantName);\n    }\n    for (const material of this.materials) {\n      material[$setActive](false);\n    }\n    // Marks the materials that are now in use after the variant switch.\n    for (const primitive of this[$primitivesList]) {\n      this.materials[primitive.getActiveMaterial().index][$setActive](true);\n    }\n  }\n  async [$prepareVariantsForExport]() {\n    const promises = new Array();\n    for (const primitive of this[$primitivesList]) {\n      promises.push(primitive.instantiateVariants());\n    }\n    await Promise.all(promises);\n  }\n  [$cloneMaterial](index, newMaterialName) {\n    const material = this.materials[index];\n    if (!material.isLoaded) {\n      console.error(`Cloning an unloaded material,\n           call 'material.ensureLoaded() before cloning the material.`);\n    }\n    const threeMaterialSet = material[$correlatedObjects];\n    const clonedSet = new Set();\n    for (const [i, threeMaterial] of threeMaterialSet.entries()) {\n      const clone = threeMaterial.clone();\n      clone.name = newMaterialName + (threeMaterialSet.size > 1 ? '_inst' + i : '');\n      clonedSet.add(clone);\n    }\n    const clonedMaterial = new Material(this[$modelOnUpdate], this[$materials].length, false,\n    // Cloned as inactive.\n    this[$variantData], clonedSet, newMaterialName);\n    this[$materials].push(clonedMaterial);\n    return clonedMaterial;\n  }\n  createMaterialInstanceForVariant(originalMaterialIndex, newMaterialName, variantName, activateVariant = true) {\n    let variantMaterialInstance = null;\n    for (const primitive of this[$primitivesList]) {\n      const variantData = this[$variantData].get(variantName);\n      // Skips the primitive if the variant already exists.\n      if (variantData != null && primitive.variantInfo.has(variantData.index)) {\n        continue;\n      }\n      // Skips the primitive if the source/original material does not exist.\n      if (primitive.getMaterial(originalMaterialIndex) == null) {\n        continue;\n      }\n      if (!this.hasVariant(variantName)) {\n        this.createVariant(variantName);\n      }\n      if (variantMaterialInstance == null) {\n        variantMaterialInstance = this[$cloneMaterial](originalMaterialIndex, newMaterialName);\n      }\n      primitive.addVariant(variantMaterialInstance, variantName);\n    }\n    if (activateVariant && variantMaterialInstance != null) {\n      variantMaterialInstance[$setActive](true);\n      this.materials[originalMaterialIndex][$setActive](false);\n      for (const primitive of this[$primitivesList]) {\n        primitive.enableVariant(variantName);\n      }\n    }\n    return variantMaterialInstance;\n  }\n  createVariant(variantName) {\n    if (!this[$variantData].has(variantName)) {\n      // Adds the name if it's not already in the list.\n      this[$variantData].set(variantName, {\n        name: variantName,\n        index: this[$variantData].size\n      });\n    } else {\n      console.warn(`Variant '${variantName}'' already exists`);\n    }\n  }\n  hasVariant(variantName) {\n    return this[$variantData].has(variantName);\n  }\n  setMaterialToVariant(materialIndex, targetVariantName) {\n    if (this[$availableVariants]().find(name => name === targetVariantName) == null) {\n      console.warn(`Can't add material to '${targetVariantName}', the variant does not exist.'`);\n      return;\n    }\n    if (materialIndex < 0 || materialIndex >= this.materials.length) {\n      console.error(`setMaterialToVariant(): materialIndex is out of bounds.`);\n      return;\n    }\n    for (const primitive of this[$primitivesList]) {\n      const material = primitive.getMaterial(materialIndex);\n      // Ensures the material exists on the primitive before setting it to a\n      // variant.\n      if (material != null) {\n        primitive.addVariant(material, targetVariantName);\n      }\n    }\n  }\n  updateVariantName(currentName, newName) {\n    const variantData = this[$variantData].get(currentName);\n    if (variantData == null) {\n      return;\n    }\n    variantData.name = newName;\n    this[$variantData].set(newName, variantData);\n    this[$variantData].delete(currentName);\n  }\n  deleteVariant(variantName) {\n    const variant = this[$variantData].get(variantName);\n    if (variant == null) {\n      return;\n    }\n    for (const material of this.materials) {\n      if (material.hasVariant(variantName)) {\n        material[$variantSet].delete(variant.index);\n      }\n    }\n    for (const primitive of this[$primitivesList]) {\n      primitive.deleteVariant(variant.index);\n    }\n    this[$variantData].delete(variantName);\n  }\n}","map":{"version":3,"names":["_a","_b","_c","_d","_e","_f","Mesh","$setActive","$variantSet","Material","Node","PrimitiveNode","$correlatedObjects","$materials","Symbol","$hierarchy","$roots","$primitivesList","$loadVariant","$prepareVariantsForExport","$switchVariant","$materialFromPoint","$nodeFromPoint","$nodeFromIndex","$variantData","$availableVariants","$modelOnUpdate","$cloneMaterial","LazyLoader","constructor","gltf","gltfElementMap","mapKey","doLazyLoad","Model","correlatedSceneGraph","onUpdate","Array","Map","threeGLTF","i","material","materials","entries","correlatedMaterial","get","push","name","elementArray","gltfMaterialDef","capturedMatIndex","materialLoadCallback","threeMaterial","parser","getDependency","threeMaterialSet","Set","set","add","parentMap","nodeStack","object","scene","children","length","pop","node","parent","child","variants","from","values","sort","a","b","index","map","data","getMaterialByName","matches","filter","mesh","primitive","found","find","meshes","primitives","userData","associations","hit","getActiveMaterial","variantName","enableVariant","promises","instantiateVariants","Promise","all","newMaterialName","isLoaded","console","error","clonedSet","clone","size","clonedMaterial","createMaterialInstanceForVariant","originalMaterialIndex","activateVariant","variantMaterialInstance","variantData","variantInfo","has","getMaterial","hasVariant","createVariant","addVariant","warn","setMaterialToVariant","materialIndex","targetVariantName","updateVariantName","currentName","newName","delete","deleteVariant","variant"],"sources":["/Users/leandrodisconzi/CascadeProjects/geodome-website/node_modules/@google/model-viewer/lib/features/scene-graph/model.js"],"sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c, _d, _e, _f;\nimport { Mesh } from 'three';\nimport { $setActive, $variantSet, Material } from './material.js';\nimport { Node, PrimitiveNode } from './nodes/primitive-node.js';\nimport { $correlatedObjects } from './three-dom-element.js';\nexport const $materials = Symbol('materials');\nconst $hierarchy = Symbol('hierarchy');\nconst $roots = Symbol('roots');\nexport const $primitivesList = Symbol('primitives');\nexport const $loadVariant = Symbol('loadVariant');\nexport const $prepareVariantsForExport = Symbol('prepareVariantsForExport');\nexport const $switchVariant = Symbol('switchVariant');\nexport const $materialFromPoint = Symbol('materialFromPoint');\nexport const $nodeFromPoint = Symbol('nodeFromPoint');\nexport const $nodeFromIndex = Symbol('nodeFromIndex');\nexport const $variantData = Symbol('variantData');\nexport const $availableVariants = Symbol('availableVariants');\nconst $modelOnUpdate = Symbol('modelOnUpdate');\nconst $cloneMaterial = Symbol('cloneMaterial');\n// Holds onto temporary scene context information needed to perform lazy loading\n// of a resource.\nexport class LazyLoader {\n    constructor(gltf, gltfElementMap, mapKey, doLazyLoad) {\n        this.gltf = gltf;\n        this.gltfElementMap = gltfElementMap;\n        this.mapKey = mapKey;\n        this.doLazyLoad = doLazyLoad;\n    }\n}\n/**\n * A Model facades the top-level GLTF object returned by Three.js' GLTFLoader.\n * Currently, the model only bothers itself with the materials in the Three.js\n * scene graph.\n */\nexport class Model {\n    constructor(correlatedSceneGraph, onUpdate = () => { }) {\n        this[_a] = new Array();\n        this[_b] = new Array();\n        this[_c] = new Array();\n        this[_d] = new Array();\n        this[_e] = () => { };\n        this[_f] = new Map();\n        this[$modelOnUpdate] = onUpdate;\n        const { gltf, threeGLTF, gltfElementMap } = correlatedSceneGraph;\n        for (const [i, material] of gltf.materials.entries()) {\n            const correlatedMaterial = gltfElementMap.get(material);\n            if (correlatedMaterial != null) {\n                this[$materials].push(new Material(onUpdate, i, true, this[$variantData], correlatedMaterial, material.name));\n            }\n            else {\n                const elementArray = gltf['materials'] || [];\n                const gltfMaterialDef = elementArray[i];\n                // Loads the three.js material.\n                const capturedMatIndex = i;\n                const materialLoadCallback = async () => {\n                    const threeMaterial = await threeGLTF.parser.getDependency('material', capturedMatIndex);\n                    // Adds correlation, maps the variant gltf-def to the\n                    // three material set containing the variant material.\n                    const threeMaterialSet = new Set();\n                    gltfElementMap.set(gltfMaterialDef, threeMaterialSet);\n                    threeMaterialSet.add(threeMaterial);\n                    return { set: threeMaterialSet, material: threeMaterial };\n                };\n                // Configures the material for lazy loading.\n                this[$materials].push(new Material(onUpdate, i, false, this[$variantData], correlatedMaterial, material.name, new LazyLoader(gltf, gltfElementMap, gltfMaterialDef, materialLoadCallback)));\n            }\n        }\n        // Creates a hierarchy of Nodes. Allows not just for switching which\n        // material is applied to a mesh but also exposes a way to provide API\n        // for switching materials and general assignment/modification.\n        // Prepares for scene iteration.\n        const parentMap = new Map();\n        const nodeStack = new Array();\n        for (const object of threeGLTF.scene.children) {\n            nodeStack.push(object);\n        }\n        // Walks the hierarchy and creates a node tree.\n        while (nodeStack.length > 0) {\n            const object = nodeStack.pop();\n            let node = null;\n            if (object instanceof Mesh) {\n                node = new PrimitiveNode(object, this.materials, this[$variantData], correlatedSceneGraph);\n                this[$primitivesList].push(node);\n            }\n            else {\n                node = new Node(object.name);\n            }\n            const parent = parentMap.get(object);\n            if (parent != null) {\n                parent.children.push(node);\n            }\n            else {\n                this[$roots].push(node);\n            }\n            this[$hierarchy].push(node);\n            for (const child of object.children) {\n                nodeStack.push(child);\n                parentMap.set(object, node);\n            }\n        }\n    }\n    /**\n     * Materials are listed in the order of the GLTF materials array, plus a\n     * default material at the end if one is used.\n     *\n     * TODO(#1003): How do we handle non-active scenes?\n     */\n    get materials() {\n        return this[$materials];\n    }\n    [(_a = $materials, _b = $hierarchy, _c = $roots, _d = $primitivesList, _e = $modelOnUpdate, _f = $variantData, $availableVariants)]() {\n        const variants = Array.from(this[$variantData].values());\n        variants.sort((a, b) => {\n            return a.index - b.index;\n        });\n        return variants.map((data) => {\n            return data.name;\n        });\n    }\n    getMaterialByName(name) {\n        const matches = this[$materials].filter(material => {\n            return material.name === name;\n        });\n        if (matches.length > 0) {\n            return matches[0];\n        }\n        return null;\n    }\n    [$nodeFromIndex](mesh, primitive) {\n        const found = this[$hierarchy].find((node) => {\n            if (node instanceof PrimitiveNode) {\n                const { meshes, primitives } = node.mesh.userData.associations;\n                if (meshes == mesh && primitives == primitive) {\n                    return true;\n                }\n            }\n            return false;\n        });\n        return found == null ? null : found;\n    }\n    [$nodeFromPoint](hit) {\n        return this[$hierarchy].find((node) => {\n            if (node instanceof PrimitiveNode) {\n                const primitive = node;\n                if (primitive.mesh === hit.object) {\n                    return true;\n                }\n            }\n            return false;\n        });\n    }\n    /**\n     * Intersects a ray with the Model and returns the first material whose\n     * object was intersected.\n     */\n    [$materialFromPoint](hit) {\n        return this[$nodeFromPoint](hit).getActiveMaterial();\n    }\n    /**\n     * Switches model variant to the variant name provided, or switches to\n     * default/initial materials if 'null' is provided.\n     */\n    async [$switchVariant](variantName) {\n        for (const primitive of this[$primitivesList]) {\n            await primitive.enableVariant(variantName);\n        }\n        for (const material of this.materials) {\n            material[$setActive](false);\n        }\n        // Marks the materials that are now in use after the variant switch.\n        for (const primitive of this[$primitivesList]) {\n            this.materials[primitive.getActiveMaterial().index][$setActive](true);\n        }\n    }\n    async [$prepareVariantsForExport]() {\n        const promises = new Array();\n        for (const primitive of this[$primitivesList]) {\n            promises.push(primitive.instantiateVariants());\n        }\n        await Promise.all(promises);\n    }\n    [$cloneMaterial](index, newMaterialName) {\n        const material = this.materials[index];\n        if (!material.isLoaded) {\n            console.error(`Cloning an unloaded material,\n           call 'material.ensureLoaded() before cloning the material.`);\n        }\n        const threeMaterialSet = material[$correlatedObjects];\n        const clonedSet = new Set();\n        for (const [i, threeMaterial] of threeMaterialSet.entries()) {\n            const clone = threeMaterial.clone();\n            clone.name =\n                newMaterialName + (threeMaterialSet.size > 1 ? '_inst' + i : '');\n            clonedSet.add(clone);\n        }\n        const clonedMaterial = new Material(this[$modelOnUpdate], this[$materials].length, false, // Cloned as inactive.\n        this[$variantData], clonedSet, newMaterialName);\n        this[$materials].push(clonedMaterial);\n        return clonedMaterial;\n    }\n    createMaterialInstanceForVariant(originalMaterialIndex, newMaterialName, variantName, activateVariant = true) {\n        let variantMaterialInstance = null;\n        for (const primitive of this[$primitivesList]) {\n            const variantData = this[$variantData].get(variantName);\n            // Skips the primitive if the variant already exists.\n            if (variantData != null && primitive.variantInfo.has(variantData.index)) {\n                continue;\n            }\n            // Skips the primitive if the source/original material does not exist.\n            if (primitive.getMaterial(originalMaterialIndex) == null) {\n                continue;\n            }\n            if (!this.hasVariant(variantName)) {\n                this.createVariant(variantName);\n            }\n            if (variantMaterialInstance == null) {\n                variantMaterialInstance =\n                    this[$cloneMaterial](originalMaterialIndex, newMaterialName);\n            }\n            primitive.addVariant(variantMaterialInstance, variantName);\n        }\n        if (activateVariant && variantMaterialInstance != null) {\n            variantMaterialInstance[$setActive](true);\n            this.materials[originalMaterialIndex][$setActive](false);\n            for (const primitive of this[$primitivesList]) {\n                primitive.enableVariant(variantName);\n            }\n        }\n        return variantMaterialInstance;\n    }\n    createVariant(variantName) {\n        if (!this[$variantData].has(variantName)) {\n            // Adds the name if it's not already in the list.\n            this[$variantData].set(variantName, { name: variantName, index: this[$variantData].size });\n        }\n        else {\n            console.warn(`Variant '${variantName}'' already exists`);\n        }\n    }\n    hasVariant(variantName) {\n        return this[$variantData].has(variantName);\n    }\n    setMaterialToVariant(materialIndex, targetVariantName) {\n        if (this[$availableVariants]().find(name => name === targetVariantName) ==\n            null) {\n            console.warn(`Can't add material to '${targetVariantName}', the variant does not exist.'`);\n            return;\n        }\n        if (materialIndex < 0 || materialIndex >= this.materials.length) {\n            console.error(`setMaterialToVariant(): materialIndex is out of bounds.`);\n            return;\n        }\n        for (const primitive of this[$primitivesList]) {\n            const material = primitive.getMaterial(materialIndex);\n            // Ensures the material exists on the primitive before setting it to a\n            // variant.\n            if (material != null) {\n                primitive.addVariant(material, targetVariantName);\n            }\n        }\n    }\n    updateVariantName(currentName, newName) {\n        const variantData = this[$variantData].get(currentName);\n        if (variantData == null) {\n            return;\n        }\n        variantData.name = newName;\n        this[$variantData].set(newName, variantData);\n        this[$variantData].delete(currentName);\n    }\n    deleteVariant(variantName) {\n        const variant = this[$variantData].get(variantName);\n        if (variant == null) {\n            return;\n        }\n        for (const material of this.materials) {\n            if (material.hasVariant(variantName)) {\n                material[$variantSet].delete(variant.index);\n            }\n        }\n        for (const primitive of this[$primitivesList]) {\n            primitive.deleteVariant(variant.index);\n        }\n        this[$variantData].delete(variantName);\n    }\n}\n//# sourceMappingURL=model.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}