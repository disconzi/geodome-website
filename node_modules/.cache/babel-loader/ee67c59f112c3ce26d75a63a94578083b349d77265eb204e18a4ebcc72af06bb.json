{"ast":null,"code":"/* @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @param object {THREE.Object3D}\n * @return {boolean}\n */\nconst compatibleObject = object => {\n  // @TODO: Need properer variantMaterials format validation?\n  return object.material !== undefined &&\n  // easier than (!object.isMesh && !object.isLine &&\n  // !object.isPoints)\n  object.userData &&\n  // just in case\n  object.userData.variantMaterials &&\n  // Is this line costly?\n  !!Array.from(object.userData.variantMaterials.values()).filter(m => compatibleMaterial(m.material));\n};\n/**\n * @param material {THREE.Material}\n * @return {boolean}\n */\nconst compatibleMaterial = material => {\n  // @TODO: support multi materials?\n  return material && material.isMaterial && !Array.isArray(material);\n};\nexport default class GLTFExporterMaterialsVariantsExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_variants';\n    this.variantNames = [];\n  }\n  beforeParse(objects) {\n    // Find all variant names and store them to the table\n    const variantNameSet = new Set();\n    for (const object of objects) {\n      object.traverse(o => {\n        if (!compatibleObject(o)) {\n          return;\n        }\n        const variantMaterials = o.userData.variantMaterials;\n        const variantDataMap = o.userData.variantData;\n        for (const [variantName, variantData] of variantDataMap) {\n          const variantMaterial = variantMaterials.get(variantData.index);\n          // Ignore unloaded variant materials\n          if (variantMaterial && compatibleMaterial(variantMaterial.material)) {\n            variantNameSet.add(variantName);\n          }\n        }\n      });\n    }\n    // We may want to sort?\n    variantNameSet.forEach(name => this.variantNames.push(name));\n  }\n  writeMesh(mesh, meshDef) {\n    if (!compatibleObject(mesh)) {\n      return;\n    }\n    const userData = mesh.userData;\n    const variantMaterials = userData.variantMaterials;\n    const variantDataMap = userData.variantData;\n    const mappingTable = new Map();\n    // Removes gaps in the variant indices list (caused by deleting variants).\n    const reIndexedVariants = new Map();\n    const variants = Array.from(variantDataMap.values()).sort((a, b) => {\n      return a.index - b.index;\n    });\n    for (const [i, variantData] of variants.entries()) {\n      reIndexedVariants.set(variantData.index, i);\n    }\n    for (const variantData of variantDataMap.values()) {\n      const variantInstance = variantMaterials.get(variantData.index);\n      if (!variantInstance || !compatibleMaterial(variantInstance.material)) {\n        continue;\n      }\n      const materialIndex = this.writer.processMaterial(variantInstance.material);\n      if (!mappingTable.has(materialIndex)) {\n        mappingTable.set(materialIndex, {\n          material: materialIndex,\n          variants: []\n        });\n      }\n      mappingTable.get(materialIndex).variants.push(reIndexedVariants.get(variantData.index));\n    }\n    const mappingsDef = Array.from(mappingTable.values()).map(m => {\n      return m.variants.sort((a, b) => a - b) && m;\n    }).sort((a, b) => a.material - b.material);\n    if (mappingsDef.length === 0) {\n      return;\n    }\n    const originalMaterialIndex = compatibleMaterial(userData.originalMaterial) ? this.writer.processMaterial(userData.originalMaterial) : -1;\n    for (const primitiveDef of meshDef.primitives) {\n      // Override primitiveDef.material with original material.\n      if (originalMaterialIndex >= 0) {\n        primitiveDef.material = originalMaterialIndex;\n      }\n      primitiveDef.extensions = primitiveDef.extensions || {};\n      primitiveDef.extensions[this.name] = {\n        mappings: mappingsDef\n      };\n    }\n  }\n  afterParse() {\n    if (this.variantNames.length === 0) {\n      return;\n    }\n    const root = this.writer.json;\n    root.extensions = root.extensions || {};\n    const variantsDef = this.variantNames.map(n => {\n      return {\n        name: n\n      };\n    });\n    root.extensions[this.name] = {\n      variants: variantsDef\n    };\n    this.writer.extensionsUsed[this.name] = true;\n  }\n}","map":{"version":3,"names":["compatibleObject","object","material","undefined","userData","variantMaterials","Array","from","values","filter","m","compatibleMaterial","isMaterial","isArray","GLTFExporterMaterialsVariantsExtension","constructor","writer","name","variantNames","beforeParse","objects","variantNameSet","Set","traverse","o","variantDataMap","variantData","variantName","variantMaterial","get","index","add","forEach","push","writeMesh","mesh","meshDef","mappingTable","Map","reIndexedVariants","variants","sort","a","b","i","entries","set","variantInstance","materialIndex","processMaterial","has","mappingsDef","map","length","originalMaterialIndex","originalMaterial","primitiveDef","primitives","extensions","mappings","afterParse","root","json","variantsDef","n","extensionsUsed"],"sources":["/Users/leandrodisconzi/CascadeProjects/geodome-website/node_modules/@google/model-viewer/lib/three-components/gltf-instance/VariantMaterialExporterPlugin.js"],"sourcesContent":["/* @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @param object {THREE.Object3D}\n * @return {boolean}\n */\nconst compatibleObject = (object) => {\n    // @TODO: Need properer variantMaterials format validation?\n    return object.material !==\n        undefined && // easier than (!object.isMesh && !object.isLine &&\n        // !object.isPoints)\n        object.userData && // just in case\n        object.userData.variantMaterials &&\n        // Is this line costly?\n        !!Array\n            .from(object.userData.variantMaterials\n            .values())\n            .filter(m => compatibleMaterial(m.material));\n};\n/**\n * @param material {THREE.Material}\n * @return {boolean}\n */\nconst compatibleMaterial = (material) => {\n    // @TODO: support multi materials?\n    return material && material.isMaterial && !Array.isArray(material);\n};\nexport default class GLTFExporterMaterialsVariantsExtension {\n    constructor(writer) {\n        this.writer = writer;\n        this.name = 'KHR_materials_variants';\n        this.variantNames = [];\n    }\n    beforeParse(objects) {\n        // Find all variant names and store them to the table\n        const variantNameSet = new Set();\n        for (const object of objects) {\n            object.traverse(o => {\n                if (!compatibleObject(o)) {\n                    return;\n                }\n                const variantMaterials = o.userData.variantMaterials;\n                const variantDataMap = o.userData.variantData;\n                for (const [variantName, variantData] of variantDataMap) {\n                    const variantMaterial = variantMaterials.get(variantData.index);\n                    // Ignore unloaded variant materials\n                    if (variantMaterial && compatibleMaterial(variantMaterial.material)) {\n                        variantNameSet.add(variantName);\n                    }\n                }\n            });\n        }\n        // We may want to sort?\n        variantNameSet.forEach(name => this.variantNames.push(name));\n    }\n    writeMesh(mesh, meshDef) {\n        if (!compatibleObject(mesh)) {\n            return;\n        }\n        const userData = mesh.userData;\n        const variantMaterials = userData.variantMaterials;\n        const variantDataMap = userData.variantData;\n        const mappingTable = new Map();\n        // Removes gaps in the variant indices list (caused by deleting variants).\n        const reIndexedVariants = new Map();\n        const variants = Array.from(variantDataMap.values()).sort((a, b) => {\n            return a.index - b.index;\n        });\n        for (const [i, variantData] of variants.entries()) {\n            reIndexedVariants.set(variantData.index, i);\n        }\n        for (const variantData of variantDataMap.values()) {\n            const variantInstance = variantMaterials.get(variantData.index);\n            if (!variantInstance || !compatibleMaterial(variantInstance.material)) {\n                continue;\n            }\n            const materialIndex = this.writer.processMaterial(variantInstance.material);\n            if (!mappingTable.has(materialIndex)) {\n                mappingTable.set(materialIndex, { material: materialIndex, variants: [] });\n            }\n            mappingTable.get(materialIndex).variants.push(reIndexedVariants.get(variantData.index));\n        }\n        const mappingsDef = Array.from(mappingTable.values())\n            .map((m => { return m.variants.sort((a, b) => a - b) && m; }))\n            .sort((a, b) => a.material - b.material);\n        if (mappingsDef.length === 0) {\n            return;\n        }\n        const originalMaterialIndex = compatibleMaterial(userData.originalMaterial) ?\n            this.writer.processMaterial(userData.originalMaterial) :\n            -1;\n        for (const primitiveDef of meshDef.primitives) {\n            // Override primitiveDef.material with original material.\n            if (originalMaterialIndex >= 0) {\n                primitiveDef.material = originalMaterialIndex;\n            }\n            primitiveDef.extensions = primitiveDef.extensions || {};\n            primitiveDef.extensions[this.name] = { mappings: mappingsDef };\n        }\n    }\n    afterParse() {\n        if (this.variantNames.length === 0) {\n            return;\n        }\n        const root = this.writer.json;\n        root.extensions = root.extensions || {};\n        const variantsDef = this.variantNames.map(n => {\n            return { name: n };\n        });\n        root.extensions[this.name] = { variants: variantsDef };\n        this.writer.extensionsUsed[this.name] = true;\n    }\n}\n//# sourceMappingURL=VariantMaterialExporterPlugin.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}