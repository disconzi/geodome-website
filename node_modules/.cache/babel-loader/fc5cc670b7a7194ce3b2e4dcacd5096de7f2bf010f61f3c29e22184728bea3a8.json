{"ast":null,"code":"/* @license\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Euler, EventDispatcher, Matrix3, Spherical, Vector2, Vector3 } from 'three';\nimport { $panElement } from '../features/controls.js';\nimport { clamp } from '../utilities.js';\nimport { Damper, SETTLING_TIME } from './Damper.js';\nconst PAN_SENSITIVITY = 0.018;\nconst TAP_DISTANCE = 2;\nconst TAP_MS = 300;\nconst vector2 = new Vector2();\nconst vector3 = new Vector3();\nexport const DEFAULT_OPTIONS = Object.freeze({\n  minimumRadius: 0,\n  maximumRadius: Infinity,\n  minimumPolarAngle: Math.PI / 8,\n  maximumPolarAngle: Math.PI - Math.PI / 8,\n  minimumAzimuthalAngle: -Infinity,\n  maximumAzimuthalAngle: Infinity,\n  minimumFieldOfView: 10,\n  maximumFieldOfView: 45,\n  touchAction: 'none'\n});\n// Constants\nconst KEYBOARD_ORBIT_INCREMENT = Math.PI / 8;\nconst ZOOM_SENSITIVITY = 0.04;\n// The move size on pan key event\nconst PAN_KEY_INCREMENT = 10;\nexport const KeyCode = {\n  PAGE_UP: 33,\n  PAGE_DOWN: 34,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40\n};\nexport const ChangeSource = {\n  USER_INTERACTION: 'user-interaction',\n  NONE: 'none',\n  AUTOMATIC: 'automatic'\n};\n/**\n * SmoothControls is a Three.js helper for adding delightful pointer and\n * keyboard-based input to a staged Three.js scene. Its API is very similar to\n * OrbitControls, but it offers more opinionated (subjectively more delightful)\n * defaults, easy extensibility and subjectively better out-of-the-box keyboard\n * support.\n *\n * One important change compared to OrbitControls is that the `update` method\n * of SmoothControls must be invoked on every frame, otherwise the controls\n * will not have an effect.\n *\n * Another notable difference compared to OrbitControls is that SmoothControls\n * does not currently support panning (but probably will in a future revision).\n *\n * Like OrbitControls, SmoothControls assumes that the orientation of the camera\n * has been set in terms of position, rotation and scale, so it is important to\n * ensure that the camera's matrixWorld is in sync before using SmoothControls.\n */\nexport class SmoothControls extends EventDispatcher {\n  constructor(camera, element, scene) {\n    super();\n    this.camera = camera;\n    this.element = element;\n    this.scene = scene;\n    this.orbitSensitivity = 1;\n    this.zoomSensitivity = 1;\n    this.panSensitivity = 1;\n    this.inputSensitivity = 1;\n    this.changeSource = ChangeSource.NONE;\n    this._interactionEnabled = false;\n    this._disableZoom = false;\n    this.isUserPointing = false;\n    // Pan state\n    this.enablePan = true;\n    this.enableTap = true;\n    this.panProjection = new Matrix3();\n    this.panPerPixel = 0;\n    // Internal orbital position state\n    this.spherical = new Spherical();\n    this.goalSpherical = new Spherical();\n    this.thetaDamper = new Damper();\n    this.phiDamper = new Damper();\n    this.radiusDamper = new Damper();\n    this.logFov = Math.log(DEFAULT_OPTIONS.maximumFieldOfView);\n    this.goalLogFov = this.logFov;\n    this.fovDamper = new Damper();\n    // Pointer state\n    this.touchMode = null;\n    this.pointers = [];\n    this.startTime = 0;\n    this.startPointerPosition = {\n      clientX: 0,\n      clientY: 0\n    };\n    this.lastSeparation = 0;\n    this.touchDecided = false;\n    this.onContext = event => {\n      if (this.enablePan) {\n        event.preventDefault();\n      } else {\n        for (const pointer of this.pointers) {\n          // Required because of a common browser bug where the context menu never\n          // fires a pointercancel event.\n          this.onPointerUp(new PointerEvent('pointercancel', Object.assign(Object.assign({}, this.startPointerPosition), {\n            pointerId: pointer.id\n          })));\n        }\n      }\n    };\n    this.touchModeZoom = (dx, dy) => {\n      if (!this._disableZoom) {\n        const touchDistance = this.twoTouchDistance(this.pointers[0], this.pointers[1]);\n        const deltaZoom = ZOOM_SENSITIVITY * this.zoomSensitivity * (this.lastSeparation - touchDistance) * 50 / this.scene.height;\n        this.lastSeparation = touchDistance;\n        this.userAdjustOrbit(0, 0, deltaZoom);\n      }\n      if (this.panPerPixel > 0) {\n        this.movePan(dx, dy);\n      }\n    };\n    // We implement our own version of the browser's CSS touch-action, enforced by\n    // this function, because the iOS implementation of pan-y is bad and doesn't\n    // match Android. Specifically, even if a touch gesture begins by panning X,\n    // iOS will switch to scrolling as soon as the gesture moves in the Y, rather\n    // than staying in the same mode until the end of the gesture.\n    this.disableScroll = event => {\n      event.preventDefault();\n    };\n    this.touchModeRotate = (dx, dy) => {\n      const {\n        touchAction\n      } = this._options;\n      if (!this.touchDecided && touchAction !== 'none') {\n        this.touchDecided = true;\n        const dxMag = Math.abs(dx);\n        const dyMag = Math.abs(dy);\n        // If motion is mostly vertical, assume scrolling is the intent.\n        if (this.changeSource === ChangeSource.USER_INTERACTION && (touchAction === 'pan-y' && dyMag > dxMag || touchAction === 'pan-x' && dxMag > dyMag)) {\n          this.touchMode = null;\n          return;\n        } else {\n          this.element.addEventListener('touchmove', this.disableScroll, {\n            passive: false\n          });\n        }\n      }\n      this.handleSinglePointerMove(dx, dy);\n    };\n    this.onPointerDown = event => {\n      if (this.pointers.length > 2) {\n        return;\n      }\n      const {\n        element\n      } = this;\n      if (this.pointers.length === 0) {\n        element.addEventListener('pointermove', this.onPointerMove);\n        element.addEventListener('pointerup', this.onPointerUp);\n        this.touchMode = null;\n        this.touchDecided = false;\n        this.startPointerPosition.clientX = event.clientX;\n        this.startPointerPosition.clientY = event.clientY;\n        this.startTime = performance.now();\n      }\n      try {\n        element.setPointerCapture(event.pointerId);\n      } catch (_a) {}\n      this.pointers.push({\n        clientX: event.clientX,\n        clientY: event.clientY,\n        id: event.pointerId\n      });\n      this.isUserPointing = false;\n      if (event.pointerType === 'touch') {\n        this.changeSource = event.altKey ?\n        // set by interact() in controls.ts\n        ChangeSource.AUTOMATIC : ChangeSource.USER_INTERACTION;\n        this.onTouchChange(event);\n      } else {\n        this.changeSource = ChangeSource.USER_INTERACTION;\n        this.onMouseDown(event);\n      }\n      if (this.changeSource === ChangeSource.USER_INTERACTION) {\n        this.dispatchEvent({\n          type: 'user-interaction'\n        });\n      }\n    };\n    this.onPointerMove = event => {\n      const pointer = this.pointers.find(pointer => pointer.id === event.pointerId);\n      if (pointer == null) {\n        return;\n      }\n      // In case no one gave us a pointerup or pointercancel event.\n      if (event.pointerType === 'mouse' && event.buttons === 0) {\n        this.onPointerUp(event);\n        return;\n      }\n      const numTouches = this.pointers.length;\n      const dx = (event.clientX - pointer.clientX) / numTouches;\n      const dy = (event.clientY - pointer.clientY) / numTouches;\n      if (dx === 0 && dy === 0) {\n        return;\n      }\n      pointer.clientX = event.clientX;\n      pointer.clientY = event.clientY;\n      if (event.pointerType === 'touch') {\n        this.changeSource = event.altKey ?\n        // set by interact() in controls.ts\n        ChangeSource.AUTOMATIC : ChangeSource.USER_INTERACTION;\n        if (this.touchMode !== null) {\n          this.touchMode(dx, dy);\n        }\n      } else {\n        this.changeSource = ChangeSource.USER_INTERACTION;\n        if (this.panPerPixel > 0) {\n          this.movePan(dx, dy);\n        } else {\n          this.handleSinglePointerMove(dx, dy);\n        }\n      }\n    };\n    this.onPointerUp = event => {\n      const {\n        element\n      } = this;\n      const index = this.pointers.findIndex(pointer => pointer.id === event.pointerId);\n      if (index !== -1) {\n        this.pointers.splice(index, 1);\n      }\n      // altKey indicates an interaction prompt; don't reset radius in this case\n      // as it will cause the camera to drift.\n      if (this.panPerPixel > 0 && !event.altKey) {\n        this.resetRadius();\n      }\n      if (this.pointers.length === 0) {\n        element.removeEventListener('pointermove', this.onPointerMove);\n        element.removeEventListener('pointerup', this.onPointerUp);\n        element.removeEventListener('touchmove', this.disableScroll);\n        if (this.enablePan && this.enableTap) {\n          this.recenter(event);\n        }\n      } else if (this.touchMode !== null) {\n        this.onTouchChange(event);\n      }\n      this.scene.element[$panElement].style.opacity = 0;\n      element.style.cursor = 'grab';\n      this.panPerPixel = 0;\n      if (this.isUserPointing) {\n        this.dispatchEvent({\n          type: 'pointer-change-end'\n        });\n      }\n    };\n    this.onWheel = event => {\n      this.changeSource = ChangeSource.USER_INTERACTION;\n      const deltaZoom = event.deltaY * (event.deltaMode == 1 ? 18 : 1) * ZOOM_SENSITIVITY * this.zoomSensitivity / 30;\n      this.userAdjustOrbit(0, 0, deltaZoom);\n      event.preventDefault();\n      this.dispatchEvent({\n        type: 'user-interaction'\n      });\n    };\n    this.onKeyDown = event => {\n      // We track if the key is actually one we respond to, so as not to\n      // accidentally clobber unrelated key inputs when the <model-viewer> has\n      // focus.\n      const {\n        changeSource\n      } = this;\n      this.changeSource = ChangeSource.USER_INTERACTION;\n      const relevantKey = event.shiftKey && this.enablePan ? this.panKeyCodeHandler(event) : this.orbitZoomKeyCodeHandler(event);\n      if (relevantKey) {\n        event.preventDefault();\n        this.dispatchEvent({\n          type: 'user-interaction'\n        });\n      } else {\n        this.changeSource = changeSource;\n      }\n    };\n    this._options = Object.assign({}, DEFAULT_OPTIONS);\n    this.setOrbit(0, Math.PI / 2, 1);\n    this.setFieldOfView(100);\n    this.jumpToGoal();\n  }\n  get interactionEnabled() {\n    return this._interactionEnabled;\n  }\n  enableInteraction() {\n    if (this._interactionEnabled === false) {\n      const {\n        element\n      } = this;\n      element.addEventListener('pointerdown', this.onPointerDown);\n      element.addEventListener('pointercancel', this.onPointerUp);\n      if (!this._disableZoom) {\n        element.addEventListener('wheel', this.onWheel);\n      }\n      element.addEventListener('keydown', this.onKeyDown);\n      // This little beauty is to work around a WebKit bug that otherwise makes\n      // touch events randomly not cancelable.\n      element.addEventListener('touchmove', () => {}, {\n        passive: false\n      });\n      element.addEventListener('contextmenu', this.onContext);\n      this.element.style.cursor = 'grab';\n      this._interactionEnabled = true;\n      this.updateTouchActionStyle();\n    }\n  }\n  disableInteraction() {\n    if (this._interactionEnabled === true) {\n      const {\n        element\n      } = this;\n      element.removeEventListener('pointerdown', this.onPointerDown);\n      element.removeEventListener('pointermove', this.onPointerMove);\n      element.removeEventListener('pointerup', this.onPointerUp);\n      element.removeEventListener('pointercancel', this.onPointerUp);\n      element.removeEventListener('wheel', this.onWheel);\n      element.removeEventListener('keydown', this.onKeyDown);\n      element.removeEventListener('contextmenu', this.onContext);\n      element.style.cursor = '';\n      this.touchMode = null;\n      this._interactionEnabled = false;\n      this.updateTouchActionStyle();\n    }\n  }\n  /**\n   * The options that are currently configured for the controls instance.\n   */\n  get options() {\n    return this._options;\n  }\n  set disableZoom(disable) {\n    if (this._disableZoom != disable) {\n      this._disableZoom = disable;\n      if (disable === true) {\n        this.element.removeEventListener('wheel', this.onWheel);\n      } else {\n        this.element.addEventListener('wheel', this.onWheel);\n      }\n      this.updateTouchActionStyle();\n    }\n  }\n  /**\n   * Copy the spherical values that represent the current camera orbital\n   * position relative to the configured target into a provided Spherical\n   * instance. If no Spherical is provided, a new Spherical will be allocated\n   * to copy the values into. The Spherical that values are copied into is\n   * returned.\n   */\n  getCameraSpherical(target = new Spherical()) {\n    return target.copy(this.spherical);\n  }\n  /**\n   * Returns the camera's current vertical field of view in degrees.\n   */\n  getFieldOfView() {\n    return this.camera.fov;\n  }\n  /**\n   * Configure the _options of the controls. Configured _options will be\n   * merged with whatever _options have already been configured for this\n   * controls instance.\n   */\n  applyOptions(_options) {\n    Object.assign(this._options, _options);\n    // Re-evaluates clamping based on potentially new values for min/max\n    // polar, azimuth and radius:\n    this.setOrbit();\n    this.setFieldOfView(Math.exp(this.goalLogFov));\n  }\n  /**\n   * Sets the near and far planes of the camera.\n   */\n  updateNearFar(nearPlane, farPlane) {\n    this.camera.far = farPlane === 0 ? 2 : farPlane;\n    this.camera.near = Math.max(nearPlane, this.camera.far / 1000);\n    this.camera.updateProjectionMatrix();\n  }\n  /**\n   * Sets the aspect ratio of the camera\n   */\n  updateAspect(aspect) {\n    this.camera.aspect = aspect;\n    this.camera.updateProjectionMatrix();\n  }\n  /**\n   * Set the absolute orbital goal of the camera. The change will be\n   * applied over a number of frames depending on configured acceleration and\n   * dampening _options.\n   *\n   * Returns true if invoking the method will result in the camera changing\n   * position and/or rotation, otherwise false.\n   */\n  setOrbit(goalTheta = this.goalSpherical.theta, goalPhi = this.goalSpherical.phi, goalRadius = this.goalSpherical.radius) {\n    const {\n      minimumAzimuthalAngle,\n      maximumAzimuthalAngle,\n      minimumPolarAngle,\n      maximumPolarAngle,\n      minimumRadius,\n      maximumRadius\n    } = this._options;\n    const {\n      theta,\n      phi,\n      radius\n    } = this.goalSpherical;\n    const nextTheta = clamp(goalTheta, minimumAzimuthalAngle, maximumAzimuthalAngle);\n    if (!isFinite(minimumAzimuthalAngle) && !isFinite(maximumAzimuthalAngle)) {\n      this.spherical.theta = this.wrapAngle(this.spherical.theta - nextTheta) + nextTheta;\n    }\n    const nextPhi = clamp(goalPhi, minimumPolarAngle, maximumPolarAngle);\n    const nextRadius = clamp(goalRadius, minimumRadius, maximumRadius);\n    if (nextTheta === theta && nextPhi === phi && nextRadius === radius) {\n      return false;\n    }\n    if (!isFinite(nextTheta) || !isFinite(nextPhi) || !isFinite(nextRadius)) {\n      return false;\n    }\n    this.goalSpherical.theta = nextTheta;\n    this.goalSpherical.phi = nextPhi;\n    this.goalSpherical.radius = nextRadius;\n    this.goalSpherical.makeSafe();\n    return true;\n  }\n  /**\n   * Subset of setOrbit() above, which only sets the camera's radius.\n   */\n  setRadius(radius) {\n    this.goalSpherical.radius = radius;\n    this.setOrbit();\n  }\n  /**\n   * Sets the goal field of view for the camera\n   */\n  setFieldOfView(fov) {\n    const {\n      minimumFieldOfView,\n      maximumFieldOfView\n    } = this._options;\n    fov = clamp(fov, minimumFieldOfView, maximumFieldOfView);\n    this.goalLogFov = Math.log(fov);\n  }\n  /**\n   * Sets the smoothing decay time.\n   */\n  setDamperDecayTime(decayMilliseconds) {\n    this.thetaDamper.setDecayTime(decayMilliseconds);\n    this.phiDamper.setDecayTime(decayMilliseconds);\n    this.radiusDamper.setDecayTime(decayMilliseconds);\n    this.fovDamper.setDecayTime(decayMilliseconds);\n  }\n  /**\n   * Adjust the orbital position of the camera relative to its current orbital\n   * position. Does not let the theta goal get more than pi ahead of the current\n   * theta, which ensures interpolation continues in the direction of the delta.\n   * The deltaZoom parameter adjusts both the field of view and the orbit radius\n   * such that they progress across their allowed ranges in sync.\n   */\n  adjustOrbit(deltaTheta, deltaPhi, deltaZoom) {\n    const {\n      theta,\n      phi,\n      radius\n    } = this.goalSpherical;\n    const {\n      minimumRadius,\n      maximumRadius,\n      minimumFieldOfView,\n      maximumFieldOfView\n    } = this._options;\n    const dTheta = this.spherical.theta - theta;\n    const dThetaLimit = Math.PI - 0.001;\n    const goalTheta = theta - clamp(deltaTheta, -dThetaLimit - dTheta, dThetaLimit - dTheta);\n    const goalPhi = phi - deltaPhi;\n    const deltaRatio = deltaZoom === 0 ? 0 : ((deltaZoom > 0 ? maximumRadius : minimumRadius) - radius) / (Math.log(deltaZoom > 0 ? maximumFieldOfView : minimumFieldOfView) - this.goalLogFov);\n    const goalRadius = radius + deltaZoom * (isFinite(deltaRatio) ? deltaRatio : (maximumRadius - minimumRadius) * 2);\n    this.setOrbit(goalTheta, goalPhi, goalRadius);\n    if (deltaZoom !== 0) {\n      const goalLogFov = this.goalLogFov + deltaZoom;\n      this.setFieldOfView(Math.exp(goalLogFov));\n    }\n  }\n  /**\n   * Move the camera instantly instead of accelerating toward the goal\n   * parameters.\n   */\n  jumpToGoal() {\n    this.update(0, SETTLING_TIME);\n  }\n  /**\n   * Update controls. In most cases, this will result in the camera\n   * interpolating its position and rotation until it lines up with the\n   * designated goal orbital position. Returns false if the camera did not move.\n   *\n   * Time and delta are measured in milliseconds.\n   */\n  update(_time, delta) {\n    if (this.isStationary()) {\n      return false;\n    }\n    const {\n      maximumPolarAngle,\n      maximumRadius\n    } = this._options;\n    const dTheta = this.spherical.theta - this.goalSpherical.theta;\n    if (Math.abs(dTheta) > Math.PI && !isFinite(this._options.minimumAzimuthalAngle) && !isFinite(this._options.maximumAzimuthalAngle)) {\n      this.spherical.theta -= Math.sign(dTheta) * 2 * Math.PI;\n    }\n    this.spherical.theta = this.thetaDamper.update(this.spherical.theta, this.goalSpherical.theta, delta, Math.PI);\n    this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, delta, maximumPolarAngle);\n    this.spherical.radius = this.radiusDamper.update(this.spherical.radius, this.goalSpherical.radius, delta, maximumRadius);\n    this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, delta, 1);\n    this.moveCamera();\n    return true;\n  }\n  updateTouchActionStyle() {\n    const {\n      style\n    } = this.element;\n    if (this._interactionEnabled) {\n      const {\n        touchAction\n      } = this._options;\n      if (this._disableZoom && touchAction !== 'none') {\n        style.touchAction = 'manipulation';\n      } else {\n        style.touchAction = touchAction;\n      }\n    } else {\n      style.touchAction = '';\n    }\n  }\n  isStationary() {\n    return this.goalSpherical.theta === this.spherical.theta && this.goalSpherical.phi === this.spherical.phi && this.goalSpherical.radius === this.spherical.radius && this.goalLogFov === this.logFov;\n  }\n  moveCamera() {\n    // Derive the new camera position from the updated spherical:\n    this.spherical.makeSafe();\n    this.camera.position.setFromSpherical(this.spherical);\n    this.camera.setRotationFromEuler(new Euler(this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, 'YXZ'));\n    if (this.camera.fov !== Math.exp(this.logFov)) {\n      this.camera.fov = Math.exp(this.logFov);\n      this.camera.updateProjectionMatrix();\n    }\n  }\n  userAdjustOrbit(deltaTheta, deltaPhi, deltaZoom) {\n    this.adjustOrbit(deltaTheta * this.orbitSensitivity * this.inputSensitivity, deltaPhi * this.orbitSensitivity * this.inputSensitivity, deltaZoom * this.inputSensitivity);\n  }\n  // Wraps to between -pi and pi\n  wrapAngle(radians) {\n    const normalized = (radians + Math.PI) / (2 * Math.PI);\n    const wrapped = normalized - Math.floor(normalized);\n    return wrapped * 2 * Math.PI - Math.PI;\n  }\n  pixelLengthToSphericalAngle(pixelLength) {\n    return 2 * Math.PI * pixelLength / this.scene.height;\n  }\n  twoTouchDistance(touchOne, touchTwo) {\n    const {\n      clientX: xOne,\n      clientY: yOne\n    } = touchOne;\n    const {\n      clientX: xTwo,\n      clientY: yTwo\n    } = touchTwo;\n    const xDelta = xTwo - xOne;\n    const yDelta = yTwo - yOne;\n    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);\n  }\n  handleSinglePointerMove(dx, dy) {\n    const deltaTheta = this.pixelLengthToSphericalAngle(dx);\n    const deltaPhi = this.pixelLengthToSphericalAngle(dy);\n    if (this.isUserPointing === false) {\n      this.isUserPointing = true;\n      this.dispatchEvent({\n        type: 'pointer-change-start'\n      });\n    }\n    this.userAdjustOrbit(deltaTheta, deltaPhi, 0);\n  }\n  initializePan() {\n    const {\n      theta,\n      phi\n    } = this.spherical;\n    const psi = theta - this.scene.yaw;\n    this.panPerPixel = PAN_SENSITIVITY * this.panSensitivity / this.scene.height;\n    this.panProjection.set(-Math.cos(psi), -Math.cos(phi) * Math.sin(psi), 0, 0, Math.sin(phi), 0, Math.sin(psi), -Math.cos(phi) * Math.cos(psi), 0);\n  }\n  movePan(dx, dy) {\n    const {\n      scene\n    } = this;\n    const dxy = vector3.set(dx, dy, 0).multiplyScalar(this.inputSensitivity);\n    const metersPerPixel = this.spherical.radius * Math.exp(this.logFov) * this.panPerPixel;\n    dxy.multiplyScalar(metersPerPixel);\n    const target = scene.getTarget();\n    target.add(dxy.applyMatrix3(this.panProjection));\n    scene.boundingSphere.clampPoint(target, target);\n    scene.setTarget(target.x, target.y, target.z);\n  }\n  recenter(pointer) {\n    if (performance.now() > this.startTime + TAP_MS || Math.abs(pointer.clientX - this.startPointerPosition.clientX) > TAP_DISTANCE || Math.abs(pointer.clientY - this.startPointerPosition.clientY) > TAP_DISTANCE) {\n      return;\n    }\n    const {\n      scene\n    } = this;\n    const hit = scene.positionAndNormalFromPoint(scene.getNDC(pointer.clientX, pointer.clientY));\n    if (hit == null) {\n      const {\n        cameraTarget\n      } = scene.element;\n      scene.element.cameraTarget = '';\n      scene.element.cameraTarget = cameraTarget;\n      // Zoom all the way out.\n      this.userAdjustOrbit(0, 0, 1);\n    } else {\n      scene.target.worldToLocal(hit.position);\n      scene.setTarget(hit.position.x, hit.position.y, hit.position.z);\n    }\n  }\n  resetRadius() {\n    const {\n      scene\n    } = this;\n    const hit = scene.positionAndNormalFromPoint(vector2.set(0, 0));\n    if (hit == null) {\n      return;\n    }\n    scene.target.worldToLocal(hit.position);\n    const goalTarget = scene.getTarget();\n    const {\n      theta,\n      phi\n    } = this.spherical;\n    // Set target to surface hit point, except the target is still settling,\n    // so offset the goal accordingly so the transition is smooth even though\n    // this will drift the target slightly away from the hit point.\n    const psi = theta - scene.yaw;\n    const n = vector3.set(Math.sin(phi) * Math.sin(psi), Math.cos(phi), Math.sin(phi) * Math.cos(psi));\n    const dr = n.dot(hit.position.sub(goalTarget));\n    goalTarget.add(n.multiplyScalar(dr));\n    scene.setTarget(goalTarget.x, goalTarget.y, goalTarget.z);\n    // Change the camera radius to match the change in target so that the\n    // camera itself does not move, unless it hits a radius bound.\n    this.setOrbit(undefined, undefined, this.goalSpherical.radius - dr);\n  }\n  onTouchChange(event) {\n    if (this.pointers.length === 1) {\n      this.touchMode = this.touchModeRotate;\n    } else {\n      if (this._disableZoom) {\n        this.touchMode = null;\n        this.element.removeEventListener('touchmove', this.disableScroll);\n        return;\n      }\n      this.touchMode = this.touchDecided && this.touchMode === null ? null : this.touchModeZoom;\n      this.touchDecided = true;\n      this.element.addEventListener('touchmove', this.disableScroll, {\n        passive: false\n      });\n      this.lastSeparation = this.twoTouchDistance(this.pointers[0], this.pointers[1]);\n      if (this.enablePan && this.touchMode != null) {\n        this.initializePan();\n        if (!event.altKey) {\n          // user interaction, not prompt\n          this.scene.element[$panElement].style.opacity = 1;\n        }\n      }\n    }\n  }\n  onMouseDown(event) {\n    this.panPerPixel = 0;\n    if (this.enablePan && (event.button === 2 || event.ctrlKey || event.metaKey || event.shiftKey)) {\n      this.initializePan();\n      this.scene.element[$panElement].style.opacity = 1;\n    }\n    this.element.style.cursor = 'grabbing';\n  }\n  /**\n   * Handles the orbit and Zoom key presses\n   * Uses constants for the increment.\n   * @param event The keyboard event for the .key value\n   * @returns boolean to indicate if the key event has been handled\n   */\n  orbitZoomKeyCodeHandler(event) {\n    let relevantKey = true;\n    switch (event.key) {\n      case 'PageUp':\n        this.userAdjustOrbit(0, 0, ZOOM_SENSITIVITY * this.zoomSensitivity);\n        break;\n      case 'PageDown':\n        this.userAdjustOrbit(0, 0, -1 * ZOOM_SENSITIVITY * this.zoomSensitivity);\n        break;\n      case 'ArrowUp':\n        this.userAdjustOrbit(0, -KEYBOARD_ORBIT_INCREMENT, 0);\n        break;\n      case 'ArrowDown':\n        this.userAdjustOrbit(0, KEYBOARD_ORBIT_INCREMENT, 0);\n        break;\n      case 'ArrowLeft':\n        this.userAdjustOrbit(-KEYBOARD_ORBIT_INCREMENT, 0, 0);\n        break;\n      case 'ArrowRight':\n        this.userAdjustOrbit(KEYBOARD_ORBIT_INCREMENT, 0, 0);\n        break;\n      default:\n        relevantKey = false;\n        break;\n    }\n    return relevantKey;\n  }\n  /**\n   * Handles the Pan key presses\n   * Uses constants for the increment.\n   * @param event The keyboard event for the .key value\n   * @returns boolean to indicate if the key event has been handled\n   */\n  panKeyCodeHandler(event) {\n    this.initializePan();\n    let relevantKey = true;\n    switch (event.key) {\n      case 'ArrowUp':\n        this.movePan(0, -1 * PAN_KEY_INCREMENT); // This is the negative one so that the\n        // model appears to move as the arrow\n        // direction rather than the view moving\n        break;\n      case 'ArrowDown':\n        this.movePan(0, PAN_KEY_INCREMENT);\n        break;\n      case 'ArrowLeft':\n        this.movePan(-1 * PAN_KEY_INCREMENT, 0);\n        break;\n      case 'ArrowRight':\n        this.movePan(PAN_KEY_INCREMENT, 0);\n        break;\n      default:\n        relevantKey = false;\n        break;\n    }\n    return relevantKey;\n  }\n}","map":{"version":3,"names":["Euler","EventDispatcher","Matrix3","Spherical","Vector2","Vector3","$panElement","clamp","Damper","SETTLING_TIME","PAN_SENSITIVITY","TAP_DISTANCE","TAP_MS","vector2","vector3","DEFAULT_OPTIONS","Object","freeze","minimumRadius","maximumRadius","Infinity","minimumPolarAngle","Math","PI","maximumPolarAngle","minimumAzimuthalAngle","maximumAzimuthalAngle","minimumFieldOfView","maximumFieldOfView","touchAction","KEYBOARD_ORBIT_INCREMENT","ZOOM_SENSITIVITY","PAN_KEY_INCREMENT","KeyCode","PAGE_UP","PAGE_DOWN","LEFT","UP","RIGHT","DOWN","ChangeSource","USER_INTERACTION","NONE","AUTOMATIC","SmoothControls","constructor","camera","element","scene","orbitSensitivity","zoomSensitivity","panSensitivity","inputSensitivity","changeSource","_interactionEnabled","_disableZoom","isUserPointing","enablePan","enableTap","panProjection","panPerPixel","spherical","goalSpherical","thetaDamper","phiDamper","radiusDamper","logFov","log","goalLogFov","fovDamper","touchMode","pointers","startTime","startPointerPosition","clientX","clientY","lastSeparation","touchDecided","onContext","event","preventDefault","pointer","onPointerUp","PointerEvent","assign","pointerId","id","touchModeZoom","dx","dy","touchDistance","twoTouchDistance","deltaZoom","height","userAdjustOrbit","movePan","disableScroll","touchModeRotate","_options","dxMag","abs","dyMag","addEventListener","passive","handleSinglePointerMove","onPointerDown","length","onPointerMove","performance","now","setPointerCapture","_a","push","pointerType","altKey","onTouchChange","onMouseDown","dispatchEvent","type","find","buttons","numTouches","index","findIndex","splice","resetRadius","removeEventListener","recenter","style","opacity","cursor","onWheel","deltaY","deltaMode","onKeyDown","relevantKey","shiftKey","panKeyCodeHandler","orbitZoomKeyCodeHandler","setOrbit","setFieldOfView","jumpToGoal","interactionEnabled","enableInteraction","updateTouchActionStyle","disableInteraction","options","disableZoom","disable","getCameraSpherical","target","copy","getFieldOfView","fov","applyOptions","exp","updateNearFar","nearPlane","farPlane","far","near","max","updateProjectionMatrix","updateAspect","aspect","goalTheta","theta","goalPhi","phi","goalRadius","radius","nextTheta","isFinite","wrapAngle","nextPhi","nextRadius","makeSafe","setRadius","setDamperDecayTime","decayMilliseconds","setDecayTime","adjustOrbit","deltaTheta","deltaPhi","dTheta","dThetaLimit","deltaRatio","update","_time","delta","isStationary","sign","moveCamera","position","setFromSpherical","setRotationFromEuler","radians","normalized","wrapped","floor","pixelLengthToSphericalAngle","pixelLength","touchOne","touchTwo","xOne","yOne","xTwo","yTwo","xDelta","yDelta","sqrt","initializePan","psi","yaw","set","cos","sin","dxy","multiplyScalar","metersPerPixel","getTarget","add","applyMatrix3","boundingSphere","clampPoint","setTarget","x","y","z","hit","positionAndNormalFromPoint","getNDC","cameraTarget","worldToLocal","goalTarget","n","dr","dot","sub","undefined","button","ctrlKey","metaKey","key"],"sources":["/Users/leandrodisconzi/CascadeProjects/geodome-website/node_modules/@google/model-viewer/lib/three-components/SmoothControls.js"],"sourcesContent":["/* @license\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Euler, EventDispatcher, Matrix3, Spherical, Vector2, Vector3 } from 'three';\nimport { $panElement } from '../features/controls.js';\nimport { clamp } from '../utilities.js';\nimport { Damper, SETTLING_TIME } from './Damper.js';\nconst PAN_SENSITIVITY = 0.018;\nconst TAP_DISTANCE = 2;\nconst TAP_MS = 300;\nconst vector2 = new Vector2();\nconst vector3 = new Vector3();\nexport const DEFAULT_OPTIONS = Object.freeze({\n    minimumRadius: 0,\n    maximumRadius: Infinity,\n    minimumPolarAngle: Math.PI / 8,\n    maximumPolarAngle: Math.PI - Math.PI / 8,\n    minimumAzimuthalAngle: -Infinity,\n    maximumAzimuthalAngle: Infinity,\n    minimumFieldOfView: 10,\n    maximumFieldOfView: 45,\n    touchAction: 'none'\n});\n// Constants\nconst KEYBOARD_ORBIT_INCREMENT = Math.PI / 8;\nconst ZOOM_SENSITIVITY = 0.04;\n// The move size on pan key event\nconst PAN_KEY_INCREMENT = 10;\nexport const KeyCode = {\n    PAGE_UP: 33,\n    PAGE_DOWN: 34,\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40\n};\nexport const ChangeSource = {\n    USER_INTERACTION: 'user-interaction',\n    NONE: 'none',\n    AUTOMATIC: 'automatic'\n};\n/**\n * SmoothControls is a Three.js helper for adding delightful pointer and\n * keyboard-based input to a staged Three.js scene. Its API is very similar to\n * OrbitControls, but it offers more opinionated (subjectively more delightful)\n * defaults, easy extensibility and subjectively better out-of-the-box keyboard\n * support.\n *\n * One important change compared to OrbitControls is that the `update` method\n * of SmoothControls must be invoked on every frame, otherwise the controls\n * will not have an effect.\n *\n * Another notable difference compared to OrbitControls is that SmoothControls\n * does not currently support panning (but probably will in a future revision).\n *\n * Like OrbitControls, SmoothControls assumes that the orientation of the camera\n * has been set in terms of position, rotation and scale, so it is important to\n * ensure that the camera's matrixWorld is in sync before using SmoothControls.\n */\nexport class SmoothControls extends EventDispatcher {\n    constructor(camera, element, scene) {\n        super();\n        this.camera = camera;\n        this.element = element;\n        this.scene = scene;\n        this.orbitSensitivity = 1;\n        this.zoomSensitivity = 1;\n        this.panSensitivity = 1;\n        this.inputSensitivity = 1;\n        this.changeSource = ChangeSource.NONE;\n        this._interactionEnabled = false;\n        this._disableZoom = false;\n        this.isUserPointing = false;\n        // Pan state\n        this.enablePan = true;\n        this.enableTap = true;\n        this.panProjection = new Matrix3();\n        this.panPerPixel = 0;\n        // Internal orbital position state\n        this.spherical = new Spherical();\n        this.goalSpherical = new Spherical();\n        this.thetaDamper = new Damper();\n        this.phiDamper = new Damper();\n        this.radiusDamper = new Damper();\n        this.logFov = Math.log(DEFAULT_OPTIONS.maximumFieldOfView);\n        this.goalLogFov = this.logFov;\n        this.fovDamper = new Damper();\n        // Pointer state\n        this.touchMode = null;\n        this.pointers = [];\n        this.startTime = 0;\n        this.startPointerPosition = { clientX: 0, clientY: 0 };\n        this.lastSeparation = 0;\n        this.touchDecided = false;\n        this.onContext = (event) => {\n            if (this.enablePan) {\n                event.preventDefault();\n            }\n            else {\n                for (const pointer of this.pointers) {\n                    // Required because of a common browser bug where the context menu never\n                    // fires a pointercancel event.\n                    this.onPointerUp(new PointerEvent('pointercancel', Object.assign(Object.assign({}, this.startPointerPosition), { pointerId: pointer.id })));\n                }\n            }\n        };\n        this.touchModeZoom = (dx, dy) => {\n            if (!this._disableZoom) {\n                const touchDistance = this.twoTouchDistance(this.pointers[0], this.pointers[1]);\n                const deltaZoom = ZOOM_SENSITIVITY * this.zoomSensitivity *\n                    (this.lastSeparation - touchDistance) * 50 / this.scene.height;\n                this.lastSeparation = touchDistance;\n                this.userAdjustOrbit(0, 0, deltaZoom);\n            }\n            if (this.panPerPixel > 0) {\n                this.movePan(dx, dy);\n            }\n        };\n        // We implement our own version of the browser's CSS touch-action, enforced by\n        // this function, because the iOS implementation of pan-y is bad and doesn't\n        // match Android. Specifically, even if a touch gesture begins by panning X,\n        // iOS will switch to scrolling as soon as the gesture moves in the Y, rather\n        // than staying in the same mode until the end of the gesture.\n        this.disableScroll = (event) => {\n            event.preventDefault();\n        };\n        this.touchModeRotate = (dx, dy) => {\n            const { touchAction } = this._options;\n            if (!this.touchDecided && touchAction !== 'none') {\n                this.touchDecided = true;\n                const dxMag = Math.abs(dx);\n                const dyMag = Math.abs(dy);\n                // If motion is mostly vertical, assume scrolling is the intent.\n                if (this.changeSource === ChangeSource.USER_INTERACTION &&\n                    ((touchAction === 'pan-y' && dyMag > dxMag) ||\n                        (touchAction === 'pan-x' && dxMag > dyMag))) {\n                    this.touchMode = null;\n                    return;\n                }\n                else {\n                    this.element.addEventListener('touchmove', this.disableScroll, { passive: false });\n                }\n            }\n            this.handleSinglePointerMove(dx, dy);\n        };\n        this.onPointerDown = (event) => {\n            if (this.pointers.length > 2) {\n                return;\n            }\n            const { element } = this;\n            if (this.pointers.length === 0) {\n                element.addEventListener('pointermove', this.onPointerMove);\n                element.addEventListener('pointerup', this.onPointerUp);\n                this.touchMode = null;\n                this.touchDecided = false;\n                this.startPointerPosition.clientX = event.clientX;\n                this.startPointerPosition.clientY = event.clientY;\n                this.startTime = performance.now();\n            }\n            try {\n                element.setPointerCapture(event.pointerId);\n            }\n            catch (_a) {\n            }\n            this.pointers.push({ clientX: event.clientX, clientY: event.clientY, id: event.pointerId });\n            this.isUserPointing = false;\n            if (event.pointerType === 'touch') {\n                this.changeSource = event.altKey ? // set by interact() in controls.ts\n                    ChangeSource.AUTOMATIC :\n                    ChangeSource.USER_INTERACTION;\n                this.onTouchChange(event);\n            }\n            else {\n                this.changeSource = ChangeSource.USER_INTERACTION;\n                this.onMouseDown(event);\n            }\n            if (this.changeSource === ChangeSource.USER_INTERACTION) {\n                this.dispatchEvent({ type: 'user-interaction' });\n            }\n        };\n        this.onPointerMove = (event) => {\n            const pointer = this.pointers.find((pointer) => pointer.id === event.pointerId);\n            if (pointer == null) {\n                return;\n            }\n            // In case no one gave us a pointerup or pointercancel event.\n            if (event.pointerType === 'mouse' && event.buttons === 0) {\n                this.onPointerUp(event);\n                return;\n            }\n            const numTouches = this.pointers.length;\n            const dx = (event.clientX - pointer.clientX) / numTouches;\n            const dy = (event.clientY - pointer.clientY) / numTouches;\n            if (dx === 0 && dy === 0) {\n                return;\n            }\n            pointer.clientX = event.clientX;\n            pointer.clientY = event.clientY;\n            if (event.pointerType === 'touch') {\n                this.changeSource = event.altKey ? // set by interact() in controls.ts\n                    ChangeSource.AUTOMATIC :\n                    ChangeSource.USER_INTERACTION;\n                if (this.touchMode !== null) {\n                    this.touchMode(dx, dy);\n                }\n            }\n            else {\n                this.changeSource = ChangeSource.USER_INTERACTION;\n                if (this.panPerPixel > 0) {\n                    this.movePan(dx, dy);\n                }\n                else {\n                    this.handleSinglePointerMove(dx, dy);\n                }\n            }\n        };\n        this.onPointerUp = (event) => {\n            const { element } = this;\n            const index = this.pointers.findIndex((pointer) => pointer.id === event.pointerId);\n            if (index !== -1) {\n                this.pointers.splice(index, 1);\n            }\n            // altKey indicates an interaction prompt; don't reset radius in this case\n            // as it will cause the camera to drift.\n            if (this.panPerPixel > 0 && !event.altKey) {\n                this.resetRadius();\n            }\n            if (this.pointers.length === 0) {\n                element.removeEventListener('pointermove', this.onPointerMove);\n                element.removeEventListener('pointerup', this.onPointerUp);\n                element.removeEventListener('touchmove', this.disableScroll);\n                if (this.enablePan && this.enableTap) {\n                    this.recenter(event);\n                }\n            }\n            else if (this.touchMode !== null) {\n                this.onTouchChange(event);\n            }\n            this.scene.element[$panElement].style.opacity = 0;\n            element.style.cursor = 'grab';\n            this.panPerPixel = 0;\n            if (this.isUserPointing) {\n                this.dispatchEvent({ type: 'pointer-change-end' });\n            }\n        };\n        this.onWheel = (event) => {\n            this.changeSource = ChangeSource.USER_INTERACTION;\n            const deltaZoom = event.deltaY *\n                (event.deltaMode == 1 ? 18 : 1) * ZOOM_SENSITIVITY *\n                this.zoomSensitivity / 30;\n            this.userAdjustOrbit(0, 0, deltaZoom);\n            event.preventDefault();\n            this.dispatchEvent({ type: 'user-interaction' });\n        };\n        this.onKeyDown = (event) => {\n            // We track if the key is actually one we respond to, so as not to\n            // accidentally clobber unrelated key inputs when the <model-viewer> has\n            // focus.\n            const { changeSource } = this;\n            this.changeSource = ChangeSource.USER_INTERACTION;\n            const relevantKey = (event.shiftKey && this.enablePan) ?\n                this.panKeyCodeHandler(event) :\n                this.orbitZoomKeyCodeHandler(event);\n            if (relevantKey) {\n                event.preventDefault();\n                this.dispatchEvent({ type: 'user-interaction' });\n            }\n            else {\n                this.changeSource = changeSource;\n            }\n        };\n        this._options = Object.assign({}, DEFAULT_OPTIONS);\n        this.setOrbit(0, Math.PI / 2, 1);\n        this.setFieldOfView(100);\n        this.jumpToGoal();\n    }\n    get interactionEnabled() {\n        return this._interactionEnabled;\n    }\n    enableInteraction() {\n        if (this._interactionEnabled === false) {\n            const { element } = this;\n            element.addEventListener('pointerdown', this.onPointerDown);\n            element.addEventListener('pointercancel', this.onPointerUp);\n            if (!this._disableZoom) {\n                element.addEventListener('wheel', this.onWheel);\n            }\n            element.addEventListener('keydown', this.onKeyDown);\n            // This little beauty is to work around a WebKit bug that otherwise makes\n            // touch events randomly not cancelable.\n            element.addEventListener('touchmove', () => { }, { passive: false });\n            element.addEventListener('contextmenu', this.onContext);\n            this.element.style.cursor = 'grab';\n            this._interactionEnabled = true;\n            this.updateTouchActionStyle();\n        }\n    }\n    disableInteraction() {\n        if (this._interactionEnabled === true) {\n            const { element } = this;\n            element.removeEventListener('pointerdown', this.onPointerDown);\n            element.removeEventListener('pointermove', this.onPointerMove);\n            element.removeEventListener('pointerup', this.onPointerUp);\n            element.removeEventListener('pointercancel', this.onPointerUp);\n            element.removeEventListener('wheel', this.onWheel);\n            element.removeEventListener('keydown', this.onKeyDown);\n            element.removeEventListener('contextmenu', this.onContext);\n            element.style.cursor = '';\n            this.touchMode = null;\n            this._interactionEnabled = false;\n            this.updateTouchActionStyle();\n        }\n    }\n    /**\n     * The options that are currently configured for the controls instance.\n     */\n    get options() {\n        return this._options;\n    }\n    set disableZoom(disable) {\n        if (this._disableZoom != disable) {\n            this._disableZoom = disable;\n            if (disable === true) {\n                this.element.removeEventListener('wheel', this.onWheel);\n            }\n            else {\n                this.element.addEventListener('wheel', this.onWheel);\n            }\n            this.updateTouchActionStyle();\n        }\n    }\n    /**\n     * Copy the spherical values that represent the current camera orbital\n     * position relative to the configured target into a provided Spherical\n     * instance. If no Spherical is provided, a new Spherical will be allocated\n     * to copy the values into. The Spherical that values are copied into is\n     * returned.\n     */\n    getCameraSpherical(target = new Spherical()) {\n        return target.copy(this.spherical);\n    }\n    /**\n     * Returns the camera's current vertical field of view in degrees.\n     */\n    getFieldOfView() {\n        return this.camera.fov;\n    }\n    /**\n     * Configure the _options of the controls. Configured _options will be\n     * merged with whatever _options have already been configured for this\n     * controls instance.\n     */\n    applyOptions(_options) {\n        Object.assign(this._options, _options);\n        // Re-evaluates clamping based on potentially new values for min/max\n        // polar, azimuth and radius:\n        this.setOrbit();\n        this.setFieldOfView(Math.exp(this.goalLogFov));\n    }\n    /**\n     * Sets the near and far planes of the camera.\n     */\n    updateNearFar(nearPlane, farPlane) {\n        this.camera.far = farPlane === 0 ? 2 : farPlane;\n        this.camera.near = Math.max(nearPlane, this.camera.far / 1000);\n        this.camera.updateProjectionMatrix();\n    }\n    /**\n     * Sets the aspect ratio of the camera\n     */\n    updateAspect(aspect) {\n        this.camera.aspect = aspect;\n        this.camera.updateProjectionMatrix();\n    }\n    /**\n     * Set the absolute orbital goal of the camera. The change will be\n     * applied over a number of frames depending on configured acceleration and\n     * dampening _options.\n     *\n     * Returns true if invoking the method will result in the camera changing\n     * position and/or rotation, otherwise false.\n     */\n    setOrbit(goalTheta = this.goalSpherical.theta, goalPhi = this.goalSpherical.phi, goalRadius = this.goalSpherical.radius) {\n        const { minimumAzimuthalAngle, maximumAzimuthalAngle, minimumPolarAngle, maximumPolarAngle, minimumRadius, maximumRadius } = this._options;\n        const { theta, phi, radius } = this.goalSpherical;\n        const nextTheta = clamp(goalTheta, minimumAzimuthalAngle, maximumAzimuthalAngle);\n        if (!isFinite(minimumAzimuthalAngle) &&\n            !isFinite(maximumAzimuthalAngle)) {\n            this.spherical.theta =\n                this.wrapAngle(this.spherical.theta - nextTheta) + nextTheta;\n        }\n        const nextPhi = clamp(goalPhi, minimumPolarAngle, maximumPolarAngle);\n        const nextRadius = clamp(goalRadius, minimumRadius, maximumRadius);\n        if (nextTheta === theta && nextPhi === phi && nextRadius === radius) {\n            return false;\n        }\n        if (!isFinite(nextTheta) || !isFinite(nextPhi) || !isFinite(nextRadius)) {\n            return false;\n        }\n        this.goalSpherical.theta = nextTheta;\n        this.goalSpherical.phi = nextPhi;\n        this.goalSpherical.radius = nextRadius;\n        this.goalSpherical.makeSafe();\n        return true;\n    }\n    /**\n     * Subset of setOrbit() above, which only sets the camera's radius.\n     */\n    setRadius(radius) {\n        this.goalSpherical.radius = radius;\n        this.setOrbit();\n    }\n    /**\n     * Sets the goal field of view for the camera\n     */\n    setFieldOfView(fov) {\n        const { minimumFieldOfView, maximumFieldOfView } = this._options;\n        fov = clamp(fov, minimumFieldOfView, maximumFieldOfView);\n        this.goalLogFov = Math.log(fov);\n    }\n    /**\n     * Sets the smoothing decay time.\n     */\n    setDamperDecayTime(decayMilliseconds) {\n        this.thetaDamper.setDecayTime(decayMilliseconds);\n        this.phiDamper.setDecayTime(decayMilliseconds);\n        this.radiusDamper.setDecayTime(decayMilliseconds);\n        this.fovDamper.setDecayTime(decayMilliseconds);\n    }\n    /**\n     * Adjust the orbital position of the camera relative to its current orbital\n     * position. Does not let the theta goal get more than pi ahead of the current\n     * theta, which ensures interpolation continues in the direction of the delta.\n     * The deltaZoom parameter adjusts both the field of view and the orbit radius\n     * such that they progress across their allowed ranges in sync.\n     */\n    adjustOrbit(deltaTheta, deltaPhi, deltaZoom) {\n        const { theta, phi, radius } = this.goalSpherical;\n        const { minimumRadius, maximumRadius, minimumFieldOfView, maximumFieldOfView } = this._options;\n        const dTheta = this.spherical.theta - theta;\n        const dThetaLimit = Math.PI - 0.001;\n        const goalTheta = theta - clamp(deltaTheta, -dThetaLimit - dTheta, dThetaLimit - dTheta);\n        const goalPhi = phi - deltaPhi;\n        const deltaRatio = deltaZoom === 0 ?\n            0 :\n            ((deltaZoom > 0 ? maximumRadius : minimumRadius) - radius) /\n                (Math.log(deltaZoom > 0 ? maximumFieldOfView : minimumFieldOfView) -\n                    this.goalLogFov);\n        const goalRadius = radius +\n            deltaZoom *\n                (isFinite(deltaRatio) ? deltaRatio :\n                    (maximumRadius - minimumRadius) * 2);\n        this.setOrbit(goalTheta, goalPhi, goalRadius);\n        if (deltaZoom !== 0) {\n            const goalLogFov = this.goalLogFov + deltaZoom;\n            this.setFieldOfView(Math.exp(goalLogFov));\n        }\n    }\n    /**\n     * Move the camera instantly instead of accelerating toward the goal\n     * parameters.\n     */\n    jumpToGoal() {\n        this.update(0, SETTLING_TIME);\n    }\n    /**\n     * Update controls. In most cases, this will result in the camera\n     * interpolating its position and rotation until it lines up with the\n     * designated goal orbital position. Returns false if the camera did not move.\n     *\n     * Time and delta are measured in milliseconds.\n     */\n    update(_time, delta) {\n        if (this.isStationary()) {\n            return false;\n        }\n        const { maximumPolarAngle, maximumRadius } = this._options;\n        const dTheta = this.spherical.theta - this.goalSpherical.theta;\n        if (Math.abs(dTheta) > Math.PI &&\n            !isFinite(this._options.minimumAzimuthalAngle) &&\n            !isFinite(this._options.maximumAzimuthalAngle)) {\n            this.spherical.theta -= Math.sign(dTheta) * 2 * Math.PI;\n        }\n        this.spherical.theta = this.thetaDamper.update(this.spherical.theta, this.goalSpherical.theta, delta, Math.PI);\n        this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, delta, maximumPolarAngle);\n        this.spherical.radius = this.radiusDamper.update(this.spherical.radius, this.goalSpherical.radius, delta, maximumRadius);\n        this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, delta, 1);\n        this.moveCamera();\n        return true;\n    }\n    updateTouchActionStyle() {\n        const { style } = this.element;\n        if (this._interactionEnabled) {\n            const { touchAction } = this._options;\n            if (this._disableZoom && touchAction !== 'none') {\n                style.touchAction = 'manipulation';\n            }\n            else {\n                style.touchAction = touchAction;\n            }\n        }\n        else {\n            style.touchAction = '';\n        }\n    }\n    isStationary() {\n        return this.goalSpherical.theta === this.spherical.theta &&\n            this.goalSpherical.phi === this.spherical.phi &&\n            this.goalSpherical.radius === this.spherical.radius &&\n            this.goalLogFov === this.logFov;\n    }\n    moveCamera() {\n        // Derive the new camera position from the updated spherical:\n        this.spherical.makeSafe();\n        this.camera.position.setFromSpherical(this.spherical);\n        this.camera.setRotationFromEuler(new Euler(this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, 'YXZ'));\n        if (this.camera.fov !== Math.exp(this.logFov)) {\n            this.camera.fov = Math.exp(this.logFov);\n            this.camera.updateProjectionMatrix();\n        }\n    }\n    userAdjustOrbit(deltaTheta, deltaPhi, deltaZoom) {\n        this.adjustOrbit(deltaTheta * this.orbitSensitivity * this.inputSensitivity, deltaPhi * this.orbitSensitivity * this.inputSensitivity, deltaZoom * this.inputSensitivity);\n    }\n    // Wraps to between -pi and pi\n    wrapAngle(radians) {\n        const normalized = (radians + Math.PI) / (2 * Math.PI);\n        const wrapped = normalized - Math.floor(normalized);\n        return wrapped * 2 * Math.PI - Math.PI;\n    }\n    pixelLengthToSphericalAngle(pixelLength) {\n        return 2 * Math.PI * pixelLength / this.scene.height;\n    }\n    twoTouchDistance(touchOne, touchTwo) {\n        const { clientX: xOne, clientY: yOne } = touchOne;\n        const { clientX: xTwo, clientY: yTwo } = touchTwo;\n        const xDelta = xTwo - xOne;\n        const yDelta = yTwo - yOne;\n        return Math.sqrt(xDelta * xDelta + yDelta * yDelta);\n    }\n    handleSinglePointerMove(dx, dy) {\n        const deltaTheta = this.pixelLengthToSphericalAngle(dx);\n        const deltaPhi = this.pixelLengthToSphericalAngle(dy);\n        if (this.isUserPointing === false) {\n            this.isUserPointing = true;\n            this.dispatchEvent({ type: 'pointer-change-start' });\n        }\n        this.userAdjustOrbit(deltaTheta, deltaPhi, 0);\n    }\n    initializePan() {\n        const { theta, phi } = this.spherical;\n        const psi = theta - this.scene.yaw;\n        this.panPerPixel =\n            PAN_SENSITIVITY * this.panSensitivity / this.scene.height;\n        this.panProjection.set(-Math.cos(psi), -Math.cos(phi) * Math.sin(psi), 0, 0, Math.sin(phi), 0, Math.sin(psi), -Math.cos(phi) * Math.cos(psi), 0);\n    }\n    movePan(dx, dy) {\n        const { scene } = this;\n        const dxy = vector3.set(dx, dy, 0).multiplyScalar(this.inputSensitivity);\n        const metersPerPixel = this.spherical.radius * Math.exp(this.logFov) * this.panPerPixel;\n        dxy.multiplyScalar(metersPerPixel);\n        const target = scene.getTarget();\n        target.add(dxy.applyMatrix3(this.panProjection));\n        scene.boundingSphere.clampPoint(target, target);\n        scene.setTarget(target.x, target.y, target.z);\n    }\n    recenter(pointer) {\n        if (performance.now() > this.startTime + TAP_MS ||\n            Math.abs(pointer.clientX - this.startPointerPosition.clientX) >\n                TAP_DISTANCE ||\n            Math.abs(pointer.clientY - this.startPointerPosition.clientY) >\n                TAP_DISTANCE) {\n            return;\n        }\n        const { scene } = this;\n        const hit = scene.positionAndNormalFromPoint(scene.getNDC(pointer.clientX, pointer.clientY));\n        if (hit == null) {\n            const { cameraTarget } = scene.element;\n            scene.element.cameraTarget = '';\n            scene.element.cameraTarget = cameraTarget;\n            // Zoom all the way out.\n            this.userAdjustOrbit(0, 0, 1);\n        }\n        else {\n            scene.target.worldToLocal(hit.position);\n            scene.setTarget(hit.position.x, hit.position.y, hit.position.z);\n        }\n    }\n    resetRadius() {\n        const { scene } = this;\n        const hit = scene.positionAndNormalFromPoint(vector2.set(0, 0));\n        if (hit == null) {\n            return;\n        }\n        scene.target.worldToLocal(hit.position);\n        const goalTarget = scene.getTarget();\n        const { theta, phi } = this.spherical;\n        // Set target to surface hit point, except the target is still settling,\n        // so offset the goal accordingly so the transition is smooth even though\n        // this will drift the target slightly away from the hit point.\n        const psi = theta - scene.yaw;\n        const n = vector3.set(Math.sin(phi) * Math.sin(psi), Math.cos(phi), Math.sin(phi) * Math.cos(psi));\n        const dr = n.dot(hit.position.sub(goalTarget));\n        goalTarget.add(n.multiplyScalar(dr));\n        scene.setTarget(goalTarget.x, goalTarget.y, goalTarget.z);\n        // Change the camera radius to match the change in target so that the\n        // camera itself does not move, unless it hits a radius bound.\n        this.setOrbit(undefined, undefined, this.goalSpherical.radius - dr);\n    }\n    onTouchChange(event) {\n        if (this.pointers.length === 1) {\n            this.touchMode = this.touchModeRotate;\n        }\n        else {\n            if (this._disableZoom) {\n                this.touchMode = null;\n                this.element.removeEventListener('touchmove', this.disableScroll);\n                return;\n            }\n            this.touchMode = (this.touchDecided && this.touchMode === null) ?\n                null :\n                this.touchModeZoom;\n            this.touchDecided = true;\n            this.element.addEventListener('touchmove', this.disableScroll, { passive: false });\n            this.lastSeparation =\n                this.twoTouchDistance(this.pointers[0], this.pointers[1]);\n            if (this.enablePan && this.touchMode != null) {\n                this.initializePan();\n                if (!event.altKey) { // user interaction, not prompt\n                    this.scene.element[$panElement].style.opacity = 1;\n                }\n            }\n        }\n    }\n    onMouseDown(event) {\n        this.panPerPixel = 0;\n        if (this.enablePan &&\n            (event.button === 2 || event.ctrlKey || event.metaKey ||\n                event.shiftKey)) {\n            this.initializePan();\n            this.scene.element[$panElement].style.opacity = 1;\n        }\n        this.element.style.cursor = 'grabbing';\n    }\n    /**\n     * Handles the orbit and Zoom key presses\n     * Uses constants for the increment.\n     * @param event The keyboard event for the .key value\n     * @returns boolean to indicate if the key event has been handled\n     */\n    orbitZoomKeyCodeHandler(event) {\n        let relevantKey = true;\n        switch (event.key) {\n            case 'PageUp':\n                this.userAdjustOrbit(0, 0, ZOOM_SENSITIVITY * this.zoomSensitivity);\n                break;\n            case 'PageDown':\n                this.userAdjustOrbit(0, 0, -1 * ZOOM_SENSITIVITY * this.zoomSensitivity);\n                break;\n            case 'ArrowUp':\n                this.userAdjustOrbit(0, -KEYBOARD_ORBIT_INCREMENT, 0);\n                break;\n            case 'ArrowDown':\n                this.userAdjustOrbit(0, KEYBOARD_ORBIT_INCREMENT, 0);\n                break;\n            case 'ArrowLeft':\n                this.userAdjustOrbit(-KEYBOARD_ORBIT_INCREMENT, 0, 0);\n                break;\n            case 'ArrowRight':\n                this.userAdjustOrbit(KEYBOARD_ORBIT_INCREMENT, 0, 0);\n                break;\n            default:\n                relevantKey = false;\n                break;\n        }\n        return relevantKey;\n    }\n    /**\n     * Handles the Pan key presses\n     * Uses constants for the increment.\n     * @param event The keyboard event for the .key value\n     * @returns boolean to indicate if the key event has been handled\n     */\n    panKeyCodeHandler(event) {\n        this.initializePan();\n        let relevantKey = true;\n        switch (event.key) {\n            case 'ArrowUp':\n                this.movePan(0, -1 * PAN_KEY_INCREMENT); // This is the negative one so that the\n                // model appears to move as the arrow\n                // direction rather than the view moving\n                break;\n            case 'ArrowDown':\n                this.movePan(0, PAN_KEY_INCREMENT);\n                break;\n            case 'ArrowLeft':\n                this.movePan(-1 * PAN_KEY_INCREMENT, 0);\n                break;\n            case 'ArrowRight':\n                this.movePan(PAN_KEY_INCREMENT, 0);\n                break;\n            default:\n                relevantKey = false;\n                break;\n        }\n        return relevantKey;\n    }\n}\n//# sourceMappingURL=SmoothControls.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}