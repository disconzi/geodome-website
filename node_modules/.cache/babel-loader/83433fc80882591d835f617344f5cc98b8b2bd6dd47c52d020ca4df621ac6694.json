{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { clamp } from '../utilities.js';\n/**\n * ProgressTracker is an event emitter that helps to track the ongoing progress\n * of many simultaneous actions.\n *\n * ProgressTracker reports progress activity in the form of a progress event.\n * The event.detail.totalProgress value indicates the elapsed progress of all\n * activities being tracked by the ProgressTracker.\n *\n * The value of totalProgress is a number that progresses from 0 to 1. The\n * ProgressTracker allows for the lazy accumulation of tracked actions, so the\n * total progress represents an abstract, non-absolute progress towards the\n * completion of all currently tracked events.\n *\n * When all currently tracked activities are finished, the ProgressTracker\n * emits one final progress event and then resets the list of its currently\n * tracked activities. This means that from an observer's perspective,\n * ongoing activities will accumulate and collectively contribute to the notion\n * of total progress until all currently tracked ongoing activities have\n * completed.\n */\nexport class ProgressTracker extends EventTarget {\n  constructor() {\n    super(...arguments);\n    this.ongoingActivities = new Set();\n    this.totalProgress = 0;\n  }\n  /**\n   * The total number of activities currently being tracked.\n   */\n  get ongoingActivityCount() {\n    return this.ongoingActivities.size;\n  }\n  /**\n   * Registers a new activity to be tracked by the progress tracker. The method\n   * returns a special callback that should be invoked whenever new progress is\n   * ready to be reported. The progress should be reported as a value between 0\n   * and 1, where 0 would represent the beginning of the action and 1 would\n   * represent its completion.\n   *\n   * There is no built-in notion of a time-out for ongoing activities, so once\n   * an ongoing activity is begun, it is up to the consumer of this API to\n   * update the progress until that activity is no longer ongoing.\n   *\n   * Progress is only allowed to move forward for any given activity. If a lower\n   * progress is reported than the previously reported progress, it will be\n   * ignored.\n   */\n  beginActivity(reason) {\n    const activity = {\n      progress: 0,\n      completed: false\n    };\n    this.ongoingActivities.add(activity);\n    if (this.ongoingActivityCount === 1) {\n      // Announce the first progress event (which should always be 0 / 1\n      // total progress):\n      this.announceTotalProgress(activity, 0, reason);\n    }\n    return progress => {\n      let nextProgress;\n      nextProgress = Math.max(clamp(progress, 0, 1), activity.progress);\n      if (nextProgress !== activity.progress) {\n        this.announceTotalProgress(activity, nextProgress, reason);\n      }\n      return activity.progress;\n    };\n  }\n  announceTotalProgress(updatedActivity, nextProgress, reason) {\n    let progressLeft = 0;\n    let completedActivities = 0;\n    if (nextProgress == 1.0) updatedActivity.completed = true;\n    for (const activity of this.ongoingActivities) {\n      const {\n        progress\n      } = activity;\n      progressLeft += 1.0 - progress;\n      if (activity.completed) {\n        completedActivities++;\n      }\n    }\n    const lastProgress = updatedActivity.progress;\n    updatedActivity.progress = nextProgress;\n    // Advance the total progress by the fraction of total remaining progress\n    // due to this activity.\n    this.totalProgress += (nextProgress - lastProgress) * (1.0 - this.totalProgress) / progressLeft;\n    const totalProgress = completedActivities === this.ongoingActivityCount ? 1.0 : this.totalProgress;\n    this.dispatchEvent(new CustomEvent('progress', {\n      detail: {\n        totalProgress,\n        reason\n      }\n    }));\n    if (completedActivities === this.ongoingActivityCount) {\n      this.totalProgress = 0.0;\n      this.ongoingActivities.clear();\n    }\n  }\n}","map":{"version":3,"names":["clamp","ProgressTracker","EventTarget","constructor","arguments","ongoingActivities","Set","totalProgress","ongoingActivityCount","size","beginActivity","reason","activity","progress","completed","add","announceTotalProgress","nextProgress","Math","max","updatedActivity","progressLeft","completedActivities","lastProgress","dispatchEvent","CustomEvent","detail","clear"],"sources":["/Users/leandrodisconzi/CascadeProjects/geodome-website/node_modules/@google/model-viewer/lib/utilities/progress-tracker.js"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { clamp } from '../utilities.js';\n/**\n * ProgressTracker is an event emitter that helps to track the ongoing progress\n * of many simultaneous actions.\n *\n * ProgressTracker reports progress activity in the form of a progress event.\n * The event.detail.totalProgress value indicates the elapsed progress of all\n * activities being tracked by the ProgressTracker.\n *\n * The value of totalProgress is a number that progresses from 0 to 1. The\n * ProgressTracker allows for the lazy accumulation of tracked actions, so the\n * total progress represents an abstract, non-absolute progress towards the\n * completion of all currently tracked events.\n *\n * When all currently tracked activities are finished, the ProgressTracker\n * emits one final progress event and then resets the list of its currently\n * tracked activities. This means that from an observer's perspective,\n * ongoing activities will accumulate and collectively contribute to the notion\n * of total progress until all currently tracked ongoing activities have\n * completed.\n */\nexport class ProgressTracker extends EventTarget {\n    constructor() {\n        super(...arguments);\n        this.ongoingActivities = new Set();\n        this.totalProgress = 0;\n    }\n    /**\n     * The total number of activities currently being tracked.\n     */\n    get ongoingActivityCount() {\n        return this.ongoingActivities.size;\n    }\n    /**\n     * Registers a new activity to be tracked by the progress tracker. The method\n     * returns a special callback that should be invoked whenever new progress is\n     * ready to be reported. The progress should be reported as a value between 0\n     * and 1, where 0 would represent the beginning of the action and 1 would\n     * represent its completion.\n     *\n     * There is no built-in notion of a time-out for ongoing activities, so once\n     * an ongoing activity is begun, it is up to the consumer of this API to\n     * update the progress until that activity is no longer ongoing.\n     *\n     * Progress is only allowed to move forward for any given activity. If a lower\n     * progress is reported than the previously reported progress, it will be\n     * ignored.\n     */\n    beginActivity(reason) {\n        const activity = { progress: 0, completed: false };\n        this.ongoingActivities.add(activity);\n        if (this.ongoingActivityCount === 1) {\n            // Announce the first progress event (which should always be 0 / 1\n            // total progress):\n            this.announceTotalProgress(activity, 0, reason);\n        }\n        return (progress) => {\n            let nextProgress;\n            nextProgress = Math.max(clamp(progress, 0, 1), activity.progress);\n            if (nextProgress !== activity.progress) {\n                this.announceTotalProgress(activity, nextProgress, reason);\n            }\n            return activity.progress;\n        };\n    }\n    announceTotalProgress(updatedActivity, nextProgress, reason) {\n        let progressLeft = 0;\n        let completedActivities = 0;\n        if (nextProgress == 1.0)\n            updatedActivity.completed = true;\n        for (const activity of this.ongoingActivities) {\n            const { progress } = activity;\n            progressLeft += 1.0 - progress;\n            if (activity.completed) {\n                completedActivities++;\n            }\n        }\n        const lastProgress = updatedActivity.progress;\n        updatedActivity.progress = nextProgress;\n        // Advance the total progress by the fraction of total remaining progress\n        // due to this activity.\n        this.totalProgress += (nextProgress - lastProgress) *\n            (1.0 - this.totalProgress) / progressLeft;\n        const totalProgress = completedActivities === this.ongoingActivityCount ?\n            1.0 :\n            this.totalProgress;\n        this.dispatchEvent(new CustomEvent('progress', { detail: { totalProgress, reason } }));\n        if (completedActivities === this.ongoingActivityCount) {\n            this.totalProgress = 0.0;\n            this.ongoingActivities.clear();\n        }\n    }\n}\n//# sourceMappingURL=progress-tracker.js.map"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,KAAK,QAAQ,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,eAAe,SAASC,WAAW,CAAC;EAC7CC,WAAWA,CAAA,EAAG;IACV,KAAK,CAAC,GAAGC,SAAS,CAAC;IACnB,IAAI,CAACC,iBAAiB,GAAG,IAAIC,GAAG,CAAC,CAAC;IAClC,IAAI,CAACC,aAAa,GAAG,CAAC;EAC1B;EACA;AACJ;AACA;EACI,IAAIC,oBAAoBA,CAAA,EAAG;IACvB,OAAO,IAAI,CAACH,iBAAiB,CAACI,IAAI;EACtC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,aAAaA,CAACC,MAAM,EAAE;IAClB,MAAMC,QAAQ,GAAG;MAAEC,QAAQ,EAAE,CAAC;MAAEC,SAAS,EAAE;IAAM,CAAC;IAClD,IAAI,CAACT,iBAAiB,CAACU,GAAG,CAACH,QAAQ,CAAC;IACpC,IAAI,IAAI,CAACJ,oBAAoB,KAAK,CAAC,EAAE;MACjC;MACA;MACA,IAAI,CAACQ,qBAAqB,CAACJ,QAAQ,EAAE,CAAC,EAAED,MAAM,CAAC;IACnD;IACA,OAAQE,QAAQ,IAAK;MACjB,IAAII,YAAY;MAChBA,YAAY,GAAGC,IAAI,CAACC,GAAG,CAACnB,KAAK,CAACa,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC,EAAED,QAAQ,CAACC,QAAQ,CAAC;MACjE,IAAII,YAAY,KAAKL,QAAQ,CAACC,QAAQ,EAAE;QACpC,IAAI,CAACG,qBAAqB,CAACJ,QAAQ,EAAEK,YAAY,EAAEN,MAAM,CAAC;MAC9D;MACA,OAAOC,QAAQ,CAACC,QAAQ;IAC5B,CAAC;EACL;EACAG,qBAAqBA,CAACI,eAAe,EAAEH,YAAY,EAAEN,MAAM,EAAE;IACzD,IAAIU,YAAY,GAAG,CAAC;IACpB,IAAIC,mBAAmB,GAAG,CAAC;IAC3B,IAAIL,YAAY,IAAI,GAAG,EACnBG,eAAe,CAACN,SAAS,GAAG,IAAI;IACpC,KAAK,MAAMF,QAAQ,IAAI,IAAI,CAACP,iBAAiB,EAAE;MAC3C,MAAM;QAAEQ;MAAS,CAAC,GAAGD,QAAQ;MAC7BS,YAAY,IAAI,GAAG,GAAGR,QAAQ;MAC9B,IAAID,QAAQ,CAACE,SAAS,EAAE;QACpBQ,mBAAmB,EAAE;MACzB;IACJ;IACA,MAAMC,YAAY,GAAGH,eAAe,CAACP,QAAQ;IAC7CO,eAAe,CAACP,QAAQ,GAAGI,YAAY;IACvC;IACA;IACA,IAAI,CAACV,aAAa,IAAI,CAACU,YAAY,GAAGM,YAAY,KAC7C,GAAG,GAAG,IAAI,CAAChB,aAAa,CAAC,GAAGc,YAAY;IAC7C,MAAMd,aAAa,GAAGe,mBAAmB,KAAK,IAAI,CAACd,oBAAoB,GACnE,GAAG,GACH,IAAI,CAACD,aAAa;IACtB,IAAI,CAACiB,aAAa,CAAC,IAAIC,WAAW,CAAC,UAAU,EAAE;MAAEC,MAAM,EAAE;QAAEnB,aAAa;QAAEI;MAAO;IAAE,CAAC,CAAC,CAAC;IACtF,IAAIW,mBAAmB,KAAK,IAAI,CAACd,oBAAoB,EAAE;MACnD,IAAI,CAACD,aAAa,GAAG,GAAG;MACxB,IAAI,CAACF,iBAAiB,CAACsB,KAAK,CAAC,CAAC;IAClC;EACJ;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}