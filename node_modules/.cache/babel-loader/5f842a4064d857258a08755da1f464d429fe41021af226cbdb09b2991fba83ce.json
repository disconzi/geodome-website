{"ast":null,"code":"/* @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * KHR_materials_variants specification allows duplicated variant names\n * but it makes handling the extension complex.\n * We ensure tha names and make it easier.\n * If you want to export the extension with the original names\n * you are recommended to write GLTFExporter plugin to restore the names.\n *\n * @param variantNames {Array<string>}\n * @return {Array<string>}\n */\nconst ensureUniqueNames = variantNames => {\n  const uniqueNames = [];\n  const knownNames = new Set();\n  for (const name of variantNames) {\n    let uniqueName = name;\n    let suffix = 0;\n    // @TODO: An easy solution.\n    //        O(N^2) in the worst scenario where N is variantNames.length.\n    //        Fix me if needed.\n    while (knownNames.has(uniqueName)) {\n      uniqueName = name + '.' + ++suffix;\n    }\n    knownNames.add(uniqueName);\n    uniqueNames.push(uniqueName);\n  }\n  return uniqueNames;\n};\n/**\n * Convert mappings array to table object to make handling the extension easier.\n *\n * @param\n *     extensionDef {glTF.meshes[n].primitive.extensions.KHR_materials_variants}\n * @param variantNames {Array<string>} Required to be unique names\n * @return {Map}\n */\nconst mappingsArrayToTable = extensionDef => {\n  const table = new Map();\n  for (const mapping of extensionDef.mappings) {\n    for (const variant of mapping.variants) {\n      table.set(variant, {\n        material: null,\n        gltfMaterialIndex: mapping.material\n      });\n    }\n  }\n  return table;\n};\nexport default class GLTFMaterialsVariantsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = 'KHR_materials_variants';\n  }\n  // Note that the following properties will be overridden even if they are\n  // pre-defined\n  // - gltf.userData.variants\n  // - mesh.userData.variantMaterials\n  afterRoot(gltf) {\n    const parser = this.parser;\n    const json = parser.json;\n    if (json.extensions === undefined || json.extensions[this.name] === undefined) {\n      return null;\n    }\n    const extensionDef = json.extensions[this.name];\n    const variantsDef = extensionDef.variants || [];\n    const variants = ensureUniqueNames(variantsDef.map(v => v.name));\n    for (const scene of gltf.scenes) {\n      // Save the variants data under associated mesh.userData\n      scene.traverse(object => {\n        const mesh = object;\n        if (!mesh.material) {\n          return;\n        }\n        const association = parser.associations.get(mesh);\n        if (association == null || association.meshes == null || association.primitives == null) {\n          return;\n        }\n        const meshDef = json.meshes[association.meshes];\n        const primitivesDef = meshDef.primitives;\n        const primitiveDef = primitivesDef[association.primitives];\n        const extensionsDef = primitiveDef.extensions;\n        if (!extensionsDef || !extensionsDef[this.name]) {\n          return;\n        }\n        mesh.userData.variantMaterials = mappingsArrayToTable(extensionsDef[this.name]);\n      });\n    }\n    gltf.userData.variants = variants;\n    return Promise.resolve();\n  }\n}","map":{"version":3,"names":["ensureUniqueNames","variantNames","uniqueNames","knownNames","Set","name","uniqueName","suffix","has","add","push","mappingsArrayToTable","extensionDef","table","Map","mapping","mappings","variant","variants","set","material","gltfMaterialIndex","GLTFMaterialsVariantsExtension","constructor","parser","afterRoot","gltf","json","extensions","undefined","variantsDef","map","v","scene","scenes","traverse","object","mesh","association","associations","get","meshes","primitives","meshDef","primitivesDef","primitiveDef","extensionsDef","userData","variantMaterials","Promise","resolve"],"sources":["/Users/leandrodisconzi/CascadeProjects/geodome-website/node_modules/@google/model-viewer/lib/three-components/gltf-instance/VariantMaterialLoaderPlugin.js"],"sourcesContent":["/* @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * KHR_materials_variants specification allows duplicated variant names\n * but it makes handling the extension complex.\n * We ensure tha names and make it easier.\n * If you want to export the extension with the original names\n * you are recommended to write GLTFExporter plugin to restore the names.\n *\n * @param variantNames {Array<string>}\n * @return {Array<string>}\n */\nconst ensureUniqueNames = (variantNames) => {\n    const uniqueNames = [];\n    const knownNames = new Set();\n    for (const name of variantNames) {\n        let uniqueName = name;\n        let suffix = 0;\n        // @TODO: An easy solution.\n        //        O(N^2) in the worst scenario where N is variantNames.length.\n        //        Fix me if needed.\n        while (knownNames.has(uniqueName)) {\n            uniqueName = name + '.' + (++suffix);\n        }\n        knownNames.add(uniqueName);\n        uniqueNames.push(uniqueName);\n    }\n    return uniqueNames;\n};\n/**\n * Convert mappings array to table object to make handling the extension easier.\n *\n * @param\n *     extensionDef {glTF.meshes[n].primitive.extensions.KHR_materials_variants}\n * @param variantNames {Array<string>} Required to be unique names\n * @return {Map}\n */\nconst mappingsArrayToTable = (extensionDef) => {\n    const table = new Map();\n    for (const mapping of extensionDef.mappings) {\n        for (const variant of mapping.variants) {\n            table.set(variant, { material: null, gltfMaterialIndex: mapping.material });\n        }\n    }\n    return table;\n};\nexport default class GLTFMaterialsVariantsExtension {\n    constructor(parser) {\n        this.parser = parser;\n        this.name = 'KHR_materials_variants';\n    }\n    // Note that the following properties will be overridden even if they are\n    // pre-defined\n    // - gltf.userData.variants\n    // - mesh.userData.variantMaterials\n    afterRoot(gltf) {\n        const parser = this.parser;\n        const json = parser.json;\n        if (json.extensions === undefined ||\n            json.extensions[this.name] === undefined) {\n            return null;\n        }\n        const extensionDef = json.extensions[this.name];\n        const variantsDef = extensionDef.variants || [];\n        const variants = ensureUniqueNames(variantsDef.map((v) => v.name));\n        for (const scene of gltf.scenes) {\n            // Save the variants data under associated mesh.userData\n            scene.traverse(object => {\n                const mesh = object;\n                if (!mesh.material) {\n                    return;\n                }\n                const association = parser.associations.get(mesh);\n                if (association == null || association.meshes == null ||\n                    association.primitives == null) {\n                    return;\n                }\n                const meshDef = json.meshes[association.meshes];\n                const primitivesDef = meshDef.primitives;\n                const primitiveDef = primitivesDef[association.primitives];\n                const extensionsDef = primitiveDef.extensions;\n                if (!extensionsDef || !extensionsDef[this.name]) {\n                    return;\n                }\n                mesh.userData.variantMaterials =\n                    mappingsArrayToTable(extensionsDef[this.name]);\n            });\n        }\n        gltf.userData.variants = variants;\n        return Promise.resolve();\n    }\n}\n//# sourceMappingURL=VariantMaterialLoaderPlugin.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}