{"ast":null,"code":"/* @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BackSide, Box3, Mesh, MeshBasicMaterial, MeshDepthMaterial, Object3D, OrthographicCamera, PlaneGeometry, RGBAFormat, ShaderMaterial, Vector3, WebGLRenderTarget } from 'three';\nimport { HorizontalBlurShader } from 'three/examples/jsm/shaders/HorizontalBlurShader.js';\nimport { VerticalBlurShader } from 'three/examples/jsm/shaders/VerticalBlurShader.js';\nimport { lerp } from 'three/src/math/MathUtils.js';\n// The softness [0, 1] of the shadow is mapped to a resolution between\n// 2^LOG_MAX_RESOLUTION and 2^LOG_MIN_RESOLUTION.\nconst LOG_MAX_RESOLUTION = 9;\nconst LOG_MIN_RESOLUTION = 6;\n// Animated models are not in general contained in their bounding box, as this\n// is calculated only for their resting pose. We create a cubic shadow volume\n// for animated models sized to their largest bounding box dimension multiplied\n// by this scale factor.\nconst ANIMATION_SCALING = 2;\n// Since hard shadows are not lightened by blurring and depth, set a lower\n// default intensity to make them more perceptually similar to the intensity of\n// the soft shadows.\nconst DEFAULT_HARD_INTENSITY = 0.3;\n/**\n * The Shadow class creates a shadow that fits a given scene and follows a\n * target. This shadow will follow the scene without any updates needed so long\n * as the shadow and scene are both parented to the same object (call it the\n * scene) and this scene is passed as the target parameter to the shadow's\n * constructor. We also must constrain the scene to motion within the horizontal\n * plane and call the setRotation() method whenever the scene's Y-axis rotation\n * changes. For motion outside of the horizontal plane, this.needsUpdate must be\n * set to true.\n *\n * The softness of the shadow is controlled by changing its resolution, making\n * softer shadows faster, but less precise.\n */\nexport class Shadow extends Object3D {\n  constructor(scene, softness, side) {\n    super();\n    this.camera = new OrthographicCamera();\n    // private cameraHelper = new CameraHelper(this.camera);\n    this.renderTarget = null;\n    this.renderTargetBlur = null;\n    this.depthMaterial = new MeshDepthMaterial();\n    this.horizontalBlurMaterial = new ShaderMaterial(HorizontalBlurShader);\n    this.verticalBlurMaterial = new ShaderMaterial(VerticalBlurShader);\n    this.intensity = 0;\n    this.softness = 1;\n    this.boundingBox = new Box3();\n    this.size = new Vector3();\n    this.maxDimension = 0;\n    this.isAnimated = false;\n    this.needsUpdate = false;\n    const {\n      camera\n    } = this;\n    camera.rotation.x = Math.PI / 2;\n    camera.left = -0.5;\n    camera.right = 0.5;\n    camera.bottom = -0.5;\n    camera.top = 0.5;\n    this.add(camera);\n    // this.add(this.cameraHelper);\n    // this.cameraHelper.updateMatrixWorld = function() {\n    //   this.matrixWorld = this.camera.matrixWorld;\n    // };\n    const plane = new PlaneGeometry();\n    const shadowMaterial = new MeshBasicMaterial({\n      // color: new Color(1, 0, 0),\n      opacity: 1,\n      transparent: true,\n      side: BackSide\n    });\n    this.floor = new Mesh(plane, shadowMaterial);\n    this.floor.userData.noHit = true;\n    camera.add(this.floor);\n    // the plane onto which to blur the texture\n    this.blurPlane = new Mesh(plane);\n    this.blurPlane.visible = false;\n    camera.add(this.blurPlane);\n    scene.target.add(this);\n    // like MeshDepthMaterial, but goes from black to transparent\n    this.depthMaterial.onBeforeCompile = function (shader) {\n      shader.fragmentShader = shader.fragmentShader.replace('gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );', 'gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * opacity );');\n    };\n    this.horizontalBlurMaterial.depthTest = false;\n    this.verticalBlurMaterial.depthTest = false;\n    this.setScene(scene, softness, side);\n  }\n  /**\n   * Update the shadow's size and position for a new scene. Softness is also\n   * needed, as this controls the shadow's resolution.\n   */\n  setScene(scene, softness, side) {\n    const {\n      boundingBox,\n      size,\n      rotation,\n      position\n    } = this;\n    this.isAnimated = scene.animationNames.length > 0;\n    this.boundingBox.copy(scene.boundingBox);\n    this.size.copy(scene.size);\n    this.maxDimension = Math.max(size.x, size.y, size.z) * (this.isAnimated ? ANIMATION_SCALING : 1);\n    this.boundingBox.getCenter(position);\n    if (side === 'back') {\n      const {\n        min,\n        max\n      } = boundingBox;\n      [min.y, min.z] = [min.z, min.y];\n      [max.y, max.z] = [max.z, max.y];\n      [size.y, size.z] = [size.z, size.y];\n      rotation.x = Math.PI / 2;\n      rotation.y = Math.PI;\n    } else {\n      rotation.x = 0;\n      rotation.y = 0;\n    }\n    if (this.isAnimated) {\n      const minY = boundingBox.min.y;\n      const maxY = boundingBox.max.y;\n      size.y = this.maxDimension;\n      boundingBox.expandByVector(size.subScalar(this.maxDimension).multiplyScalar(-0.5));\n      boundingBox.min.y = minY;\n      boundingBox.max.y = maxY;\n      size.set(this.maxDimension, maxY - minY, this.maxDimension);\n    }\n    if (side === 'bottom') {\n      position.y = boundingBox.min.y;\n    } else {\n      position.z = boundingBox.min.y;\n    }\n    this.setSoftness(softness);\n  }\n  /**\n   * Update the shadow's resolution based on softness (between 0 and 1). Should\n   * not be called frequently, as this results in reallocation.\n   */\n  setSoftness(softness) {\n    this.softness = softness;\n    const {\n      size,\n      camera\n    } = this;\n    const scaleY = this.isAnimated ? ANIMATION_SCALING : 1;\n    const resolution = scaleY * Math.pow(2, LOG_MAX_RESOLUTION - softness * (LOG_MAX_RESOLUTION - LOG_MIN_RESOLUTION));\n    this.setMapSize(resolution);\n    const softFar = size.y / 2;\n    const hardFar = size.y * scaleY;\n    camera.near = 0;\n    camera.far = lerp(hardFar, softFar, softness);\n    // we have co-opted opacity to scale the depth to clip\n    this.depthMaterial.opacity = 1.0 / softness;\n    camera.updateProjectionMatrix();\n    // this.cameraHelper.update();\n    this.setIntensity(this.intensity);\n    this.setOffset(0);\n  }\n  /**\n   * Lower-level version of the above function.\n   */\n  setMapSize(maxMapSize) {\n    const {\n      size\n    } = this;\n    if (this.isAnimated) {\n      maxMapSize *= ANIMATION_SCALING;\n    }\n    const baseWidth = Math.floor(size.x > size.z ? maxMapSize : maxMapSize * size.x / size.z);\n    const baseHeight = Math.floor(size.x > size.z ? maxMapSize * size.z / size.x : maxMapSize);\n    // width of blur filter in pixels (not adjustable)\n    const TAP_WIDTH = 10;\n    const width = TAP_WIDTH + baseWidth;\n    const height = TAP_WIDTH + baseHeight;\n    if (this.renderTarget != null && (this.renderTarget.width !== width || this.renderTarget.height !== height)) {\n      this.renderTarget.dispose();\n      this.renderTarget = null;\n      this.renderTargetBlur.dispose();\n      this.renderTargetBlur = null;\n    }\n    if (this.renderTarget == null) {\n      const params = {\n        format: RGBAFormat\n      };\n      this.renderTarget = new WebGLRenderTarget(width, height, params);\n      this.renderTargetBlur = new WebGLRenderTarget(width, height, params);\n      this.floor.material.map = this.renderTarget.texture;\n    }\n    // These pads account for the softening radius around the shadow.\n    this.camera.scale.set(size.x * (1 + TAP_WIDTH / baseWidth), size.z * (1 + TAP_WIDTH / baseHeight), 1);\n    this.needsUpdate = true;\n  }\n  /**\n   * Set the shadow's intensity (0 to 1), which is just its opacity. Turns off\n   * shadow rendering if zero.\n   */\n  setIntensity(intensity) {\n    this.intensity = intensity;\n    if (intensity > 0) {\n      this.visible = true;\n      this.floor.visible = true;\n      this.floor.material.opacity = intensity * lerp(DEFAULT_HARD_INTENSITY, 1, this.softness * this.softness);\n    } else {\n      this.visible = false;\n      this.floor.visible = false;\n    }\n  }\n  getIntensity() {\n    return this.intensity;\n  }\n  /**\n   * An offset can be specified to move the\n   * shadow vertically relative to the bottom of the scene. Positive is up, so\n   * values are generally negative. A small offset keeps our shadow from\n   * z-fighting with any baked-in shadow plane.\n   */\n  setOffset(offset) {\n    this.floor.position.z = -offset + this.gap();\n  }\n  gap() {\n    return 0.001 * this.maxDimension;\n  }\n  render(renderer, scene) {\n    // this.cameraHelper.visible = false;\n    // force the depthMaterial to everything\n    scene.overrideMaterial = this.depthMaterial;\n    // set renderer clear alpha\n    const initialClearAlpha = renderer.getClearAlpha();\n    renderer.setClearAlpha(0);\n    this.floor.visible = false;\n    // disable XR for offscreen rendering\n    const xrEnabled = renderer.xr.enabled;\n    renderer.xr.enabled = false;\n    // render to the render target to get the depths\n    const oldRenderTarget = renderer.getRenderTarget();\n    renderer.setRenderTarget(this.renderTarget);\n    renderer.render(scene, this.camera);\n    // and reset the override material\n    scene.overrideMaterial = null;\n    this.floor.visible = true;\n    this.blurShadow(renderer);\n    // reset and render the normal scene\n    renderer.xr.enabled = xrEnabled;\n    renderer.setRenderTarget(oldRenderTarget);\n    renderer.setClearAlpha(initialClearAlpha);\n    // this.cameraHelper.visible = true;\n  }\n  blurShadow(renderer) {\n    const {\n      camera,\n      horizontalBlurMaterial,\n      verticalBlurMaterial,\n      renderTarget,\n      renderTargetBlur,\n      blurPlane\n    } = this;\n    blurPlane.visible = true;\n    // blur horizontally and draw in the renderTargetBlur\n    blurPlane.material = horizontalBlurMaterial;\n    horizontalBlurMaterial.uniforms.h.value = 1 / this.renderTarget.width;\n    horizontalBlurMaterial.uniforms.tDiffuse.value = this.renderTarget.texture;\n    renderer.setRenderTarget(renderTargetBlur);\n    renderer.render(blurPlane, camera);\n    // blur vertically and draw in the main renderTarget\n    blurPlane.material = verticalBlurMaterial;\n    verticalBlurMaterial.uniforms.v.value = 1 / this.renderTarget.height;\n    verticalBlurMaterial.uniforms.tDiffuse.value = this.renderTargetBlur.texture;\n    renderer.setRenderTarget(renderTarget);\n    renderer.render(blurPlane, camera);\n    blurPlane.visible = false;\n  }\n  dispose() {\n    if (this.renderTarget != null) {\n      this.renderTarget.dispose();\n    }\n    if (this.renderTargetBlur != null) {\n      this.renderTargetBlur.dispose();\n    }\n    this.depthMaterial.dispose();\n    this.horizontalBlurMaterial.dispose();\n    this.verticalBlurMaterial.dispose();\n    this.floor.material.dispose();\n    this.floor.geometry.dispose();\n    this.blurPlane.geometry.dispose();\n    this.removeFromParent();\n  }\n}","map":{"version":3,"names":["BackSide","Box3","Mesh","MeshBasicMaterial","MeshDepthMaterial","Object3D","OrthographicCamera","PlaneGeometry","RGBAFormat","ShaderMaterial","Vector3","WebGLRenderTarget","HorizontalBlurShader","VerticalBlurShader","lerp","LOG_MAX_RESOLUTION","LOG_MIN_RESOLUTION","ANIMATION_SCALING","DEFAULT_HARD_INTENSITY","Shadow","constructor","scene","softness","side","camera","renderTarget","renderTargetBlur","depthMaterial","horizontalBlurMaterial","verticalBlurMaterial","intensity","boundingBox","size","maxDimension","isAnimated","needsUpdate","rotation","x","Math","PI","left","right","bottom","top","add","plane","shadowMaterial","opacity","transparent","floor","userData","noHit","blurPlane","visible","target","onBeforeCompile","shader","fragmentShader","replace","depthTest","setScene","position","animationNames","length","copy","max","y","z","getCenter","min","minY","maxY","expandByVector","subScalar","multiplyScalar","set","setSoftness","scaleY","resolution","pow","setMapSize","softFar","hardFar","near","far","updateProjectionMatrix","setIntensity","setOffset","maxMapSize","baseWidth","baseHeight","TAP_WIDTH","width","height","dispose","params","format","material","map","texture","scale","getIntensity","offset","gap","render","renderer","overrideMaterial","initialClearAlpha","getClearAlpha","setClearAlpha","xrEnabled","xr","enabled","oldRenderTarget","getRenderTarget","setRenderTarget","blurShadow","uniforms","h","value","tDiffuse","v","geometry","removeFromParent"],"sources":["/Users/leandrodisconzi/CascadeProjects/geodome-website/node_modules/@google/model-viewer/lib/three-components/Shadow.js"],"sourcesContent":["/* @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BackSide, Box3, Mesh, MeshBasicMaterial, MeshDepthMaterial, Object3D, OrthographicCamera, PlaneGeometry, RGBAFormat, ShaderMaterial, Vector3, WebGLRenderTarget } from 'three';\nimport { HorizontalBlurShader } from 'three/examples/jsm/shaders/HorizontalBlurShader.js';\nimport { VerticalBlurShader } from 'three/examples/jsm/shaders/VerticalBlurShader.js';\nimport { lerp } from 'three/src/math/MathUtils.js';\n// The softness [0, 1] of the shadow is mapped to a resolution between\n// 2^LOG_MAX_RESOLUTION and 2^LOG_MIN_RESOLUTION.\nconst LOG_MAX_RESOLUTION = 9;\nconst LOG_MIN_RESOLUTION = 6;\n// Animated models are not in general contained in their bounding box, as this\n// is calculated only for their resting pose. We create a cubic shadow volume\n// for animated models sized to their largest bounding box dimension multiplied\n// by this scale factor.\nconst ANIMATION_SCALING = 2;\n// Since hard shadows are not lightened by blurring and depth, set a lower\n// default intensity to make them more perceptually similar to the intensity of\n// the soft shadows.\nconst DEFAULT_HARD_INTENSITY = 0.3;\n/**\n * The Shadow class creates a shadow that fits a given scene and follows a\n * target. This shadow will follow the scene without any updates needed so long\n * as the shadow and scene are both parented to the same object (call it the\n * scene) and this scene is passed as the target parameter to the shadow's\n * constructor. We also must constrain the scene to motion within the horizontal\n * plane and call the setRotation() method whenever the scene's Y-axis rotation\n * changes. For motion outside of the horizontal plane, this.needsUpdate must be\n * set to true.\n *\n * The softness of the shadow is controlled by changing its resolution, making\n * softer shadows faster, but less precise.\n */\nexport class Shadow extends Object3D {\n    constructor(scene, softness, side) {\n        super();\n        this.camera = new OrthographicCamera();\n        // private cameraHelper = new CameraHelper(this.camera);\n        this.renderTarget = null;\n        this.renderTargetBlur = null;\n        this.depthMaterial = new MeshDepthMaterial();\n        this.horizontalBlurMaterial = new ShaderMaterial(HorizontalBlurShader);\n        this.verticalBlurMaterial = new ShaderMaterial(VerticalBlurShader);\n        this.intensity = 0;\n        this.softness = 1;\n        this.boundingBox = new Box3;\n        this.size = new Vector3;\n        this.maxDimension = 0;\n        this.isAnimated = false;\n        this.needsUpdate = false;\n        const { camera } = this;\n        camera.rotation.x = Math.PI / 2;\n        camera.left = -0.5;\n        camera.right = 0.5;\n        camera.bottom = -0.5;\n        camera.top = 0.5;\n        this.add(camera);\n        // this.add(this.cameraHelper);\n        // this.cameraHelper.updateMatrixWorld = function() {\n        //   this.matrixWorld = this.camera.matrixWorld;\n        // };\n        const plane = new PlaneGeometry();\n        const shadowMaterial = new MeshBasicMaterial({\n            // color: new Color(1, 0, 0),\n            opacity: 1,\n            transparent: true,\n            side: BackSide,\n        });\n        this.floor = new Mesh(plane, shadowMaterial);\n        this.floor.userData.noHit = true;\n        camera.add(this.floor);\n        // the plane onto which to blur the texture\n        this.blurPlane = new Mesh(plane);\n        this.blurPlane.visible = false;\n        camera.add(this.blurPlane);\n        scene.target.add(this);\n        // like MeshDepthMaterial, but goes from black to transparent\n        this.depthMaterial.onBeforeCompile = function (shader) {\n            shader.fragmentShader = shader.fragmentShader.replace('gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );', 'gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * opacity );');\n        };\n        this.horizontalBlurMaterial.depthTest = false;\n        this.verticalBlurMaterial.depthTest = false;\n        this.setScene(scene, softness, side);\n    }\n    /**\n     * Update the shadow's size and position for a new scene. Softness is also\n     * needed, as this controls the shadow's resolution.\n     */\n    setScene(scene, softness, side) {\n        const { boundingBox, size, rotation, position } = this;\n        this.isAnimated = scene.animationNames.length > 0;\n        this.boundingBox.copy(scene.boundingBox);\n        this.size.copy(scene.size);\n        this.maxDimension = Math.max(size.x, size.y, size.z) *\n            (this.isAnimated ? ANIMATION_SCALING : 1);\n        this.boundingBox.getCenter(position);\n        if (side === 'back') {\n            const { min, max } = boundingBox;\n            [min.y, min.z] = [min.z, min.y];\n            [max.y, max.z] = [max.z, max.y];\n            [size.y, size.z] = [size.z, size.y];\n            rotation.x = Math.PI / 2;\n            rotation.y = Math.PI;\n        }\n        else {\n            rotation.x = 0;\n            rotation.y = 0;\n        }\n        if (this.isAnimated) {\n            const minY = boundingBox.min.y;\n            const maxY = boundingBox.max.y;\n            size.y = this.maxDimension;\n            boundingBox.expandByVector(size.subScalar(this.maxDimension).multiplyScalar(-0.5));\n            boundingBox.min.y = minY;\n            boundingBox.max.y = maxY;\n            size.set(this.maxDimension, maxY - minY, this.maxDimension);\n        }\n        if (side === 'bottom') {\n            position.y = boundingBox.min.y;\n        }\n        else {\n            position.z = boundingBox.min.y;\n        }\n        this.setSoftness(softness);\n    }\n    /**\n     * Update the shadow's resolution based on softness (between 0 and 1). Should\n     * not be called frequently, as this results in reallocation.\n     */\n    setSoftness(softness) {\n        this.softness = softness;\n        const { size, camera } = this;\n        const scaleY = (this.isAnimated ? ANIMATION_SCALING : 1);\n        const resolution = scaleY *\n            Math.pow(2, LOG_MAX_RESOLUTION -\n                softness * (LOG_MAX_RESOLUTION - LOG_MIN_RESOLUTION));\n        this.setMapSize(resolution);\n        const softFar = size.y / 2;\n        const hardFar = size.y * scaleY;\n        camera.near = 0;\n        camera.far = lerp(hardFar, softFar, softness);\n        // we have co-opted opacity to scale the depth to clip\n        this.depthMaterial.opacity = 1.0 / softness;\n        camera.updateProjectionMatrix();\n        // this.cameraHelper.update();\n        this.setIntensity(this.intensity);\n        this.setOffset(0);\n    }\n    /**\n     * Lower-level version of the above function.\n     */\n    setMapSize(maxMapSize) {\n        const { size } = this;\n        if (this.isAnimated) {\n            maxMapSize *= ANIMATION_SCALING;\n        }\n        const baseWidth = Math.floor(size.x > size.z ? maxMapSize : maxMapSize * size.x / size.z);\n        const baseHeight = Math.floor(size.x > size.z ? maxMapSize * size.z / size.x : maxMapSize);\n        // width of blur filter in pixels (not adjustable)\n        const TAP_WIDTH = 10;\n        const width = TAP_WIDTH + baseWidth;\n        const height = TAP_WIDTH + baseHeight;\n        if (this.renderTarget != null &&\n            (this.renderTarget.width !== width ||\n                this.renderTarget.height !== height)) {\n            this.renderTarget.dispose();\n            this.renderTarget = null;\n            this.renderTargetBlur.dispose();\n            this.renderTargetBlur = null;\n        }\n        if (this.renderTarget == null) {\n            const params = { format: RGBAFormat };\n            this.renderTarget = new WebGLRenderTarget(width, height, params);\n            this.renderTargetBlur = new WebGLRenderTarget(width, height, params);\n            this.floor.material.map =\n                this.renderTarget.texture;\n        }\n        // These pads account for the softening radius around the shadow.\n        this.camera.scale.set(size.x * (1 + TAP_WIDTH / baseWidth), size.z * (1 + TAP_WIDTH / baseHeight), 1);\n        this.needsUpdate = true;\n    }\n    /**\n     * Set the shadow's intensity (0 to 1), which is just its opacity. Turns off\n     * shadow rendering if zero.\n     */\n    setIntensity(intensity) {\n        this.intensity = intensity;\n        if (intensity > 0) {\n            this.visible = true;\n            this.floor.visible = true;\n            this.floor.material.opacity = intensity *\n                lerp(DEFAULT_HARD_INTENSITY, 1, this.softness * this.softness);\n        }\n        else {\n            this.visible = false;\n            this.floor.visible = false;\n        }\n    }\n    getIntensity() {\n        return this.intensity;\n    }\n    /**\n     * An offset can be specified to move the\n     * shadow vertically relative to the bottom of the scene. Positive is up, so\n     * values are generally negative. A small offset keeps our shadow from\n     * z-fighting with any baked-in shadow plane.\n     */\n    setOffset(offset) {\n        this.floor.position.z = -offset + this.gap();\n    }\n    gap() {\n        return 0.001 * this.maxDimension;\n    }\n    render(renderer, scene) {\n        // this.cameraHelper.visible = false;\n        // force the depthMaterial to everything\n        scene.overrideMaterial = this.depthMaterial;\n        // set renderer clear alpha\n        const initialClearAlpha = renderer.getClearAlpha();\n        renderer.setClearAlpha(0);\n        this.floor.visible = false;\n        // disable XR for offscreen rendering\n        const xrEnabled = renderer.xr.enabled;\n        renderer.xr.enabled = false;\n        // render to the render target to get the depths\n        const oldRenderTarget = renderer.getRenderTarget();\n        renderer.setRenderTarget(this.renderTarget);\n        renderer.render(scene, this.camera);\n        // and reset the override material\n        scene.overrideMaterial = null;\n        this.floor.visible = true;\n        this.blurShadow(renderer);\n        // reset and render the normal scene\n        renderer.xr.enabled = xrEnabled;\n        renderer.setRenderTarget(oldRenderTarget);\n        renderer.setClearAlpha(initialClearAlpha);\n        // this.cameraHelper.visible = true;\n    }\n    blurShadow(renderer) {\n        const { camera, horizontalBlurMaterial, verticalBlurMaterial, renderTarget, renderTargetBlur, blurPlane } = this;\n        blurPlane.visible = true;\n        // blur horizontally and draw in the renderTargetBlur\n        blurPlane.material = horizontalBlurMaterial;\n        horizontalBlurMaterial.uniforms.h.value = 1 / this.renderTarget.width;\n        horizontalBlurMaterial.uniforms.tDiffuse.value = this.renderTarget.texture;\n        renderer.setRenderTarget(renderTargetBlur);\n        renderer.render(blurPlane, camera);\n        // blur vertically and draw in the main renderTarget\n        blurPlane.material = verticalBlurMaterial;\n        verticalBlurMaterial.uniforms.v.value = 1 / this.renderTarget.height;\n        verticalBlurMaterial.uniforms.tDiffuse.value =\n            this.renderTargetBlur.texture;\n        renderer.setRenderTarget(renderTarget);\n        renderer.render(blurPlane, camera);\n        blurPlane.visible = false;\n    }\n    dispose() {\n        if (this.renderTarget != null) {\n            this.renderTarget.dispose();\n        }\n        if (this.renderTargetBlur != null) {\n            this.renderTargetBlur.dispose();\n        }\n        this.depthMaterial.dispose();\n        this.horizontalBlurMaterial.dispose();\n        this.verticalBlurMaterial.dispose();\n        this.floor.material.dispose();\n        this.floor.geometry.dispose();\n        this.blurPlane.geometry.dispose();\n        this.removeFromParent();\n    }\n}\n//# sourceMappingURL=Shadow.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}