{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ACESFilmicToneMapping, EventDispatcher, NeutralToneMapping, Vector2, WebGLRenderer } from 'three';\nimport { $updateEnvironment } from '../features/environment.js';\nimport { $canvas, $tick, $updateSize } from '../model-viewer-base.js';\nimport { clamp, isDebugMode } from '../utilities.js';\nimport { ARRenderer } from './ARRenderer.js';\nimport { CachingGLTFLoader } from './CachingGLTFLoader.js';\nimport { ModelViewerGLTFInstance } from './gltf-instance/ModelViewerGLTFInstance.js';\nimport TextureUtils from './TextureUtils.js';\n// Between 0 and 1: larger means the average responds faster and is less smooth.\nconst DURATION_DECAY = 0.2;\nconst LOW_FRAME_DURATION_MS = 40;\nconst HIGH_FRAME_DURATION_MS = 60;\nconst MAX_AVG_CHANGE_MS = 5;\nconst SCALE_STEPS = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25];\nconst DEFAULT_LAST_STEP = 3;\nexport const DEFAULT_POWER_PREFERENCE = 'high-performance';\nconst COMMERCE_EXPOSURE = 1.3;\n/**\n * Registers canvases with Canvas2DRenderingContexts and renders them\n * all in the same WebGLRenderingContext, spitting out textures to apply\n * to the canvases. Creates a fullscreen WebGL canvas that is not added\n * to the DOM, and on each frame, renders each registered canvas on a portion\n * of the WebGL canvas, and applies the texture on the registered canvas.\n *\n * In the future, can use ImageBitmapRenderingContext instead of\n * Canvas2DRenderingContext if supported for cheaper transferring of\n * the texture.\n */\nexport class Renderer extends EventDispatcher {\n  constructor(options) {\n    super();\n    this.loader = new CachingGLTFLoader(ModelViewerGLTFInstance);\n    this.width = 0;\n    this.height = 0;\n    this.dpr = 1;\n    this.scenes = new Set();\n    this.multipleScenesVisible = false;\n    this.lastTick = performance.now();\n    this.renderedLastFrame = false;\n    this.scaleStep = 0;\n    this.lastStep = DEFAULT_LAST_STEP;\n    this.avgFrameDuration = (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n    this.onWebGLContextLost = event => {\n      this.dispatchEvent({\n        type: 'contextlost',\n        sourceEvent: event\n      });\n    };\n    this.onWebGLContextRestored = () => {\n      var _a;\n      (_a = this.textureUtils) === null || _a === void 0 ? void 0 : _a.dispose();\n      this.textureUtils = new TextureUtils(this.threeRenderer);\n      for (const scene of this.scenes) {\n        scene.element[$updateEnvironment]();\n      }\n    };\n    this.dpr = window.devicePixelRatio;\n    this.canvas3D = document.createElement('canvas');\n    this.canvas3D.id = 'webgl-canvas';\n    this.canvas3D.classList.add('show');\n    try {\n      this.threeRenderer = new WebGLRenderer({\n        canvas: this.canvas3D,\n        alpha: true,\n        antialias: true,\n        powerPreference: options.powerPreference,\n        preserveDrawingBuffer: true\n      });\n      this.threeRenderer.autoClear = true;\n      this.threeRenderer.setPixelRatio(1); // handle pixel ratio externally\n      this.threeRenderer.debug = {\n        checkShaderErrors: !!options.debug,\n        onShaderError: null\n      };\n      // ACESFilmicToneMapping appears to be the most \"saturated\",\n      // and similar to Filament's gltf-viewer.\n      this.threeRenderer.toneMapping = ACESFilmicToneMapping;\n    } catch (error) {\n      console.warn(error);\n    }\n    this.arRenderer = new ARRenderer(this);\n    this.textureUtils = this.canRender ? new TextureUtils(this.threeRenderer) : null;\n    CachingGLTFLoader.initializeKTX2Loader(this.threeRenderer);\n    this.canvas3D.addEventListener('webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.addEventListener('webglcontextrestored', this.onWebGLContextRestored);\n    this.updateRendererSize();\n  }\n  static get singleton() {\n    if (!this._singleton) {\n      this._singleton = new Renderer({\n        powerPreference: (self.ModelViewerElement || {}).powerPreference || DEFAULT_POWER_PREFERENCE,\n        debug: isDebugMode()\n      });\n    }\n    return this._singleton;\n  }\n  static resetSingleton() {\n    const elements = this._singleton.dispose();\n    for (const element of elements) {\n      element.disconnectedCallback();\n    }\n    this._singleton = new Renderer({\n      powerPreference: (self.ModelViewerElement || {}).powerPreference || DEFAULT_POWER_PREFERENCE,\n      debug: isDebugMode()\n    });\n    for (const element of elements) {\n      element.connectedCallback();\n    }\n  }\n  get canRender() {\n    return this.threeRenderer != null;\n  }\n  get scaleFactor() {\n    return SCALE_STEPS[this.scaleStep];\n  }\n  set minScale(scale) {\n    let i = 1;\n    while (i < SCALE_STEPS.length) {\n      if (SCALE_STEPS[i] < scale) {\n        break;\n      }\n      ++i;\n    }\n    this.lastStep = i - 1;\n  }\n  registerScene(scene) {\n    this.scenes.add(scene);\n    scene.forceRescale();\n    const size = new Vector2();\n    this.threeRenderer.getSize(size);\n    scene.canvas.width = size.x;\n    scene.canvas.height = size.y;\n    if (this.canRender && this.scenes.size > 0) {\n      this.threeRenderer.setAnimationLoop((time, frame) => this.render(time, frame));\n    }\n  }\n  unregisterScene(scene) {\n    this.scenes.delete(scene);\n    if (this.canvas3D.parentElement === scene.canvas.parentElement) {\n      scene.canvas.parentElement.removeChild(this.canvas3D);\n    }\n    if (this.canRender && this.scenes.size === 0) {\n      this.threeRenderer.setAnimationLoop(null);\n    }\n  }\n  displayCanvas(scene) {\n    return scene.element.modelIsVisible && !this.multipleScenesVisible ? this.canvas3D : scene.element[$canvas];\n  }\n  /**\n   * The function enables an optimization, where when there is only a single\n   * <model-viewer> element, we can use the renderer's 3D canvas directly for\n   * display. Otherwise we need to use the element's 2D canvas and copy the\n   * renderer's result into it.\n   */\n  countVisibleScenes() {\n    const {\n      canvas3D\n    } = this;\n    let visibleScenes = 0;\n    let canvas3DScene = null;\n    for (const scene of this.scenes) {\n      const {\n        element\n      } = scene;\n      if (element.modelIsVisible && scene.externalRenderer == null) {\n        ++visibleScenes;\n      }\n      if (canvas3D.parentElement === scene.canvas.parentElement) {\n        canvas3DScene = scene;\n      }\n    }\n    const multipleScenesVisible = visibleScenes > 1;\n    if (canvas3DScene != null) {\n      const newlyMultiple = multipleScenesVisible && !this.multipleScenesVisible;\n      const disappearing = !canvas3DScene.element.modelIsVisible;\n      if (newlyMultiple || disappearing) {\n        const {\n          width,\n          height\n        } = this.sceneSize(canvas3DScene);\n        this.copyPixels(canvas3DScene, width, height);\n        canvas3D.parentElement.removeChild(canvas3D);\n      }\n    }\n    this.multipleScenesVisible = multipleScenesVisible;\n  }\n  /**\n   * Updates the renderer's size based on the largest scene and any changes to\n   * device pixel ratio.\n   */\n  updateRendererSize() {\n    var _a;\n    const dpr = window.devicePixelRatio;\n    if (dpr !== this.dpr) {\n      // If the device pixel ratio has changed due to page zoom, elements\n      // specified by % width do not fire a resize event even though their CSS\n      // pixel dimensions change, so we force them to update their size here.\n      for (const scene of this.scenes) {\n        const {\n          element\n        } = scene;\n        element[$updateSize](element.getBoundingClientRect());\n      }\n    }\n    // Make the renderer the size of the largest scene\n    let width = 0;\n    let height = 0;\n    for (const scene of this.scenes) {\n      width = Math.max(width, scene.width);\n      height = Math.max(height, scene.height);\n    }\n    if (width === this.width && height === this.height && dpr === this.dpr) {\n      return;\n    }\n    this.width = width;\n    this.height = height;\n    this.dpr = dpr;\n    width = Math.ceil(width * dpr);\n    height = Math.ceil(height * dpr);\n    if (this.canRender) {\n      this.threeRenderer.setSize(width, height, false);\n    }\n    // Each scene's canvas must match the renderer size. In general they can be\n    // larger than the element that contains them, but the overflow is hidden\n    // and only the portion that is shown is copied over.\n    for (const scene of this.scenes) {\n      const {\n        canvas\n      } = scene;\n      canvas.width = width;\n      canvas.height = height;\n      scene.forceRescale();\n      (_a = scene.effectRenderer) === null || _a === void 0 ? void 0 : _a.setSize(width, height);\n    }\n  }\n  updateRendererScale(delta) {\n    const scaleStep = this.scaleStep;\n    this.avgFrameDuration += clamp(DURATION_DECAY * (delta - this.avgFrameDuration), -MAX_AVG_CHANGE_MS, MAX_AVG_CHANGE_MS);\n    if (this.avgFrameDuration > HIGH_FRAME_DURATION_MS) {\n      ++this.scaleStep;\n    } else if (this.avgFrameDuration < LOW_FRAME_DURATION_MS && this.scaleStep > 0) {\n      --this.scaleStep;\n    }\n    this.scaleStep = Math.min(this.scaleStep, this.lastStep);\n    if (scaleStep !== this.scaleStep) {\n      this.avgFrameDuration = (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n    }\n  }\n  shouldRender(scene) {\n    if (!scene.shouldRender()) {\n      // The first frame we stop rendering the scene (because it stops moving),\n      // trigger one extra render at full scale.\n      if (scene.scaleStep != 0) {\n        scene.scaleStep = 0;\n        this.rescaleCanvas(scene);\n      } else {\n        return false;\n      }\n    } else if (scene.scaleStep != this.scaleStep) {\n      // Update render scale\n      scene.scaleStep = this.scaleStep;\n      this.rescaleCanvas(scene);\n    }\n    return true;\n  }\n  rescaleCanvas(scene) {\n    const scale = SCALE_STEPS[scene.scaleStep];\n    const width = Math.ceil(this.width / scale);\n    const height = Math.ceil(this.height / scale);\n    const {\n      style\n    } = scene.canvas;\n    style.width = `${width}px`;\n    style.height = `${height}px`;\n    this.canvas3D.style.width = `${width}px`;\n    this.canvas3D.style.height = `${height}px`;\n    const renderedDpr = this.dpr * scale;\n    const reason = scale < 1 ? 'GPU throttling' : this.dpr !== window.devicePixelRatio ? 'No meta viewport tag' : '';\n    scene.element.dispatchEvent(new CustomEvent('render-scale', {\n      detail: {\n        reportedDpr: window.devicePixelRatio,\n        renderedDpr: renderedDpr,\n        minimumDpr: this.dpr * SCALE_STEPS[this.lastStep],\n        pixelWidth: Math.ceil(scene.width * renderedDpr),\n        pixelHeight: Math.ceil(scene.height * renderedDpr),\n        reason: reason\n      }\n    }));\n  }\n  sceneSize(scene) {\n    const {\n      dpr\n    } = this;\n    const scaleFactor = SCALE_STEPS[scene.scaleStep];\n    // We avoid using the Three.js PixelRatio and handle it ourselves here so\n    // that we can do proper rounding and avoid white boundary pixels.\n    const width = Math.min(Math.ceil(scene.width * scaleFactor * dpr), this.canvas3D.width);\n    const height = Math.min(Math.ceil(scene.height * scaleFactor * dpr), this.canvas3D.height);\n    return {\n      width,\n      height\n    };\n  }\n  copyPixels(scene, width, height) {\n    const context2D = scene.context;\n    if (context2D == null) {\n      console.log('could not acquire 2d context');\n      return;\n    }\n    context2D.clearRect(0, 0, width, height);\n    context2D.drawImage(this.canvas3D, 0, 0, width, height, 0, 0, width, height);\n    scene.canvas.classList.add('show');\n  }\n  /**\n   * Returns an array version of this.scenes where the non-visible ones are\n   * first. This allows eager scenes to be rendered before they are visible,\n   * without needing the multi-canvas render path.\n   */\n  orderedScenes() {\n    const scenes = [];\n    for (const visible of [false, true]) {\n      for (const scene of this.scenes) {\n        if (scene.element.modelIsVisible === visible) {\n          scenes.push(scene);\n        }\n      }\n    }\n    return scenes;\n  }\n  get isPresenting() {\n    return this.arRenderer.isPresenting;\n  }\n  /**\n   * This method takes care of updating the element and renderer state based on\n   * the time that has passed since the last rendered frame.\n   */\n  preRender(scene, t, delta) {\n    const {\n      element,\n      exposure,\n      toneMapping\n    } = scene;\n    element[$tick](t, delta);\n    const exposureIsNumber = typeof exposure === 'number' && !Number.isNaN(exposure);\n    const env = element.environmentImage;\n    const sky = element.skyboxImage;\n    const compensateExposure = toneMapping === NeutralToneMapping && (env === 'neutral' || env === 'legacy' || !env && !sky);\n    this.threeRenderer.toneMappingExposure = (exposureIsNumber ? exposure : 1.0) * (compensateExposure ? COMMERCE_EXPOSURE : 1.0);\n  }\n  render(t, frame) {\n    if (frame != null) {\n      this.arRenderer.onWebXRFrame(t, frame);\n      return;\n    }\n    const delta = t - this.lastTick;\n    this.lastTick = t;\n    if (!this.canRender || this.isPresenting) {\n      return;\n    }\n    this.countVisibleScenes();\n    this.updateRendererSize();\n    if (this.renderedLastFrame) {\n      this.updateRendererScale(delta);\n      this.renderedLastFrame = false;\n    }\n    const {\n      canvas3D\n    } = this;\n    for (const scene of this.orderedScenes()) {\n      const {\n        element\n      } = scene;\n      if (!element.loaded || !element.modelIsVisible && scene.renderCount > 0) {\n        continue;\n      }\n      this.preRender(scene, t, delta);\n      if (!this.shouldRender(scene)) {\n        continue;\n      }\n      if (scene.externalRenderer != null) {\n        const camera = scene.getCamera();\n        camera.updateMatrix();\n        const {\n          matrix,\n          projectionMatrix\n        } = camera;\n        const viewMatrix = matrix.elements.slice();\n        const target = scene.getTarget();\n        viewMatrix[12] += target.x;\n        viewMatrix[13] += target.y;\n        viewMatrix[14] += target.z;\n        scene.externalRenderer.render({\n          viewMatrix: viewMatrix,\n          projectionMatrix: projectionMatrix.elements\n        });\n        continue;\n      }\n      if (!element.modelIsVisible && !this.multipleScenesVisible) {\n        // Here we are pre-rendering on the visible canvas, so we must mark the\n        // visible scene dirty to ensure it overwrites us.\n        for (const visibleScene of this.scenes) {\n          if (visibleScene.element.modelIsVisible) {\n            visibleScene.queueRender();\n          }\n        }\n      }\n      const {\n        width,\n        height\n      } = this.sceneSize(scene);\n      scene.renderShadow(this.threeRenderer);\n      // Need to set the render target in order to prevent\n      // clearing the depth from a different buffer\n      this.threeRenderer.setRenderTarget(null);\n      this.threeRenderer.setViewport(0, Math.ceil(this.height * this.dpr) - height, width, height);\n      if (scene.effectRenderer != null) {\n        scene.effectRenderer.render(delta);\n      } else {\n        this.threeRenderer.autoClear = true; // this might get reset by the effectRenderer\n        this.threeRenderer.toneMapping = scene.toneMapping;\n        this.threeRenderer.render(scene, scene.camera);\n      }\n      if (this.multipleScenesVisible || !scene.element.modelIsVisible && scene.renderCount === 0) {\n        this.copyPixels(scene, width, height);\n      } else if (canvas3D.parentElement !== scene.canvas.parentElement) {\n        scene.canvas.parentElement.appendChild(canvas3D);\n        scene.canvas.classList.remove('show');\n      }\n      scene.hasRendered();\n      ++scene.renderCount;\n      this.renderedLastFrame = true;\n    }\n  }\n  dispose() {\n    if (this.textureUtils != null) {\n      this.textureUtils.dispose();\n    }\n    if (this.threeRenderer != null) {\n      this.threeRenderer.dispose();\n    }\n    this.textureUtils = null;\n    this.threeRenderer = null;\n    const elements = [];\n    for (const scene of this.scenes) {\n      elements.push(scene.element);\n    }\n    this.canvas3D.removeEventListener('webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.removeEventListener('webglcontextrestored', this.onWebGLContextRestored);\n    return elements;\n  }\n}","map":{"version":3,"names":["ACESFilmicToneMapping","EventDispatcher","NeutralToneMapping","Vector2","WebGLRenderer","$updateEnvironment","$canvas","$tick","$updateSize","clamp","isDebugMode","ARRenderer","CachingGLTFLoader","ModelViewerGLTFInstance","TextureUtils","DURATION_DECAY","LOW_FRAME_DURATION_MS","HIGH_FRAME_DURATION_MS","MAX_AVG_CHANGE_MS","SCALE_STEPS","DEFAULT_LAST_STEP","DEFAULT_POWER_PREFERENCE","COMMERCE_EXPOSURE","Renderer","constructor","options","loader","width","height","dpr","scenes","Set","multipleScenesVisible","lastTick","performance","now","renderedLastFrame","scaleStep","lastStep","avgFrameDuration","onWebGLContextLost","event","dispatchEvent","type","sourceEvent","onWebGLContextRestored","_a","textureUtils","dispose","threeRenderer","scene","element","window","devicePixelRatio","canvas3D","document","createElement","id","classList","add","canvas","alpha","antialias","powerPreference","preserveDrawingBuffer","autoClear","setPixelRatio","debug","checkShaderErrors","onShaderError","toneMapping","error","console","warn","arRenderer","canRender","initializeKTX2Loader","addEventListener","updateRendererSize","singleton","_singleton","self","ModelViewerElement","resetSingleton","elements","disconnectedCallback","connectedCallback","scaleFactor","minScale","scale","i","length","registerScene","forceRescale","size","getSize","x","y","setAnimationLoop","time","frame","render","unregisterScene","delete","parentElement","removeChild","displayCanvas","modelIsVisible","countVisibleScenes","visibleScenes","canvas3DScene","externalRenderer","newlyMultiple","disappearing","sceneSize","copyPixels","getBoundingClientRect","Math","max","ceil","setSize","effectRenderer","updateRendererScale","delta","min","shouldRender","rescaleCanvas","style","renderedDpr","reason","CustomEvent","detail","reportedDpr","minimumDpr","pixelWidth","pixelHeight","context2D","context","log","clearRect","drawImage","orderedScenes","visible","push","isPresenting","preRender","t","exposure","exposureIsNumber","Number","isNaN","env","environmentImage","sky","skyboxImage","compensateExposure","toneMappingExposure","onWebXRFrame","loaded","renderCount","camera","getCamera","updateMatrix","matrix","projectionMatrix","viewMatrix","slice","target","getTarget","z","visibleScene","queueRender","renderShadow","setRenderTarget","setViewport","appendChild","remove","hasRendered","removeEventListener"],"sources":["/Users/leandrodisconzi/CascadeProjects/geodome-website/node_modules/@google/model-viewer/src/three-components/Renderer.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ACESFilmicToneMapping, Event, EventDispatcher, NeutralToneMapping, Vector2, WebGLRenderer} from 'three';\n\nimport {$updateEnvironment} from '../features/environment.js';\nimport {ModelViewerGlobalConfig} from '../features/loading.js';\nimport ModelViewerElementBase, {$canvas, $tick, $updateSize} from '../model-viewer-base.js';\nimport {clamp, isDebugMode} from '../utilities.js';\n\nimport {ARRenderer} from './ARRenderer.js';\nimport {CachingGLTFLoader} from './CachingGLTFLoader.js';\nimport {ModelViewerGLTFInstance} from './gltf-instance/ModelViewerGLTFInstance.js';\nimport {ModelScene} from './ModelScene.js';\nimport TextureUtils from './TextureUtils.js';\n\nexport interface RendererOptions {\n  powerPreference: string;\n  debug?: boolean;\n}\n\nexport interface ContextLostEvent extends Event {\n  type: 'contextlost';\n  sourceEvent: WebGLContextEvent;\n}\n\n// Between 0 and 1: larger means the average responds faster and is less smooth.\nconst DURATION_DECAY = 0.2;\nconst LOW_FRAME_DURATION_MS = 40;\nconst HIGH_FRAME_DURATION_MS = 60;\nconst MAX_AVG_CHANGE_MS = 5;\nconst SCALE_STEPS = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25];\nconst DEFAULT_LAST_STEP = 3;\n\nexport const DEFAULT_POWER_PREFERENCE: string = 'high-performance';\nconst COMMERCE_EXPOSURE = 1.3;\n\n/**\n * Registers canvases with Canvas2DRenderingContexts and renders them\n * all in the same WebGLRenderingContext, spitting out textures to apply\n * to the canvases. Creates a fullscreen WebGL canvas that is not added\n * to the DOM, and on each frame, renders each registered canvas on a portion\n * of the WebGL canvas, and applies the texture on the registered canvas.\n *\n * In the future, can use ImageBitmapRenderingContext instead of\n * Canvas2DRenderingContext if supported for cheaper transferring of\n * the texture.\n */\nexport class Renderer extends\n    EventDispatcher<{contextlost: {sourceEvent: WebGLContextEvent}}> {\n  private static _singleton: Renderer;\n\n  static get singleton() {\n    if (!this._singleton) {\n      this._singleton = new Renderer({\n        powerPreference: (((self as any).ModelViewerElement || {}) as\n                          ModelViewerGlobalConfig)\n                             .powerPreference ||\n            DEFAULT_POWER_PREFERENCE,\n        debug: isDebugMode()\n      });\n    }\n    return this._singleton;\n  }\n\n  static resetSingleton() {\n    const elements = this._singleton.dispose();\n    for (const element of elements) {\n      element.disconnectedCallback();\n    }\n\n    this._singleton = new Renderer({\n      powerPreference:\n          (((self as any).ModelViewerElement || {}) as ModelViewerGlobalConfig)\n              .powerPreference ||\n          DEFAULT_POWER_PREFERENCE,\n      debug: isDebugMode()\n    });\n\n    for (const element of elements) {\n      element.connectedCallback();\n    }\n  }\n\n  public threeRenderer!: WebGLRenderer;\n  public canvas3D: HTMLCanvasElement;\n  public textureUtils: TextureUtils|null;\n  public arRenderer: ARRenderer;\n  public loader = new CachingGLTFLoader(ModelViewerGLTFInstance);\n  public width = 0;\n  public height = 0;\n  public dpr = 1;\n\n  private scenes: Set<ModelScene> = new Set();\n  private multipleScenesVisible = false;\n  private lastTick = performance.now();\n  private renderedLastFrame = false;\n  private scaleStep = 0;\n  private lastStep = DEFAULT_LAST_STEP;\n  private avgFrameDuration =\n      (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n\n  get canRender() {\n    return this.threeRenderer != null;\n  }\n\n  get scaleFactor() {\n    return SCALE_STEPS[this.scaleStep];\n  }\n\n  set minScale(scale: number) {\n    let i = 1;\n    while (i < SCALE_STEPS.length) {\n      if (SCALE_STEPS[i] < scale) {\n        break;\n      }\n      ++i;\n    }\n    this.lastStep = i - 1;\n  }\n\n  constructor(options: RendererOptions) {\n    super();\n\n    this.dpr = window.devicePixelRatio;\n\n    this.canvas3D = document.createElement('canvas');\n    this.canvas3D.id = 'webgl-canvas';\n    this.canvas3D.classList.add('show');\n\n    try {\n      this.threeRenderer = new WebGLRenderer({\n        canvas: this.canvas3D,\n        alpha: true,\n        antialias: true,\n        powerPreference: options.powerPreference as WebGLPowerPreference,\n        preserveDrawingBuffer: true,\n      });\n      this.threeRenderer.autoClear = true;\n      this.threeRenderer.setPixelRatio(1);  // handle pixel ratio externally\n\n      this.threeRenderer.debug = {\n        checkShaderErrors: !!options.debug,\n        onShaderError: null\n      };\n\n      // ACESFilmicToneMapping appears to be the most \"saturated\",\n      // and similar to Filament's gltf-viewer.\n      this.threeRenderer.toneMapping = ACESFilmicToneMapping;\n    } catch (error) {\n      console.warn(error);\n    }\n\n    this.arRenderer = new ARRenderer(this);\n    this.textureUtils =\n        this.canRender ? new TextureUtils(this.threeRenderer) : null;\n    CachingGLTFLoader.initializeKTX2Loader(this.threeRenderer);\n\n    this.canvas3D.addEventListener('webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.addEventListener(\n        'webglcontextrestored', this.onWebGLContextRestored);\n\n    this.updateRendererSize();\n  }\n\n  registerScene(scene: ModelScene) {\n    this.scenes.add(scene);\n\n    scene.forceRescale();\n\n    const size = new Vector2();\n    this.threeRenderer.getSize(size);\n    scene.canvas.width = size.x;\n    scene.canvas.height = size.y;\n\n    if (this.canRender && this.scenes.size > 0) {\n      this.threeRenderer.setAnimationLoop(\n          (time: number, frame?: any) => this.render(time, frame));\n    }\n  }\n\n  unregisterScene(scene: ModelScene) {\n    this.scenes.delete(scene);\n\n    if (this.canvas3D.parentElement === scene.canvas.parentElement) {\n      scene.canvas.parentElement!.removeChild(this.canvas3D);\n    }\n\n    if (this.canRender && this.scenes.size === 0) {\n      this.threeRenderer.setAnimationLoop(null);\n    }\n  }\n\n  displayCanvas(scene: ModelScene): HTMLCanvasElement {\n    return scene.element.modelIsVisible && !this.multipleScenesVisible ?\n        this.canvas3D :\n        scene.element[$canvas];\n  }\n\n  /**\n   * The function enables an optimization, where when there is only a single\n   * <model-viewer> element, we can use the renderer's 3D canvas directly for\n   * display. Otherwise we need to use the element's 2D canvas and copy the\n   * renderer's result into it.\n   */\n  private countVisibleScenes() {\n    const {canvas3D} = this;\n    let visibleScenes = 0;\n    let canvas3DScene = null;\n    for (const scene of this.scenes) {\n      const {element} = scene;\n      if (element.modelIsVisible && scene.externalRenderer == null) {\n        ++visibleScenes;\n      }\n      if (canvas3D.parentElement === scene.canvas.parentElement) {\n        canvas3DScene = scene;\n      }\n    }\n    const multipleScenesVisible = visibleScenes > 1;\n\n    if (canvas3DScene != null) {\n      const newlyMultiple =\n          multipleScenesVisible && !this.multipleScenesVisible;\n      const disappearing = !canvas3DScene.element.modelIsVisible;\n      if (newlyMultiple || disappearing) {\n        const {width, height} = this.sceneSize(canvas3DScene);\n        this.copyPixels(canvas3DScene, width, height);\n        canvas3D.parentElement!.removeChild(canvas3D);\n      }\n    }\n    this.multipleScenesVisible = multipleScenesVisible;\n  }\n\n  /**\n   * Updates the renderer's size based on the largest scene and any changes to\n   * device pixel ratio.\n   */\n  private updateRendererSize() {\n    const dpr = window.devicePixelRatio;\n    if (dpr !== this.dpr) {\n      // If the device pixel ratio has changed due to page zoom, elements\n      // specified by % width do not fire a resize event even though their CSS\n      // pixel dimensions change, so we force them to update their size here.\n      for (const scene of this.scenes) {\n        const {element} = scene;\n        element[$updateSize](element.getBoundingClientRect());\n      }\n    }\n\n    // Make the renderer the size of the largest scene\n    let width = 0;\n    let height = 0;\n    for (const scene of this.scenes) {\n      width = Math.max(width, scene.width);\n      height = Math.max(height, scene.height);\n    }\n\n    if (width === this.width && height === this.height && dpr === this.dpr) {\n      return;\n    }\n    this.width = width;\n    this.height = height;\n    this.dpr = dpr;\n    width = Math.ceil(width * dpr);\n    height = Math.ceil(height * dpr);\n\n    if (this.canRender) {\n      this.threeRenderer.setSize(width, height, false);\n    }\n\n    // Each scene's canvas must match the renderer size. In general they can be\n    // larger than the element that contains them, but the overflow is hidden\n    // and only the portion that is shown is copied over.\n    for (const scene of this.scenes) {\n      const {canvas} = scene;\n      canvas.width = width;\n      canvas.height = height;\n      scene.forceRescale();\n      scene.effectRenderer?.setSize(width, height);\n    }\n  }\n\n  private updateRendererScale(delta: number) {\n    const scaleStep = this.scaleStep;\n\n    this.avgFrameDuration += clamp(\n        DURATION_DECAY * (delta - this.avgFrameDuration),\n        -MAX_AVG_CHANGE_MS,\n        MAX_AVG_CHANGE_MS);\n\n    if (this.avgFrameDuration > HIGH_FRAME_DURATION_MS) {\n      ++this.scaleStep;\n    } else if (\n        this.avgFrameDuration < LOW_FRAME_DURATION_MS && this.scaleStep > 0) {\n      --this.scaleStep;\n    }\n    this.scaleStep = Math.min(this.scaleStep, this.lastStep);\n\n    if (scaleStep !== this.scaleStep) {\n      this.avgFrameDuration =\n          (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n    }\n  }\n\n  private shouldRender(scene: ModelScene): boolean {\n    if (!scene.shouldRender()) {\n      // The first frame we stop rendering the scene (because it stops moving),\n      // trigger one extra render at full scale.\n      if (scene.scaleStep != 0) {\n        scene.scaleStep = 0;\n        this.rescaleCanvas(scene);\n      } else {\n        return false;\n      }\n    } else if (scene.scaleStep != this.scaleStep) {\n      // Update render scale\n      scene.scaleStep = this.scaleStep;\n      this.rescaleCanvas(scene);\n    }\n    return true;\n  }\n\n  private rescaleCanvas(scene: ModelScene) {\n    const scale = SCALE_STEPS[scene.scaleStep];\n    const width = Math.ceil(this.width / scale);\n    const height = Math.ceil(this.height / scale);\n\n    const {style} = scene.canvas;\n    style.width = `${width}px`;\n    style.height = `${height}px`;\n    this.canvas3D.style.width = `${width}px`;\n    this.canvas3D.style.height = `${height}px`;\n\n    const renderedDpr = this.dpr * scale;\n    const reason = scale < 1                 ? 'GPU throttling' :\n        this.dpr !== window.devicePixelRatio ? 'No meta viewport tag' :\n                                               '';\n    scene.element.dispatchEvent(new CustomEvent('render-scale', {\n      detail: {\n        reportedDpr: window.devicePixelRatio,\n        renderedDpr: renderedDpr,\n        minimumDpr: this.dpr * SCALE_STEPS[this.lastStep],\n        pixelWidth: Math.ceil(scene.width * renderedDpr),\n        pixelHeight: Math.ceil(scene.height * renderedDpr),\n        reason: reason\n      }\n    }));\n  }\n\n  private sceneSize(scene: ModelScene) {\n    const {dpr} = this;\n    const scaleFactor = SCALE_STEPS[scene.scaleStep];\n    // We avoid using the Three.js PixelRatio and handle it ourselves here so\n    // that we can do proper rounding and avoid white boundary pixels.\n    const width = Math.min(\n        Math.ceil(scene.width * scaleFactor * dpr), this.canvas3D.width);\n    const height = Math.min(\n        Math.ceil(scene.height * scaleFactor * dpr), this.canvas3D.height);\n    return {width, height};\n  }\n\n  private copyPixels(scene: ModelScene, width: number, height: number) {\n    const context2D = scene.context;\n    if (context2D == null) {\n      console.log('could not acquire 2d context');\n      return;\n    }\n    context2D.clearRect(0, 0, width, height);\n    context2D.drawImage(\n        this.canvas3D, 0, 0, width, height, 0, 0, width, height);\n    scene.canvas.classList.add('show');\n  }\n\n  /**\n   * Returns an array version of this.scenes where the non-visible ones are\n   * first. This allows eager scenes to be rendered before they are visible,\n   * without needing the multi-canvas render path.\n   */\n  private orderedScenes(): Array<ModelScene> {\n    const scenes = [];\n    for (const visible of [false, true]) {\n      for (const scene of this.scenes) {\n        if (scene.element.modelIsVisible === visible) {\n          scenes.push(scene);\n        }\n      }\n    }\n    return scenes;\n  }\n\n  get isPresenting(): boolean {\n    return this.arRenderer.isPresenting;\n  }\n\n  /**\n   * This method takes care of updating the element and renderer state based on\n   * the time that has passed since the last rendered frame.\n   */\n  preRender(scene: ModelScene, t: number, delta: number) {\n    const {element, exposure, toneMapping} = scene;\n\n    element[$tick](t, delta);\n\n    const exposureIsNumber =\n        typeof exposure === 'number' && !Number.isNaN(exposure);\n    const env = element.environmentImage;\n    const sky = element.skyboxImage;\n    const compensateExposure = toneMapping === NeutralToneMapping &&\n        (env === 'neutral' || env === 'legacy' || (!env && !sky));\n    this.threeRenderer.toneMappingExposure =\n        (exposureIsNumber ? exposure : 1.0) *\n        (compensateExposure ? COMMERCE_EXPOSURE : 1.0);\n  }\n\n  render(t: number, frame?: XRFrame) {\n    if (frame != null) {\n      this.arRenderer.onWebXRFrame(t, frame);\n      return;\n    }\n\n    const delta = t - this.lastTick;\n    this.lastTick = t;\n\n    if (!this.canRender || this.isPresenting) {\n      return;\n    }\n\n    this.countVisibleScenes();\n    this.updateRendererSize();\n    if (this.renderedLastFrame) {\n      this.updateRendererScale(delta);\n      this.renderedLastFrame = false;\n    }\n\n    const {canvas3D} = this;\n\n    for (const scene of this.orderedScenes()) {\n      const {element} = scene;\n      if (!element.loaded ||\n          (!element.modelIsVisible && scene.renderCount > 0)) {\n        continue;\n      }\n\n      this.preRender(scene, t, delta);\n\n      if (!this.shouldRender(scene)) {\n        continue;\n      }\n\n      if (scene.externalRenderer != null) {\n        const camera = scene.getCamera();\n        camera.updateMatrix();\n        const {matrix, projectionMatrix} = camera;\n        const viewMatrix = matrix.elements.slice();\n        const target = scene.getTarget();\n        viewMatrix[12] += target.x;\n        viewMatrix[13] += target.y;\n        viewMatrix[14] += target.z;\n\n        scene.externalRenderer.render({\n          viewMatrix: viewMatrix,\n          projectionMatrix: projectionMatrix.elements\n        });\n        continue;\n      }\n\n      if (!element.modelIsVisible && !this.multipleScenesVisible) {\n        // Here we are pre-rendering on the visible canvas, so we must mark the\n        // visible scene dirty to ensure it overwrites us.\n        for (const visibleScene of this.scenes) {\n          if (visibleScene.element.modelIsVisible) {\n            visibleScene.queueRender();\n          }\n        }\n      }\n\n      const {width, height} = this.sceneSize(scene);\n\n      scene.renderShadow(this.threeRenderer);\n\n      // Need to set the render target in order to prevent\n      // clearing the depth from a different buffer\n      this.threeRenderer.setRenderTarget(null);\n      this.threeRenderer.setViewport(\n          0, Math.ceil(this.height * this.dpr) - height, width, height);\n      if (scene.effectRenderer != null) {\n        scene.effectRenderer.render(delta);\n      } else {\n        this.threeRenderer.autoClear =\n            true;  // this might get reset by the effectRenderer\n        this.threeRenderer.toneMapping = scene.toneMapping;\n        this.threeRenderer.render(scene, scene.camera);\n      }\n      if (this.multipleScenesVisible ||\n          (!scene.element.modelIsVisible && scene.renderCount === 0)) {\n        this.copyPixels(scene, width, height);\n      } else if (canvas3D.parentElement !== scene.canvas.parentElement) {\n        scene.canvas.parentElement!.appendChild(canvas3D);\n        scene.canvas.classList.remove('show');\n      }\n\n      scene.hasRendered();\n      ++scene.renderCount;\n      this.renderedLastFrame = true;\n    }\n  }\n\n  dispose(): Array<ModelViewerElementBase> {\n    if (this.textureUtils != null) {\n      this.textureUtils.dispose();\n    }\n\n    if (this.threeRenderer != null) {\n      this.threeRenderer.dispose();\n    }\n\n    this.textureUtils = null;\n    (this as any).threeRenderer = null;\n\n    const elements = [];\n    for (const scene of this.scenes) {\n      elements.push(scene.element);\n    }\n\n    this.canvas3D.removeEventListener(\n        'webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.removeEventListener(\n        'webglcontextrestored', this.onWebGLContextRestored);\n\n    return elements;\n  }\n\n  onWebGLContextLost = (event: Event) => {\n    this.dispatchEvent(\n        {type: 'contextlost', sourceEvent: event} as ContextLostEvent);\n  };\n\n  onWebGLContextRestored = () => {\n    this.textureUtils?.dispose();\n    this.textureUtils = new TextureUtils(this.threeRenderer);\n    for (const scene of this.scenes) {\n      (scene.element as any)[$updateEnvironment]();\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}