{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { property } from 'lit/decorators.js';\nimport { CanvasTexture, RepeatWrapping, SRGBColorSpace, VideoTexture } from 'three';\nimport { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter.js';\nimport { $needsRender, $onModelLoad, $progressTracker, $renderer, $scene } from '../model-viewer-base.js';\nimport GLTFExporterMaterialsVariantsExtension from '../three-components/gltf-instance/VariantMaterialExporterPlugin.js';\nimport { $availableVariants, $materialFromPoint, $prepareVariantsForExport, $switchVariant, Model } from './scene-graph/model.js';\nimport { Texture as ModelViewerTexture } from './scene-graph/texture.js';\nexport const $currentGLTF = Symbol('currentGLTF');\nexport const $originalGltfJson = Symbol('originalGltfJson');\nexport const $model = Symbol('model');\nconst $getOnUpdateMethod = Symbol('getOnUpdateMethod');\nconst $buildTexture = Symbol('buildTexture');\n/**\n * SceneGraphMixin manages exposes a model API in order to support operations on\n * the <model-viewer> scene graph.\n */\nexport const SceneGraphMixin = ModelViewerElement => {\n  var _a, _b, _c;\n  class SceneGraphModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this[_a] = undefined;\n      this[_b] = null;\n      this[_c] = null;\n      this.variantName = null;\n      this.orientation = '0 0 0';\n      this.scale = '1 1 1';\n    }\n    // Scene-graph API:\n    /** @export */\n    get model() {\n      return this[$model];\n    }\n    get availableVariants() {\n      return this.model ? this.model[$availableVariants]() : [];\n    }\n    /**\n     * Returns a deep copy of the gltf JSON as loaded. It will not reflect\n     * changes to the scene-graph, nor will editing it have any effect.\n     */\n    get originalGltfJson() {\n      return this[$originalGltfJson];\n    }\n    [(_a = $model, _b = $currentGLTF, _c = $originalGltfJson, $getOnUpdateMethod)]() {\n      return () => {\n        this[$needsRender]();\n      };\n    }\n    [$buildTexture](texture) {\n      // Applies glTF default settings.\n      texture.colorSpace = SRGBColorSpace;\n      texture.wrapS = RepeatWrapping;\n      texture.wrapT = RepeatWrapping;\n      return new ModelViewerTexture(this[$getOnUpdateMethod](), texture);\n    }\n    async createTexture(uri, type = 'image/png') {\n      const {\n        textureUtils\n      } = this[$renderer];\n      const texture = await textureUtils.loadImage(uri);\n      texture.userData.mimeType = type;\n      return this[$buildTexture](texture);\n    }\n    async createLottieTexture(uri, quality = 1) {\n      const {\n        textureUtils\n      } = this[$renderer];\n      const texture = await textureUtils.loadLottie(uri, quality);\n      return this[$buildTexture](texture);\n    }\n    createVideoTexture(uri) {\n      const video = document.createElement('video');\n      video.crossOrigin = this.withCredentials ? 'use-credentials' : 'anonymous';\n      video.src = uri;\n      video.muted = true;\n      video.playsInline = true;\n      video.loop = true;\n      video.play();\n      const texture = new VideoTexture(video);\n      return this[$buildTexture](texture);\n    }\n    createCanvasTexture() {\n      const canvas = document.createElement('canvas');\n      const texture = new CanvasTexture(canvas);\n      return this[$buildTexture](texture);\n    }\n    async updated(changedProperties) {\n      super.updated(changedProperties);\n      if (changedProperties.has('variantName')) {\n        const updateVariantProgress = this[$progressTracker].beginActivity('variant-update');\n        updateVariantProgress(0.1);\n        const model = this[$model];\n        const {\n          variantName\n        } = this;\n        if (model != null) {\n          await model[$switchVariant](variantName);\n          this[$needsRender]();\n          this.dispatchEvent(new CustomEvent('variant-applied'));\n        }\n        updateVariantProgress(1.0);\n      }\n      if (changedProperties.has('orientation') || changedProperties.has('scale')) {\n        if (!this.loaded) {\n          return;\n        }\n        const scene = this[$scene];\n        scene.applyTransform();\n        scene.updateBoundingBox();\n        scene.updateShadow();\n        this[$renderer].arRenderer.onUpdateScene();\n        this[$needsRender]();\n      }\n    }\n    [$onModelLoad]() {\n      super[$onModelLoad]();\n      const {\n        currentGLTF\n      } = this[$scene];\n      if (currentGLTF != null) {\n        const {\n          correlatedSceneGraph\n        } = currentGLTF;\n        if (correlatedSceneGraph != null && currentGLTF !== this[$currentGLTF]) {\n          this[$model] = new Model(correlatedSceneGraph, this[$getOnUpdateMethod]());\n          this[$originalGltfJson] = JSON.parse(JSON.stringify(correlatedSceneGraph.gltf));\n        }\n        // KHR_materials_variants extension spec:\n        // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants\n        if ('variants' in currentGLTF.userData) {\n          this.requestUpdate('variantName');\n        }\n      }\n      this[$currentGLTF] = currentGLTF;\n    }\n    /** @export */\n    async exportScene(options) {\n      const scene = this[$scene];\n      return new Promise(async (resolve, reject) => {\n        // Defaults\n        const opts = {\n          binary: true,\n          onlyVisible: true,\n          maxTextureSize: Infinity,\n          includeCustomExtensions: false,\n          forceIndices: false\n        };\n        Object.assign(opts, options);\n        // Not configurable\n        opts.animations = scene.animations;\n        opts.truncateDrawRange = true;\n        const shadow = scene.shadow;\n        let visible = false;\n        // Remove shadow from export\n        if (shadow != null) {\n          visible = shadow.visible;\n          shadow.visible = false;\n        }\n        await this[$model][$prepareVariantsForExport]();\n        const exporter = new GLTFExporter().register(writer => new GLTFExporterMaterialsVariantsExtension(writer));\n        exporter.parse(scene.model, gltf => {\n          return resolve(new Blob([opts.binary ? gltf : JSON.stringify(gltf)], {\n            type: opts.binary ? 'application/octet-stream' : 'application/json'\n          }));\n        }, () => {\n          return reject('glTF export failed');\n        }, opts);\n        if (shadow != null) {\n          shadow.visible = visible;\n        }\n      });\n    }\n    materialFromPoint(pixelX, pixelY) {\n      const model = this[$model];\n      if (model == null) {\n        return null;\n      }\n      const scene = this[$scene];\n      const ndcCoords = scene.getNDC(pixelX, pixelY);\n      const hit = scene.hitFromPoint(ndcCoords);\n      if (hit == null || hit.face == null) {\n        return null;\n      }\n      return model[$materialFromPoint](hit);\n    }\n  }\n  __decorate([property({\n    type: String,\n    attribute: 'variant-name'\n  })], SceneGraphModelViewerElement.prototype, \"variantName\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'orientation'\n  })], SceneGraphModelViewerElement.prototype, \"orientation\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'scale'\n  })], SceneGraphModelViewerElement.prototype, \"scale\", void 0);\n  return SceneGraphModelViewerElement;\n};","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","property","CanvasTexture","RepeatWrapping","SRGBColorSpace","VideoTexture","GLTFExporter","$needsRender","$onModelLoad","$progressTracker","$renderer","$scene","GLTFExporterMaterialsVariantsExtension","$availableVariants","$materialFromPoint","$prepareVariantsForExport","$switchVariant","Model","Texture","ModelViewerTexture","$currentGLTF","Symbol","$originalGltfJson","$model","$getOnUpdateMethod","$buildTexture","SceneGraphMixin","ModelViewerElement","_a","_b","_c","SceneGraphModelViewerElement","constructor","undefined","variantName","orientation","scale","model","availableVariants","originalGltfJson","texture","colorSpace","wrapS","wrapT","createTexture","uri","type","textureUtils","loadImage","userData","mimeType","createLottieTexture","quality","loadLottie","createVideoTexture","video","document","createElement","crossOrigin","withCredentials","src","muted","playsInline","loop","play","createCanvasTexture","canvas","updated","changedProperties","has","updateVariantProgress","beginActivity","dispatchEvent","CustomEvent","loaded","scene","applyTransform","updateBoundingBox","updateShadow","arRenderer","onUpdateScene","currentGLTF","correlatedSceneGraph","JSON","parse","stringify","gltf","requestUpdate","exportScene","options","Promise","resolve","reject","opts","binary","onlyVisible","maxTextureSize","Infinity","includeCustomExtensions","forceIndices","assign","animations","truncateDrawRange","shadow","visible","exporter","register","writer","Blob","materialFromPoint","pixelX","pixelY","ndcCoords","getNDC","hit","hitFromPoint","face","String","attribute","prototype"],"sources":["/Users/leandrodisconzi/CascadeProjects/geodome-website/node_modules/@google/model-viewer/lib/features/scene-graph.js"],"sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { property } from 'lit/decorators.js';\nimport { CanvasTexture, RepeatWrapping, SRGBColorSpace, VideoTexture } from 'three';\nimport { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter.js';\nimport { $needsRender, $onModelLoad, $progressTracker, $renderer, $scene } from '../model-viewer-base.js';\nimport GLTFExporterMaterialsVariantsExtension from '../three-components/gltf-instance/VariantMaterialExporterPlugin.js';\nimport { $availableVariants, $materialFromPoint, $prepareVariantsForExport, $switchVariant, Model } from './scene-graph/model.js';\nimport { Texture as ModelViewerTexture } from './scene-graph/texture.js';\nexport const $currentGLTF = Symbol('currentGLTF');\nexport const $originalGltfJson = Symbol('originalGltfJson');\nexport const $model = Symbol('model');\nconst $getOnUpdateMethod = Symbol('getOnUpdateMethod');\nconst $buildTexture = Symbol('buildTexture');\n/**\n * SceneGraphMixin manages exposes a model API in order to support operations on\n * the <model-viewer> scene graph.\n */\nexport const SceneGraphMixin = (ModelViewerElement) => {\n    var _a, _b, _c;\n    class SceneGraphModelViewerElement extends ModelViewerElement {\n        constructor() {\n            super(...arguments);\n            this[_a] = undefined;\n            this[_b] = null;\n            this[_c] = null;\n            this.variantName = null;\n            this.orientation = '0 0 0';\n            this.scale = '1 1 1';\n        }\n        // Scene-graph API:\n        /** @export */\n        get model() {\n            return this[$model];\n        }\n        get availableVariants() {\n            return this.model ? this.model[$availableVariants]() : [];\n        }\n        /**\n         * Returns a deep copy of the gltf JSON as loaded. It will not reflect\n         * changes to the scene-graph, nor will editing it have any effect.\n         */\n        get originalGltfJson() {\n            return this[$originalGltfJson];\n        }\n        [(_a = $model, _b = $currentGLTF, _c = $originalGltfJson, $getOnUpdateMethod)]() {\n            return () => {\n                this[$needsRender]();\n            };\n        }\n        [$buildTexture](texture) {\n            // Applies glTF default settings.\n            texture.colorSpace = SRGBColorSpace;\n            texture.wrapS = RepeatWrapping;\n            texture.wrapT = RepeatWrapping;\n            return new ModelViewerTexture(this[$getOnUpdateMethod](), texture);\n        }\n        async createTexture(uri, type = 'image/png') {\n            const { textureUtils } = this[$renderer];\n            const texture = await textureUtils.loadImage(uri);\n            texture.userData.mimeType = type;\n            return this[$buildTexture](texture);\n        }\n        async createLottieTexture(uri, quality = 1) {\n            const { textureUtils } = this[$renderer];\n            const texture = await textureUtils.loadLottie(uri, quality);\n            return this[$buildTexture](texture);\n        }\n        createVideoTexture(uri) {\n            const video = document.createElement('video');\n            video.crossOrigin = this.withCredentials ? 'use-credentials' : 'anonymous';\n            video.src = uri;\n            video.muted = true;\n            video.playsInline = true;\n            video.loop = true;\n            video.play();\n            const texture = new VideoTexture(video);\n            return this[$buildTexture](texture);\n        }\n        createCanvasTexture() {\n            const canvas = document.createElement('canvas');\n            const texture = new CanvasTexture(canvas);\n            return this[$buildTexture](texture);\n        }\n        async updated(changedProperties) {\n            super.updated(changedProperties);\n            if (changedProperties.has('variantName')) {\n                const updateVariantProgress = this[$progressTracker].beginActivity('variant-update');\n                updateVariantProgress(0.1);\n                const model = this[$model];\n                const { variantName } = this;\n                if (model != null) {\n                    await model[$switchVariant](variantName);\n                    this[$needsRender]();\n                    this.dispatchEvent(new CustomEvent('variant-applied'));\n                }\n                updateVariantProgress(1.0);\n            }\n            if (changedProperties.has('orientation') ||\n                changedProperties.has('scale')) {\n                if (!this.loaded) {\n                    return;\n                }\n                const scene = this[$scene];\n                scene.applyTransform();\n                scene.updateBoundingBox();\n                scene.updateShadow();\n                this[$renderer].arRenderer.onUpdateScene();\n                this[$needsRender]();\n            }\n        }\n        [$onModelLoad]() {\n            super[$onModelLoad]();\n            const { currentGLTF } = this[$scene];\n            if (currentGLTF != null) {\n                const { correlatedSceneGraph } = currentGLTF;\n                if (correlatedSceneGraph != null &&\n                    currentGLTF !== this[$currentGLTF]) {\n                    this[$model] =\n                        new Model(correlatedSceneGraph, this[$getOnUpdateMethod]());\n                    this[$originalGltfJson] =\n                        JSON.parse(JSON.stringify(correlatedSceneGraph.gltf));\n                }\n                // KHR_materials_variants extension spec:\n                // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants\n                if ('variants' in currentGLTF.userData) {\n                    this.requestUpdate('variantName');\n                }\n            }\n            this[$currentGLTF] = currentGLTF;\n        }\n        /** @export */\n        async exportScene(options) {\n            const scene = this[$scene];\n            return new Promise(async (resolve, reject) => {\n                // Defaults\n                const opts = {\n                    binary: true,\n                    onlyVisible: true,\n                    maxTextureSize: Infinity,\n                    includeCustomExtensions: false,\n                    forceIndices: false\n                };\n                Object.assign(opts, options);\n                // Not configurable\n                opts.animations = scene.animations;\n                opts.truncateDrawRange = true;\n                const shadow = scene.shadow;\n                let visible = false;\n                // Remove shadow from export\n                if (shadow != null) {\n                    visible = shadow.visible;\n                    shadow.visible = false;\n                }\n                await this[$model][$prepareVariantsForExport]();\n                const exporter = new GLTFExporter()\n                    .register((writer) => new GLTFExporterMaterialsVariantsExtension(writer));\n                exporter.parse(scene.model, (gltf) => {\n                    return resolve(new Blob([opts.binary ? gltf : JSON.stringify(gltf)], {\n                        type: opts.binary ? 'application/octet-stream' :\n                            'application/json'\n                    }));\n                }, () => {\n                    return reject('glTF export failed');\n                }, opts);\n                if (shadow != null) {\n                    shadow.visible = visible;\n                }\n            });\n        }\n        materialFromPoint(pixelX, pixelY) {\n            const model = this[$model];\n            if (model == null) {\n                return null;\n            }\n            const scene = this[$scene];\n            const ndcCoords = scene.getNDC(pixelX, pixelY);\n            const hit = scene.hitFromPoint(ndcCoords);\n            if (hit == null || hit.face == null) {\n                return null;\n            }\n            return model[$materialFromPoint](hit);\n        }\n    }\n    __decorate([\n        property({ type: String, attribute: 'variant-name' })\n    ], SceneGraphModelViewerElement.prototype, \"variantName\", void 0);\n    __decorate([\n        property({ type: String, attribute: 'orientation' })\n    ], SceneGraphModelViewerElement.prototype, \"orientation\", void 0);\n    __decorate([\n        property({ type: String, attribute: 'scale' })\n    ], SceneGraphModelViewerElement.prototype, \"scale\", void 0);\n    return SceneGraphModelViewerElement;\n};\n//# sourceMappingURL=scene-graph.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}