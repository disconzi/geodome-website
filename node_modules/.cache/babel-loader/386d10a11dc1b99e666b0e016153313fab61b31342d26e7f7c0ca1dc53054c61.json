{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ACESFilmicToneMapping, EventDispatcher, NeutralToneMapping, Vector2, WebGLRenderer } from 'three';\nimport { $updateEnvironment } from '../features/environment.js';\nimport { $canvas, $tick, $updateSize } from '../model-viewer-base.js';\nimport { clamp, isDebugMode, resolveDpr } from '../utilities.js';\nimport { ARRenderer } from './ARRenderer.js';\nimport { CachingGLTFLoader } from './CachingGLTFLoader.js';\nimport { ModelViewerGLTFInstance } from './gltf-instance/ModelViewerGLTFInstance.js';\nimport TextureUtils from './TextureUtils.js';\n// Between 0 and 1: larger means the average responds faster and is less smooth.\nconst DURATION_DECAY = 0.2;\nconst LOW_FRAME_DURATION_MS = 40;\nconst HIGH_FRAME_DURATION_MS = 60;\nconst MAX_AVG_CHANGE_MS = 5;\nconst SCALE_STEPS = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25];\nconst DEFAULT_LAST_STEP = 3;\nexport const DEFAULT_POWER_PREFERENCE = 'high-performance';\nconst COMMERCE_EXPOSURE = 1.3;\n/**\n * Registers canvases with Canvas2DRenderingContexts and renders them\n * all in the same WebGLRenderingContext, spitting out textures to apply\n * to the canvases. Creates a fullscreen WebGL canvas that is not added\n * to the DOM, and on each frame, renders each registered canvas on a portion\n * of the WebGL canvas, and applies the texture on the registered canvas.\n *\n * In the future, can use ImageBitmapRenderingContext instead of\n * Canvas2DRenderingContext if supported for cheaper transferring of\n * the texture.\n */\nexport class Renderer extends EventDispatcher {\n  constructor(options) {\n    super();\n    this.loader = new CachingGLTFLoader(ModelViewerGLTFInstance);\n    this.width = 0;\n    this.height = 0;\n    this.dpr = 1;\n    this.scenes = new Set();\n    this.multipleScenesVisible = false;\n    this.lastTick = performance.now();\n    this.renderedLastFrame = false;\n    this.scaleStep = 0;\n    this.lastStep = DEFAULT_LAST_STEP;\n    this.avgFrameDuration = (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n    this.onWebGLContextLost = event => {\n      this.dispatchEvent({\n        type: 'contextlost',\n        sourceEvent: event\n      });\n    };\n    this.onWebGLContextRestored = () => {\n      var _a;\n      (_a = this.textureUtils) === null || _a === void 0 ? void 0 : _a.dispose();\n      this.textureUtils = new TextureUtils(this.threeRenderer);\n      for (const scene of this.scenes) {\n        scene.element[$updateEnvironment]();\n      }\n    };\n    this.dpr = resolveDpr();\n    this.canvas3D = document.createElement('canvas');\n    this.canvas3D.id = 'webgl-canvas';\n    this.canvas3D.classList.add('show');\n    try {\n      this.threeRenderer = new WebGLRenderer({\n        canvas: this.canvas3D,\n        alpha: true,\n        antialias: true,\n        powerPreference: options.powerPreference,\n        preserveDrawingBuffer: true\n      });\n      this.threeRenderer.autoClear = true;\n      this.threeRenderer.setPixelRatio(1); // handle pixel ratio externally\n      this.threeRenderer.debug = {\n        checkShaderErrors: !!options.debug,\n        onShaderError: null\n      };\n      // ACESFilmicToneMapping appears to be the most \"saturated\",\n      // and similar to Filament's gltf-viewer.\n      this.threeRenderer.toneMapping = ACESFilmicToneMapping;\n    } catch (error) {\n      console.warn(error);\n    }\n    this.arRenderer = new ARRenderer(this);\n    this.textureUtils = this.canRender ? new TextureUtils(this.threeRenderer) : null;\n    CachingGLTFLoader.initializeKTX2Loader(this.threeRenderer);\n    this.canvas3D.addEventListener('webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.addEventListener('webglcontextrestored', this.onWebGLContextRestored);\n    this.updateRendererSize();\n  }\n  static get singleton() {\n    if (!this._singleton) {\n      this._singleton = new Renderer({\n        powerPreference: (self.ModelViewerElement || {}).powerPreference || DEFAULT_POWER_PREFERENCE,\n        debug: isDebugMode()\n      });\n    }\n    return this._singleton;\n  }\n  static resetSingleton() {\n    const elements = this._singleton.dispose();\n    for (const element of elements) {\n      element.disconnectedCallback();\n    }\n    this._singleton = new Renderer({\n      powerPreference: (self.ModelViewerElement || {}).powerPreference || DEFAULT_POWER_PREFERENCE,\n      debug: isDebugMode()\n    });\n    for (const element of elements) {\n      element.connectedCallback();\n    }\n  }\n  get canRender() {\n    return this.threeRenderer != null;\n  }\n  get scaleFactor() {\n    return SCALE_STEPS[this.scaleStep];\n  }\n  set minScale(scale) {\n    let i = 1;\n    while (i < SCALE_STEPS.length) {\n      if (SCALE_STEPS[i] < scale) {\n        break;\n      }\n      ++i;\n    }\n    this.lastStep = i - 1;\n  }\n  registerScene(scene) {\n    this.scenes.add(scene);\n    scene.forceRescale();\n    const size = new Vector2();\n    this.threeRenderer.getSize(size);\n    scene.canvas.width = size.x;\n    scene.canvas.height = size.y;\n    if (this.canRender && this.scenes.size > 0) {\n      this.threeRenderer.setAnimationLoop((time, frame) => this.render(time, frame));\n    }\n  }\n  unregisterScene(scene) {\n    this.scenes.delete(scene);\n    if (this.canvas3D.parentElement === scene.canvas.parentElement) {\n      scene.canvas.parentElement.removeChild(this.canvas3D);\n    }\n    if (this.canRender && this.scenes.size === 0) {\n      this.threeRenderer.setAnimationLoop(null);\n    }\n  }\n  displayCanvas(scene) {\n    return scene.element.modelIsVisible && !this.multipleScenesVisible ? this.canvas3D : scene.element[$canvas];\n  }\n  /**\n   * The function enables an optimization, where when there is only a single\n   * <model-viewer> element, we can use the renderer's 3D canvas directly for\n   * display. Otherwise we need to use the element's 2D canvas and copy the\n   * renderer's result into it.\n   */\n  countVisibleScenes() {\n    const {\n      canvas3D\n    } = this;\n    let visibleScenes = 0;\n    let canvas3DScene = null;\n    for (const scene of this.scenes) {\n      const {\n        element\n      } = scene;\n      if (element.modelIsVisible && scene.externalRenderer == null) {\n        ++visibleScenes;\n      }\n      if (canvas3D.parentElement === scene.canvas.parentElement) {\n        canvas3DScene = scene;\n      }\n    }\n    const multipleScenesVisible = visibleScenes > 1;\n    if (canvas3DScene != null) {\n      const newlyMultiple = multipleScenesVisible && !this.multipleScenesVisible;\n      const disappearing = !canvas3DScene.element.modelIsVisible;\n      if (newlyMultiple || disappearing) {\n        const {\n          width,\n          height\n        } = this.sceneSize(canvas3DScene);\n        this.copyPixels(canvas3DScene, width, height);\n        canvas3D.parentElement.removeChild(canvas3D);\n      }\n    }\n    this.multipleScenesVisible = multipleScenesVisible;\n  }\n  /**\n   * Updates the renderer's size based on the largest scene and any changes to\n   * device pixel ratio.\n   */\n  updateRendererSize() {\n    var _a;\n    const dpr = resolveDpr();\n    if (dpr !== this.dpr) {\n      // If the device pixel ratio has changed due to page zoom, elements\n      // specified by % width do not fire a resize event even though their CSS\n      // pixel dimensions change, so we force them to update their size here.\n      for (const scene of this.scenes) {\n        const {\n          element\n        } = scene;\n        element[$updateSize](element.getBoundingClientRect());\n      }\n    }\n    // Make the renderer the size of the largest scene\n    let width = 0;\n    let height = 0;\n    for (const scene of this.scenes) {\n      width = Math.max(width, scene.width);\n      height = Math.max(height, scene.height);\n    }\n    if (width === this.width && height === this.height && dpr === this.dpr) {\n      return;\n    }\n    this.width = width;\n    this.height = height;\n    this.dpr = dpr;\n    width = Math.ceil(width * dpr);\n    height = Math.ceil(height * dpr);\n    if (this.canRender) {\n      this.threeRenderer.setSize(width, height, false);\n    }\n    // Each scene's canvas must match the renderer size. In general they can be\n    // larger than the element that contains them, but the overflow is hidden\n    // and only the portion that is shown is copied over.\n    for (const scene of this.scenes) {\n      const {\n        canvas\n      } = scene;\n      canvas.width = width;\n      canvas.height = height;\n      scene.forceRescale();\n      (_a = scene.effectRenderer) === null || _a === void 0 ? void 0 : _a.setSize(width, height);\n    }\n  }\n  updateRendererScale(delta) {\n    const scaleStep = this.scaleStep;\n    this.avgFrameDuration += clamp(DURATION_DECAY * (delta - this.avgFrameDuration), -MAX_AVG_CHANGE_MS, MAX_AVG_CHANGE_MS);\n    if (this.avgFrameDuration > HIGH_FRAME_DURATION_MS) {\n      ++this.scaleStep;\n    } else if (this.avgFrameDuration < LOW_FRAME_DURATION_MS && this.scaleStep > 0) {\n      --this.scaleStep;\n    }\n    this.scaleStep = Math.min(this.scaleStep, this.lastStep);\n    if (scaleStep !== this.scaleStep) {\n      this.avgFrameDuration = (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n    }\n  }\n  shouldRender(scene) {\n    if (!scene.shouldRender()) {\n      // The first frame we stop rendering the scene (because it stops moving),\n      // trigger one extra render at full scale.\n      if (scene.scaleStep != 0) {\n        scene.scaleStep = 0;\n        this.rescaleCanvas(scene);\n      } else {\n        return false;\n      }\n    } else if (scene.scaleStep != this.scaleStep) {\n      // Update render scale\n      scene.scaleStep = this.scaleStep;\n      this.rescaleCanvas(scene);\n    }\n    return true;\n  }\n  rescaleCanvas(scene) {\n    const scale = SCALE_STEPS[scene.scaleStep];\n    const width = Math.ceil(this.width / scale);\n    const height = Math.ceil(this.height / scale);\n    const {\n      style\n    } = scene.canvas;\n    style.width = `${width}px`;\n    style.height = `${height}px`;\n    this.canvas3D.style.width = `${width}px`;\n    this.canvas3D.style.height = `${height}px`;\n    const renderedDpr = this.dpr * scale;\n    const reason = scale < 1 ? 'GPU throttling' : this.dpr !== window.devicePixelRatio ? 'No meta viewport tag' : '';\n    scene.element.dispatchEvent(new CustomEvent('render-scale', {\n      detail: {\n        reportedDpr: window.devicePixelRatio,\n        renderedDpr: renderedDpr,\n        minimumDpr: this.dpr * SCALE_STEPS[this.lastStep],\n        pixelWidth: Math.ceil(scene.width * renderedDpr),\n        pixelHeight: Math.ceil(scene.height * renderedDpr),\n        reason: reason\n      }\n    }));\n  }\n  sceneSize(scene) {\n    const {\n      dpr\n    } = this;\n    const scaleFactor = SCALE_STEPS[scene.scaleStep];\n    // We avoid using the Three.js PixelRatio and handle it ourselves here so\n    // that we can do proper rounding and avoid white boundary pixels.\n    const width = Math.min(Math.ceil(scene.width * scaleFactor * dpr), this.canvas3D.width);\n    const height = Math.min(Math.ceil(scene.height * scaleFactor * dpr), this.canvas3D.height);\n    return {\n      width,\n      height\n    };\n  }\n  copyPixels(scene, width, height) {\n    const context2D = scene.context;\n    if (context2D == null) {\n      console.log('could not acquire 2d context');\n      return;\n    }\n    context2D.clearRect(0, 0, width, height);\n    context2D.drawImage(this.canvas3D, 0, 0, width, height, 0, 0, width, height);\n    scene.canvas.classList.add('show');\n  }\n  /**\n   * Returns an array version of this.scenes where the non-visible ones are\n   * first. This allows eager scenes to be rendered before they are visible,\n   * without needing the multi-canvas render path.\n   */\n  orderedScenes() {\n    const scenes = [];\n    for (const visible of [false, true]) {\n      for (const scene of this.scenes) {\n        if (scene.element.modelIsVisible === visible) {\n          scenes.push(scene);\n        }\n      }\n    }\n    return scenes;\n  }\n  get isPresenting() {\n    return this.arRenderer.isPresenting;\n  }\n  /**\n   * This method takes care of updating the element and renderer state based on\n   * the time that has passed since the last rendered frame.\n   */\n  preRender(scene, t, delta) {\n    const {\n      element,\n      exposure,\n      toneMapping\n    } = scene;\n    element[$tick](t, delta);\n    const exposureIsNumber = typeof exposure === 'number' && !Number.isNaN(exposure);\n    const env = element.environmentImage;\n    const sky = element.skyboxImage;\n    const compensateExposure = toneMapping === NeutralToneMapping && (env === 'neutral' || env === 'legacy' || !env && !sky);\n    this.threeRenderer.toneMappingExposure = (exposureIsNumber ? exposure : 1.0) * (compensateExposure ? COMMERCE_EXPOSURE : 1.0);\n  }\n  render(t, frame) {\n    if (frame != null) {\n      this.arRenderer.onWebXRFrame(t, frame);\n      return;\n    }\n    const delta = t - this.lastTick;\n    this.lastTick = t;\n    if (!this.canRender || this.isPresenting) {\n      return;\n    }\n    this.countVisibleScenes();\n    this.updateRendererSize();\n    if (this.renderedLastFrame) {\n      this.updateRendererScale(delta);\n      this.renderedLastFrame = false;\n    }\n    const {\n      canvas3D\n    } = this;\n    for (const scene of this.orderedScenes()) {\n      const {\n        element\n      } = scene;\n      if (!element.loaded || !element.modelIsVisible && scene.renderCount > 0) {\n        continue;\n      }\n      this.preRender(scene, t, delta);\n      if (!this.shouldRender(scene)) {\n        continue;\n      }\n      if (scene.externalRenderer != null) {\n        const camera = scene.getCamera();\n        camera.updateMatrix();\n        const {\n          matrix,\n          projectionMatrix\n        } = camera;\n        const viewMatrix = matrix.elements.slice();\n        const target = scene.getTarget();\n        viewMatrix[12] += target.x;\n        viewMatrix[13] += target.y;\n        viewMatrix[14] += target.z;\n        scene.externalRenderer.render({\n          viewMatrix: viewMatrix,\n          projectionMatrix: projectionMatrix.elements\n        });\n        continue;\n      }\n      if (!element.modelIsVisible && !this.multipleScenesVisible) {\n        // Here we are pre-rendering on the visible canvas, so we must mark the\n        // visible scene dirty to ensure it overwrites us.\n        for (const visibleScene of this.scenes) {\n          if (visibleScene.element.modelIsVisible) {\n            visibleScene.queueRender();\n          }\n        }\n      }\n      const {\n        width,\n        height\n      } = this.sceneSize(scene);\n      scene.renderShadow(this.threeRenderer);\n      // Need to set the render target in order to prevent\n      // clearing the depth from a different buffer\n      this.threeRenderer.setRenderTarget(null);\n      this.threeRenderer.setViewport(0, Math.ceil(this.height * this.dpr) - height, width, height);\n      if (scene.effectRenderer != null) {\n        scene.effectRenderer.render(delta);\n      } else {\n        this.threeRenderer.autoClear = true; // this might get reset by the effectRenderer\n        this.threeRenderer.toneMapping = scene.toneMapping;\n        this.threeRenderer.render(scene, scene.camera);\n      }\n      if (this.multipleScenesVisible || !scene.element.modelIsVisible && scene.renderCount === 0) {\n        this.copyPixels(scene, width, height);\n      } else if (canvas3D.parentElement !== scene.canvas.parentElement) {\n        scene.canvas.parentElement.appendChild(canvas3D);\n        scene.canvas.classList.remove('show');\n      }\n      scene.hasRendered();\n      ++scene.renderCount;\n      this.renderedLastFrame = true;\n    }\n  }\n  dispose() {\n    if (this.textureUtils != null) {\n      this.textureUtils.dispose();\n    }\n    if (this.threeRenderer != null) {\n      this.threeRenderer.dispose();\n    }\n    this.textureUtils = null;\n    this.threeRenderer = null;\n    const elements = [];\n    for (const scene of this.scenes) {\n      elements.push(scene.element);\n    }\n    this.canvas3D.removeEventListener('webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.removeEventListener('webglcontextrestored', this.onWebGLContextRestored);\n    return elements;\n  }\n}","map":{"version":3,"names":["ACESFilmicToneMapping","EventDispatcher","NeutralToneMapping","Vector2","WebGLRenderer","$updateEnvironment","$canvas","$tick","$updateSize","clamp","isDebugMode","resolveDpr","ARRenderer","CachingGLTFLoader","ModelViewerGLTFInstance","TextureUtils","DURATION_DECAY","LOW_FRAME_DURATION_MS","HIGH_FRAME_DURATION_MS","MAX_AVG_CHANGE_MS","SCALE_STEPS","DEFAULT_LAST_STEP","DEFAULT_POWER_PREFERENCE","COMMERCE_EXPOSURE","Renderer","constructor","options","loader","width","height","dpr","scenes","Set","multipleScenesVisible","lastTick","performance","now","renderedLastFrame","scaleStep","lastStep","avgFrameDuration","onWebGLContextLost","event","dispatchEvent","type","sourceEvent","onWebGLContextRestored","_a","textureUtils","dispose","threeRenderer","scene","element","canvas3D","document","createElement","id","classList","add","canvas","alpha","antialias","powerPreference","preserveDrawingBuffer","autoClear","setPixelRatio","debug","checkShaderErrors","onShaderError","toneMapping","error","console","warn","arRenderer","canRender","initializeKTX2Loader","addEventListener","updateRendererSize","singleton","_singleton","self","ModelViewerElement","resetSingleton","elements","disconnectedCallback","connectedCallback","scaleFactor","minScale","scale","i","length","registerScene","forceRescale","size","getSize","x","y","setAnimationLoop","time","frame","render","unregisterScene","delete","parentElement","removeChild","displayCanvas","modelIsVisible","countVisibleScenes","visibleScenes","canvas3DScene","externalRenderer","newlyMultiple","disappearing","sceneSize","copyPixels","getBoundingClientRect","Math","max","ceil","setSize","effectRenderer","updateRendererScale","delta","min","shouldRender","rescaleCanvas","style","renderedDpr","reason","window","devicePixelRatio","CustomEvent","detail","reportedDpr","minimumDpr","pixelWidth","pixelHeight","context2D","context","log","clearRect","drawImage","orderedScenes","visible","push","isPresenting","preRender","t","exposure","exposureIsNumber","Number","isNaN","env","environmentImage","sky","skyboxImage","compensateExposure","toneMappingExposure","onWebXRFrame","loaded","renderCount","camera","getCamera","updateMatrix","matrix","projectionMatrix","viewMatrix","slice","target","getTarget","z","visibleScene","queueRender","renderShadow","setRenderTarget","setViewport","appendChild","remove","hasRendered","removeEventListener"],"sources":["/Users/leandrodisconzi/CascadeProjects/geodome-website/node_modules/@google/model-viewer/lib/three-components/Renderer.js"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ACESFilmicToneMapping, EventDispatcher, NeutralToneMapping, Vector2, WebGLRenderer } from 'three';\nimport { $updateEnvironment } from '../features/environment.js';\nimport { $canvas, $tick, $updateSize } from '../model-viewer-base.js';\nimport { clamp, isDebugMode, resolveDpr } from '../utilities.js';\nimport { ARRenderer } from './ARRenderer.js';\nimport { CachingGLTFLoader } from './CachingGLTFLoader.js';\nimport { ModelViewerGLTFInstance } from './gltf-instance/ModelViewerGLTFInstance.js';\nimport TextureUtils from './TextureUtils.js';\n// Between 0 and 1: larger means the average responds faster and is less smooth.\nconst DURATION_DECAY = 0.2;\nconst LOW_FRAME_DURATION_MS = 40;\nconst HIGH_FRAME_DURATION_MS = 60;\nconst MAX_AVG_CHANGE_MS = 5;\nconst SCALE_STEPS = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25];\nconst DEFAULT_LAST_STEP = 3;\nexport const DEFAULT_POWER_PREFERENCE = 'high-performance';\nconst COMMERCE_EXPOSURE = 1.3;\n/**\n * Registers canvases with Canvas2DRenderingContexts and renders them\n * all in the same WebGLRenderingContext, spitting out textures to apply\n * to the canvases. Creates a fullscreen WebGL canvas that is not added\n * to the DOM, and on each frame, renders each registered canvas on a portion\n * of the WebGL canvas, and applies the texture on the registered canvas.\n *\n * In the future, can use ImageBitmapRenderingContext instead of\n * Canvas2DRenderingContext if supported for cheaper transferring of\n * the texture.\n */\nexport class Renderer extends EventDispatcher {\n    constructor(options) {\n        super();\n        this.loader = new CachingGLTFLoader(ModelViewerGLTFInstance);\n        this.width = 0;\n        this.height = 0;\n        this.dpr = 1;\n        this.scenes = new Set();\n        this.multipleScenesVisible = false;\n        this.lastTick = performance.now();\n        this.renderedLastFrame = false;\n        this.scaleStep = 0;\n        this.lastStep = DEFAULT_LAST_STEP;\n        this.avgFrameDuration = (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n        this.onWebGLContextLost = (event) => {\n            this.dispatchEvent({ type: 'contextlost', sourceEvent: event });\n        };\n        this.onWebGLContextRestored = () => {\n            var _a;\n            (_a = this.textureUtils) === null || _a === void 0 ? void 0 : _a.dispose();\n            this.textureUtils = new TextureUtils(this.threeRenderer);\n            for (const scene of this.scenes) {\n                scene.element[$updateEnvironment]();\n            }\n        };\n        this.dpr = resolveDpr();\n        this.canvas3D = document.createElement('canvas');\n        this.canvas3D.id = 'webgl-canvas';\n        this.canvas3D.classList.add('show');\n        try {\n            this.threeRenderer = new WebGLRenderer({\n                canvas: this.canvas3D,\n                alpha: true,\n                antialias: true,\n                powerPreference: options.powerPreference,\n                preserveDrawingBuffer: true,\n            });\n            this.threeRenderer.autoClear = true;\n            this.threeRenderer.setPixelRatio(1); // handle pixel ratio externally\n            this.threeRenderer.debug = {\n                checkShaderErrors: !!options.debug,\n                onShaderError: null\n            };\n            // ACESFilmicToneMapping appears to be the most \"saturated\",\n            // and similar to Filament's gltf-viewer.\n            this.threeRenderer.toneMapping = ACESFilmicToneMapping;\n        }\n        catch (error) {\n            console.warn(error);\n        }\n        this.arRenderer = new ARRenderer(this);\n        this.textureUtils =\n            this.canRender ? new TextureUtils(this.threeRenderer) : null;\n        CachingGLTFLoader.initializeKTX2Loader(this.threeRenderer);\n        this.canvas3D.addEventListener('webglcontextlost', this.onWebGLContextLost);\n        this.canvas3D.addEventListener('webglcontextrestored', this.onWebGLContextRestored);\n        this.updateRendererSize();\n    }\n    static get singleton() {\n        if (!this._singleton) {\n            this._singleton = new Renderer({\n                powerPreference: (self.ModelViewerElement || {})\n                    .powerPreference ||\n                    DEFAULT_POWER_PREFERENCE,\n                debug: isDebugMode()\n            });\n        }\n        return this._singleton;\n    }\n    static resetSingleton() {\n        const elements = this._singleton.dispose();\n        for (const element of elements) {\n            element.disconnectedCallback();\n        }\n        this._singleton = new Renderer({\n            powerPreference: (self.ModelViewerElement || {})\n                .powerPreference ||\n                DEFAULT_POWER_PREFERENCE,\n            debug: isDebugMode()\n        });\n        for (const element of elements) {\n            element.connectedCallback();\n        }\n    }\n    get canRender() {\n        return this.threeRenderer != null;\n    }\n    get scaleFactor() {\n        return SCALE_STEPS[this.scaleStep];\n    }\n    set minScale(scale) {\n        let i = 1;\n        while (i < SCALE_STEPS.length) {\n            if (SCALE_STEPS[i] < scale) {\n                break;\n            }\n            ++i;\n        }\n        this.lastStep = i - 1;\n    }\n    registerScene(scene) {\n        this.scenes.add(scene);\n        scene.forceRescale();\n        const size = new Vector2();\n        this.threeRenderer.getSize(size);\n        scene.canvas.width = size.x;\n        scene.canvas.height = size.y;\n        if (this.canRender && this.scenes.size > 0) {\n            this.threeRenderer.setAnimationLoop((time, frame) => this.render(time, frame));\n        }\n    }\n    unregisterScene(scene) {\n        this.scenes.delete(scene);\n        if (this.canvas3D.parentElement === scene.canvas.parentElement) {\n            scene.canvas.parentElement.removeChild(this.canvas3D);\n        }\n        if (this.canRender && this.scenes.size === 0) {\n            this.threeRenderer.setAnimationLoop(null);\n        }\n    }\n    displayCanvas(scene) {\n        return scene.element.modelIsVisible && !this.multipleScenesVisible ?\n            this.canvas3D :\n            scene.element[$canvas];\n    }\n    /**\n     * The function enables an optimization, where when there is only a single\n     * <model-viewer> element, we can use the renderer's 3D canvas directly for\n     * display. Otherwise we need to use the element's 2D canvas and copy the\n     * renderer's result into it.\n     */\n    countVisibleScenes() {\n        const { canvas3D } = this;\n        let visibleScenes = 0;\n        let canvas3DScene = null;\n        for (const scene of this.scenes) {\n            const { element } = scene;\n            if (element.modelIsVisible && scene.externalRenderer == null) {\n                ++visibleScenes;\n            }\n            if (canvas3D.parentElement === scene.canvas.parentElement) {\n                canvas3DScene = scene;\n            }\n        }\n        const multipleScenesVisible = visibleScenes > 1;\n        if (canvas3DScene != null) {\n            const newlyMultiple = multipleScenesVisible && !this.multipleScenesVisible;\n            const disappearing = !canvas3DScene.element.modelIsVisible;\n            if (newlyMultiple || disappearing) {\n                const { width, height } = this.sceneSize(canvas3DScene);\n                this.copyPixels(canvas3DScene, width, height);\n                canvas3D.parentElement.removeChild(canvas3D);\n            }\n        }\n        this.multipleScenesVisible = multipleScenesVisible;\n    }\n    /**\n     * Updates the renderer's size based on the largest scene and any changes to\n     * device pixel ratio.\n     */\n    updateRendererSize() {\n        var _a;\n        const dpr = resolveDpr();\n        if (dpr !== this.dpr) {\n            // If the device pixel ratio has changed due to page zoom, elements\n            // specified by % width do not fire a resize event even though their CSS\n            // pixel dimensions change, so we force them to update their size here.\n            for (const scene of this.scenes) {\n                const { element } = scene;\n                element[$updateSize](element.getBoundingClientRect());\n            }\n        }\n        // Make the renderer the size of the largest scene\n        let width = 0;\n        let height = 0;\n        for (const scene of this.scenes) {\n            width = Math.max(width, scene.width);\n            height = Math.max(height, scene.height);\n        }\n        if (width === this.width && height === this.height && dpr === this.dpr) {\n            return;\n        }\n        this.width = width;\n        this.height = height;\n        this.dpr = dpr;\n        width = Math.ceil(width * dpr);\n        height = Math.ceil(height * dpr);\n        if (this.canRender) {\n            this.threeRenderer.setSize(width, height, false);\n        }\n        // Each scene's canvas must match the renderer size. In general they can be\n        // larger than the element that contains them, but the overflow is hidden\n        // and only the portion that is shown is copied over.\n        for (const scene of this.scenes) {\n            const { canvas } = scene;\n            canvas.width = width;\n            canvas.height = height;\n            scene.forceRescale();\n            (_a = scene.effectRenderer) === null || _a === void 0 ? void 0 : _a.setSize(width, height);\n        }\n    }\n    updateRendererScale(delta) {\n        const scaleStep = this.scaleStep;\n        this.avgFrameDuration += clamp(DURATION_DECAY * (delta - this.avgFrameDuration), -MAX_AVG_CHANGE_MS, MAX_AVG_CHANGE_MS);\n        if (this.avgFrameDuration > HIGH_FRAME_DURATION_MS) {\n            ++this.scaleStep;\n        }\n        else if (this.avgFrameDuration < LOW_FRAME_DURATION_MS && this.scaleStep > 0) {\n            --this.scaleStep;\n        }\n        this.scaleStep = Math.min(this.scaleStep, this.lastStep);\n        if (scaleStep !== this.scaleStep) {\n            this.avgFrameDuration =\n                (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n        }\n    }\n    shouldRender(scene) {\n        if (!scene.shouldRender()) {\n            // The first frame we stop rendering the scene (because it stops moving),\n            // trigger one extra render at full scale.\n            if (scene.scaleStep != 0) {\n                scene.scaleStep = 0;\n                this.rescaleCanvas(scene);\n            }\n            else {\n                return false;\n            }\n        }\n        else if (scene.scaleStep != this.scaleStep) {\n            // Update render scale\n            scene.scaleStep = this.scaleStep;\n            this.rescaleCanvas(scene);\n        }\n        return true;\n    }\n    rescaleCanvas(scene) {\n        const scale = SCALE_STEPS[scene.scaleStep];\n        const width = Math.ceil(this.width / scale);\n        const height = Math.ceil(this.height / scale);\n        const { style } = scene.canvas;\n        style.width = `${width}px`;\n        style.height = `${height}px`;\n        this.canvas3D.style.width = `${width}px`;\n        this.canvas3D.style.height = `${height}px`;\n        const renderedDpr = this.dpr * scale;\n        const reason = scale < 1 ? 'GPU throttling' :\n            this.dpr !== window.devicePixelRatio ? 'No meta viewport tag' :\n                '';\n        scene.element.dispatchEvent(new CustomEvent('render-scale', {\n            detail: {\n                reportedDpr: window.devicePixelRatio,\n                renderedDpr: renderedDpr,\n                minimumDpr: this.dpr * SCALE_STEPS[this.lastStep],\n                pixelWidth: Math.ceil(scene.width * renderedDpr),\n                pixelHeight: Math.ceil(scene.height * renderedDpr),\n                reason: reason\n            }\n        }));\n    }\n    sceneSize(scene) {\n        const { dpr } = this;\n        const scaleFactor = SCALE_STEPS[scene.scaleStep];\n        // We avoid using the Three.js PixelRatio and handle it ourselves here so\n        // that we can do proper rounding and avoid white boundary pixels.\n        const width = Math.min(Math.ceil(scene.width * scaleFactor * dpr), this.canvas3D.width);\n        const height = Math.min(Math.ceil(scene.height * scaleFactor * dpr), this.canvas3D.height);\n        return { width, height };\n    }\n    copyPixels(scene, width, height) {\n        const context2D = scene.context;\n        if (context2D == null) {\n            console.log('could not acquire 2d context');\n            return;\n        }\n        context2D.clearRect(0, 0, width, height);\n        context2D.drawImage(this.canvas3D, 0, 0, width, height, 0, 0, width, height);\n        scene.canvas.classList.add('show');\n    }\n    /**\n     * Returns an array version of this.scenes where the non-visible ones are\n     * first. This allows eager scenes to be rendered before they are visible,\n     * without needing the multi-canvas render path.\n     */\n    orderedScenes() {\n        const scenes = [];\n        for (const visible of [false, true]) {\n            for (const scene of this.scenes) {\n                if (scene.element.modelIsVisible === visible) {\n                    scenes.push(scene);\n                }\n            }\n        }\n        return scenes;\n    }\n    get isPresenting() {\n        return this.arRenderer.isPresenting;\n    }\n    /**\n     * This method takes care of updating the element and renderer state based on\n     * the time that has passed since the last rendered frame.\n     */\n    preRender(scene, t, delta) {\n        const { element, exposure, toneMapping } = scene;\n        element[$tick](t, delta);\n        const exposureIsNumber = typeof exposure === 'number' && !Number.isNaN(exposure);\n        const env = element.environmentImage;\n        const sky = element.skyboxImage;\n        const compensateExposure = toneMapping === NeutralToneMapping &&\n            (env === 'neutral' || env === 'legacy' || (!env && !sky));\n        this.threeRenderer.toneMappingExposure =\n            (exposureIsNumber ? exposure : 1.0) *\n                (compensateExposure ? COMMERCE_EXPOSURE : 1.0);\n    }\n    render(t, frame) {\n        if (frame != null) {\n            this.arRenderer.onWebXRFrame(t, frame);\n            return;\n        }\n        const delta = t - this.lastTick;\n        this.lastTick = t;\n        if (!this.canRender || this.isPresenting) {\n            return;\n        }\n        this.countVisibleScenes();\n        this.updateRendererSize();\n        if (this.renderedLastFrame) {\n            this.updateRendererScale(delta);\n            this.renderedLastFrame = false;\n        }\n        const { canvas3D } = this;\n        for (const scene of this.orderedScenes()) {\n            const { element } = scene;\n            if (!element.loaded ||\n                (!element.modelIsVisible && scene.renderCount > 0)) {\n                continue;\n            }\n            this.preRender(scene, t, delta);\n            if (!this.shouldRender(scene)) {\n                continue;\n            }\n            if (scene.externalRenderer != null) {\n                const camera = scene.getCamera();\n                camera.updateMatrix();\n                const { matrix, projectionMatrix } = camera;\n                const viewMatrix = matrix.elements.slice();\n                const target = scene.getTarget();\n                viewMatrix[12] += target.x;\n                viewMatrix[13] += target.y;\n                viewMatrix[14] += target.z;\n                scene.externalRenderer.render({\n                    viewMatrix: viewMatrix,\n                    projectionMatrix: projectionMatrix.elements\n                });\n                continue;\n            }\n            if (!element.modelIsVisible && !this.multipleScenesVisible) {\n                // Here we are pre-rendering on the visible canvas, so we must mark the\n                // visible scene dirty to ensure it overwrites us.\n                for (const visibleScene of this.scenes) {\n                    if (visibleScene.element.modelIsVisible) {\n                        visibleScene.queueRender();\n                    }\n                }\n            }\n            const { width, height } = this.sceneSize(scene);\n            scene.renderShadow(this.threeRenderer);\n            // Need to set the render target in order to prevent\n            // clearing the depth from a different buffer\n            this.threeRenderer.setRenderTarget(null);\n            this.threeRenderer.setViewport(0, Math.ceil(this.height * this.dpr) - height, width, height);\n            if (scene.effectRenderer != null) {\n                scene.effectRenderer.render(delta);\n            }\n            else {\n                this.threeRenderer.autoClear =\n                    true; // this might get reset by the effectRenderer\n                this.threeRenderer.toneMapping = scene.toneMapping;\n                this.threeRenderer.render(scene, scene.camera);\n            }\n            if (this.multipleScenesVisible ||\n                (!scene.element.modelIsVisible && scene.renderCount === 0)) {\n                this.copyPixels(scene, width, height);\n            }\n            else if (canvas3D.parentElement !== scene.canvas.parentElement) {\n                scene.canvas.parentElement.appendChild(canvas3D);\n                scene.canvas.classList.remove('show');\n            }\n            scene.hasRendered();\n            ++scene.renderCount;\n            this.renderedLastFrame = true;\n        }\n    }\n    dispose() {\n        if (this.textureUtils != null) {\n            this.textureUtils.dispose();\n        }\n        if (this.threeRenderer != null) {\n            this.threeRenderer.dispose();\n        }\n        this.textureUtils = null;\n        this.threeRenderer = null;\n        const elements = [];\n        for (const scene of this.scenes) {\n            elements.push(scene.element);\n        }\n        this.canvas3D.removeEventListener('webglcontextlost', this.onWebGLContextLost);\n        this.canvas3D.removeEventListener('webglcontextrestored', this.onWebGLContextRestored);\n        return elements;\n    }\n}\n//# sourceMappingURL=Renderer.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}