{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { FrontSide, Sphere } from 'three';\nimport { $clone, $prepare, $preparedGLTF, GLTFInstance } from '../GLTFInstance.js';\nimport { CorrelatedSceneGraph } from './correlated-scene-graph.js';\nconst $correlatedSceneGraph = Symbol('correlatedSceneGraph');\n/**\n * This specialization of GLTFInstance collects all of the processing needed\n * to prepare a model and to clone it making special considerations for\n * <model-viewer> use cases.\n */\nexport class ModelViewerGLTFInstance extends GLTFInstance {\n  /**\n   * @override\n   */\n  static [$prepare](source) {\n    const prepared = super[$prepare](source);\n    if (prepared[$correlatedSceneGraph] == null) {\n      prepared[$correlatedSceneGraph] = CorrelatedSceneGraph.from(prepared);\n    }\n    const {\n      scene\n    } = prepared;\n    const nullSphere = new Sphere(undefined, Infinity);\n    scene.traverse(node => {\n      // Set a high renderOrder while we're here to ensure the model\n      // always renders on top of the sky sphere\n      node.renderOrder = 1000;\n      // Three.js seems to cull some animated models incorrectly. Since we\n      // expect to view our whole scene anyway, we turn off the frustum\n      // culling optimization here.\n      node.frustumCulled = false;\n      // Animations for objects without names target their UUID instead. When\n      // objects are cloned, they get new UUIDs which the animation can't\n      // find. To fix this, we assign their UUID as their name.\n      if (!node.name) {\n        node.name = node.uuid;\n      }\n      const mesh = node;\n      if (mesh.material) {\n        const {\n          geometry\n        } = mesh;\n        mesh.castShadow = true;\n        if (mesh.isSkinnedMesh) {\n          // Akin to disabling frustum culling above, we have to also manually\n          // disable the bounds to make raycasting correct for skinned meshes.\n          geometry.boundingSphere = nullSphere;\n          // The bounding box is set in GLTFLoader by the accessor bounds, which\n          // are not updated with animation.\n          geometry.boundingBox = null;\n        }\n        const material = mesh.material;\n        if (material.isMeshBasicMaterial === true) {\n          material.toneMapped = false;\n        }\n        // This makes shadows better for non-manifold meshes\n        material.shadowSide = FrontSide;\n        // Fixes an edge case with unused extra UV-coords being incorrectly\n        // referenced by three.js; remove when\n        // https://github.com/mrdoob/three.js/pull/23974 is merged.\n        if (material.aoMap) {\n          const {\n            gltf,\n            threeObjectMap\n          } = prepared[$correlatedSceneGraph];\n          const gltfRef = threeObjectMap.get(material);\n          if (gltf.materials != null && gltfRef != null && gltfRef.materials != null) {\n            const gltfMaterial = gltf.materials[gltfRef.materials];\n            if (gltfMaterial.occlusionTexture && gltfMaterial.occlusionTexture.texCoord === 0 && geometry.attributes.uv != null) {\n              geometry.setAttribute('uv2', geometry.attributes.uv);\n            }\n          }\n        }\n      }\n    });\n    return prepared;\n  }\n  get correlatedSceneGraph() {\n    return this[$preparedGLTF][$correlatedSceneGraph];\n  }\n  /**\n   * @override\n   */\n  [$clone]() {\n    const clone = super[$clone]();\n    const sourceUUIDToClonedMaterial = new Map();\n    clone.scene.traverse(node => {\n      // Materials aren't cloned when cloning meshes; geometry\n      // and materials are copied by reference. This is necessary\n      // for the same model to be used twice with different\n      // scene-graph operations.\n      const mesh = node;\n      if (mesh.material) {\n        const material = mesh.material;\n        if (material != null) {\n          if (sourceUUIDToClonedMaterial.has(material.uuid)) {\n            mesh.material = sourceUUIDToClonedMaterial.get(material.uuid);\n            return;\n          }\n          mesh.material = material.clone();\n          sourceUUIDToClonedMaterial.set(material.uuid, mesh.material);\n        }\n      }\n      const light = node;\n      if (light.target !== undefined) {\n        // The target's parent is lost in the cloning process, but in\n        // GLTFLoader, all light targets are children of their light.\n        light.add(light.target);\n      }\n    });\n    // Cross-correlate the scene graph by relying on information in the\n    // current scene graph; without this step, relationships between the\n    // Three.js object graph and the glTF scene graph will be lost.\n    clone[$correlatedSceneGraph] = CorrelatedSceneGraph.from(clone, this.correlatedSceneGraph);\n    return clone;\n  }\n}","map":{"version":3,"names":["FrontSide","Sphere","$clone","$prepare","$preparedGLTF","GLTFInstance","CorrelatedSceneGraph","$correlatedSceneGraph","Symbol","ModelViewerGLTFInstance","source","prepared","from","scene","nullSphere","undefined","Infinity","traverse","node","renderOrder","frustumCulled","name","uuid","mesh","material","geometry","castShadow","isSkinnedMesh","boundingSphere","boundingBox","isMeshBasicMaterial","toneMapped","shadowSide","aoMap","gltf","threeObjectMap","gltfRef","get","materials","gltfMaterial","occlusionTexture","texCoord","attributes","uv","setAttribute","correlatedSceneGraph","clone","sourceUUIDToClonedMaterial","Map","has","set","light","target","add"],"sources":["/Users/leandrodisconzi/CascadeProjects/geodome-website/node_modules/@google/model-viewer/lib/three-components/gltf-instance/ModelViewerGLTFInstance.js"],"sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { FrontSide, Sphere } from 'three';\nimport { $clone, $prepare, $preparedGLTF, GLTFInstance } from '../GLTFInstance.js';\nimport { CorrelatedSceneGraph } from './correlated-scene-graph.js';\nconst $correlatedSceneGraph = Symbol('correlatedSceneGraph');\n/**\n * This specialization of GLTFInstance collects all of the processing needed\n * to prepare a model and to clone it making special considerations for\n * <model-viewer> use cases.\n */\nexport class ModelViewerGLTFInstance extends GLTFInstance {\n    /**\n     * @override\n     */\n    static [$prepare](source) {\n        const prepared = super[$prepare](source);\n        if (prepared[$correlatedSceneGraph] == null) {\n            prepared[$correlatedSceneGraph] = CorrelatedSceneGraph.from(prepared);\n        }\n        const { scene } = prepared;\n        const nullSphere = new Sphere(undefined, Infinity);\n        scene.traverse((node) => {\n            // Set a high renderOrder while we're here to ensure the model\n            // always renders on top of the sky sphere\n            node.renderOrder = 1000;\n            // Three.js seems to cull some animated models incorrectly. Since we\n            // expect to view our whole scene anyway, we turn off the frustum\n            // culling optimization here.\n            node.frustumCulled = false;\n            // Animations for objects without names target their UUID instead. When\n            // objects are cloned, they get new UUIDs which the animation can't\n            // find. To fix this, we assign their UUID as their name.\n            if (!node.name) {\n                node.name = node.uuid;\n            }\n            const mesh = node;\n            if (mesh.material) {\n                const { geometry } = mesh;\n                mesh.castShadow = true;\n                if (mesh.isSkinnedMesh) {\n                    // Akin to disabling frustum culling above, we have to also manually\n                    // disable the bounds to make raycasting correct for skinned meshes.\n                    geometry.boundingSphere = nullSphere;\n                    // The bounding box is set in GLTFLoader by the accessor bounds, which\n                    // are not updated with animation.\n                    geometry.boundingBox = null;\n                }\n                const material = mesh.material;\n                if (material.isMeshBasicMaterial === true) {\n                    material.toneMapped = false;\n                }\n                // This makes shadows better for non-manifold meshes\n                material.shadowSide = FrontSide;\n                // Fixes an edge case with unused extra UV-coords being incorrectly\n                // referenced by three.js; remove when\n                // https://github.com/mrdoob/three.js/pull/23974 is merged.\n                if (material.aoMap) {\n                    const { gltf, threeObjectMap } = prepared[$correlatedSceneGraph];\n                    const gltfRef = threeObjectMap.get(material);\n                    if (gltf.materials != null && gltfRef != null &&\n                        gltfRef.materials != null) {\n                        const gltfMaterial = gltf.materials[gltfRef.materials];\n                        if (gltfMaterial.occlusionTexture &&\n                            gltfMaterial.occlusionTexture.texCoord === 0 &&\n                            geometry.attributes.uv != null) {\n                            geometry.setAttribute('uv2', geometry.attributes.uv);\n                        }\n                    }\n                }\n            }\n        });\n        return prepared;\n    }\n    get correlatedSceneGraph() {\n        return this[$preparedGLTF][$correlatedSceneGraph];\n    }\n    /**\n     * @override\n     */\n    [$clone]() {\n        const clone = super[$clone]();\n        const sourceUUIDToClonedMaterial = new Map();\n        clone.scene.traverse((node) => {\n            // Materials aren't cloned when cloning meshes; geometry\n            // and materials are copied by reference. This is necessary\n            // for the same model to be used twice with different\n            // scene-graph operations.\n            const mesh = node;\n            if (mesh.material) {\n                const material = mesh.material;\n                if (material != null) {\n                    if (sourceUUIDToClonedMaterial.has(material.uuid)) {\n                        mesh.material = sourceUUIDToClonedMaterial.get(material.uuid);\n                        return;\n                    }\n                    mesh.material = material.clone();\n                    sourceUUIDToClonedMaterial.set(material.uuid, mesh.material);\n                }\n            }\n            const light = node;\n            if (light.target !== undefined) {\n                // The target's parent is lost in the cloning process, but in\n                // GLTFLoader, all light targets are children of their light.\n                light.add(light.target);\n            }\n        });\n        // Cross-correlate the scene graph by relying on information in the\n        // current scene graph; without this step, relationships between the\n        // Three.js object graph and the glTF scene graph will be lost.\n        clone[$correlatedSceneGraph] =\n            CorrelatedSceneGraph.from(clone, this.correlatedSceneGraph);\n        return clone;\n    }\n}\n//# sourceMappingURL=ModelViewerGLTFInstance.js.map"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,SAAS,EAAEC,MAAM,QAAQ,OAAO;AACzC,SAASC,MAAM,EAAEC,QAAQ,EAAEC,aAAa,EAAEC,YAAY,QAAQ,oBAAoB;AAClF,SAASC,oBAAoB,QAAQ,6BAA6B;AAClE,MAAMC,qBAAqB,GAAGC,MAAM,CAAC,sBAAsB,CAAC;AAC5D;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,uBAAuB,SAASJ,YAAY,CAAC;EACtD;AACJ;AACA;EACI,QAAQF,QAAQ,EAAEO,MAAM,EAAE;IACtB,MAAMC,QAAQ,GAAG,KAAK,CAACR,QAAQ,CAAC,CAACO,MAAM,CAAC;IACxC,IAAIC,QAAQ,CAACJ,qBAAqB,CAAC,IAAI,IAAI,EAAE;MACzCI,QAAQ,CAACJ,qBAAqB,CAAC,GAAGD,oBAAoB,CAACM,IAAI,CAACD,QAAQ,CAAC;IACzE;IACA,MAAM;MAAEE;IAAM,CAAC,GAAGF,QAAQ;IAC1B,MAAMG,UAAU,GAAG,IAAIb,MAAM,CAACc,SAAS,EAAEC,QAAQ,CAAC;IAClDH,KAAK,CAACI,QAAQ,CAAEC,IAAI,IAAK;MACrB;MACA;MACAA,IAAI,CAACC,WAAW,GAAG,IAAI;MACvB;MACA;MACA;MACAD,IAAI,CAACE,aAAa,GAAG,KAAK;MAC1B;MACA;MACA;MACA,IAAI,CAACF,IAAI,CAACG,IAAI,EAAE;QACZH,IAAI,CAACG,IAAI,GAAGH,IAAI,CAACI,IAAI;MACzB;MACA,MAAMC,IAAI,GAAGL,IAAI;MACjB,IAAIK,IAAI,CAACC,QAAQ,EAAE;QACf,MAAM;UAAEC;QAAS,CAAC,GAAGF,IAAI;QACzBA,IAAI,CAACG,UAAU,GAAG,IAAI;QACtB,IAAIH,IAAI,CAACI,aAAa,EAAE;UACpB;UACA;UACAF,QAAQ,CAACG,cAAc,GAAGd,UAAU;UACpC;UACA;UACAW,QAAQ,CAACI,WAAW,GAAG,IAAI;QAC/B;QACA,MAAML,QAAQ,GAAGD,IAAI,CAACC,QAAQ;QAC9B,IAAIA,QAAQ,CAACM,mBAAmB,KAAK,IAAI,EAAE;UACvCN,QAAQ,CAACO,UAAU,GAAG,KAAK;QAC/B;QACA;QACAP,QAAQ,CAACQ,UAAU,GAAGhC,SAAS;QAC/B;QACA;QACA;QACA,IAAIwB,QAAQ,CAACS,KAAK,EAAE;UAChB,MAAM;YAAEC,IAAI;YAAEC;UAAe,CAAC,GAAGxB,QAAQ,CAACJ,qBAAqB,CAAC;UAChE,MAAM6B,OAAO,GAAGD,cAAc,CAACE,GAAG,CAACb,QAAQ,CAAC;UAC5C,IAAIU,IAAI,CAACI,SAAS,IAAI,IAAI,IAAIF,OAAO,IAAI,IAAI,IACzCA,OAAO,CAACE,SAAS,IAAI,IAAI,EAAE;YAC3B,MAAMC,YAAY,GAAGL,IAAI,CAACI,SAAS,CAACF,OAAO,CAACE,SAAS,CAAC;YACtD,IAAIC,YAAY,CAACC,gBAAgB,IAC7BD,YAAY,CAACC,gBAAgB,CAACC,QAAQ,KAAK,CAAC,IAC5ChB,QAAQ,CAACiB,UAAU,CAACC,EAAE,IAAI,IAAI,EAAE;cAChClB,QAAQ,CAACmB,YAAY,CAAC,KAAK,EAAEnB,QAAQ,CAACiB,UAAU,CAACC,EAAE,CAAC;YACxD;UACJ;QACJ;MACJ;IACJ,CAAC,CAAC;IACF,OAAOhC,QAAQ;EACnB;EACA,IAAIkC,oBAAoBA,CAAA,EAAG;IACvB,OAAO,IAAI,CAACzC,aAAa,CAAC,CAACG,qBAAqB,CAAC;EACrD;EACA;AACJ;AACA;EACI,CAACL,MAAM,IAAI;IACP,MAAM4C,KAAK,GAAG,KAAK,CAAC5C,MAAM,CAAC,CAAC,CAAC;IAC7B,MAAM6C,0BAA0B,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC5CF,KAAK,CAACjC,KAAK,CAACI,QAAQ,CAAEC,IAAI,IAAK;MAC3B;MACA;MACA;MACA;MACA,MAAMK,IAAI,GAAGL,IAAI;MACjB,IAAIK,IAAI,CAACC,QAAQ,EAAE;QACf,MAAMA,QAAQ,GAAGD,IAAI,CAACC,QAAQ;QAC9B,IAAIA,QAAQ,IAAI,IAAI,EAAE;UAClB,IAAIuB,0BAA0B,CAACE,GAAG,CAACzB,QAAQ,CAACF,IAAI,CAAC,EAAE;YAC/CC,IAAI,CAACC,QAAQ,GAAGuB,0BAA0B,CAACV,GAAG,CAACb,QAAQ,CAACF,IAAI,CAAC;YAC7D;UACJ;UACAC,IAAI,CAACC,QAAQ,GAAGA,QAAQ,CAACsB,KAAK,CAAC,CAAC;UAChCC,0BAA0B,CAACG,GAAG,CAAC1B,QAAQ,CAACF,IAAI,EAAEC,IAAI,CAACC,QAAQ,CAAC;QAChE;MACJ;MACA,MAAM2B,KAAK,GAAGjC,IAAI;MAClB,IAAIiC,KAAK,CAACC,MAAM,KAAKrC,SAAS,EAAE;QAC5B;QACA;QACAoC,KAAK,CAACE,GAAG,CAACF,KAAK,CAACC,MAAM,CAAC;MAC3B;IACJ,CAAC,CAAC;IACF;IACA;IACA;IACAN,KAAK,CAACvC,qBAAqB,CAAC,GACxBD,oBAAoB,CAACM,IAAI,CAACkC,KAAK,EAAE,IAAI,CAACD,oBAAoB,CAAC;IAC/D,OAAOC,KAAK;EAChB;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}