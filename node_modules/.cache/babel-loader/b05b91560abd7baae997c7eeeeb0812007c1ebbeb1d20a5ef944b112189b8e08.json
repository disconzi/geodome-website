{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { HAS_WEBXR_DEVICE_API, HAS_WEBXR_HIT_TEST_API, IS_WEBXR_AR_CANDIDATE } from './constants.js';\nexport const deserializeUrl = url => !!url && url !== 'null' ? toFullUrl(url) : null;\nexport const assertIsArCandidate = () => {\n  if (IS_WEBXR_AR_CANDIDATE) {\n    return;\n  }\n  const missingApis = [];\n  if (!HAS_WEBXR_DEVICE_API) {\n    missingApis.push('WebXR Device API');\n  }\n  if (!HAS_WEBXR_HIT_TEST_API) {\n    missingApis.push('WebXR Hit Test API');\n  }\n  throw new Error(`The following APIs are required for AR, but are missing in this browser: ${missingApis.join(', ')}`);\n};\n/**\n * Converts a partial URL string to a fully qualified URL string.\n *\n * @param {String} url\n * @return {String}\n */\nexport const toFullUrl = partialUrl => {\n  const url = new URL(partialUrl, window.location.toString());\n  return url.toString();\n};\n/**\n * Returns a throttled version of a given function that is only invoked at most\n * once within a given threshold of time in milliseconds.\n *\n * The throttled version of the function has a \"flush\" property that resets the\n * threshold for cases when immediate invocation is desired.\n */\nexport const throttle = (fn, ms) => {\n  let timer = null;\n  const throttled = (...args) => {\n    if (timer != null) {\n      return;\n    }\n    fn(...args);\n    timer = self.setTimeout(() => timer = null, ms);\n  };\n  throttled.flush = () => {\n    if (timer != null) {\n      self.clearTimeout(timer);\n      timer = null;\n    }\n  };\n  return throttled;\n};\nexport const debounce = (fn, ms) => {\n  let timer = null;\n  return (...args) => {\n    if (timer != null) {\n      self.clearTimeout(timer);\n    }\n    timer = self.setTimeout(() => {\n      timer = null;\n      fn(...args);\n    }, ms);\n  };\n};\n/**\n * @param {Number} edge\n * @param {Number} value\n * @return {Number} 0 if value is less than edge, otherwise 1\n */\nexport const step = (edge, value) => {\n  return value < edge ? 0 : 1;\n};\n/**\n * @param {Number} value\n * @param {Number} lowerLimit\n * @param {Number} upperLimit\n * @return {Number} value clamped within lowerLimit..upperLimit\n */\nexport const clamp = (value, lowerLimit, upperLimit) => Math.max(lowerLimit, Math.min(upperLimit, value));\n// The DPR we use for a \"capped\" scenario (see resolveDpr below):\nexport const CAPPED_DEVICE_PIXEL_RATIO = 1;\n/**\n * This helper analyzes the layout of the current page to decide if we should\n * use the natural device pixel ratio, or a capped value.\n *\n * We cap DPR if there is no meta viewport (suggesting that user is not\n * consciously specifying how to scale the viewport relative to the device\n * screen size).\n *\n * The rationale is that this condition typically leads to a pathological\n * outcome on mobile devices. When the window dimensions are scaled up on a\n * device with a high DPR, we create a canvas that is much larger than\n * appropriate to accommodate for the pixel density if we naively use the\n * reported DPR.\n *\n * This value needs to be measured in real time, as device pixel ratio can\n * change over time (e.g., when a user zooms the page). Also, in some cases\n * (such as Firefox on Android), the window's innerWidth is initially reported\n * as the same as the screen's availWidth but changes later.\n *\n * A user who specifies a meta viewport, thereby consciously creating scaling\n * conditions where <model-viewer> is slow, will be encouraged to live their\n * best life.\n */\nexport const resolveDpr = (() => {\n  // If true, implies that the user is conscious of the viewport scaling\n  // relative to the device screen size.\n  const HAS_META_VIEWPORT_TAG = (() => {\n    var _a;\n    // Search result pages sometimes do not include a meta viewport tag even\n    // though they are certainly modern and work properly with devicePixelRatio.\n    if ((_a = document.documentElement.getAttribute('itemtype')) === null || _a === void 0 ? void 0 : _a.includes('schema.org/SearchResultsPage')) {\n      return true;\n    }\n    if (window.self !== window.top) {\n      // iframes can't detect the meta viewport tag, so assume the top-level\n      // page has one.\n      return true;\n    }\n    const metas = document.head != null ? Array.from(document.head.querySelectorAll('meta')) : [];\n    for (const meta of metas) {\n      if (meta.name === 'viewport') {\n        return true;\n      }\n    }\n    return false;\n  })();\n  if (!HAS_META_VIEWPORT_TAG) {\n    console.warn('No <meta name=\"viewport\"> detected; <model-viewer> will cap pixel density at 1.');\n  }\n  return () => HAS_META_VIEWPORT_TAG ? window.devicePixelRatio : CAPPED_DEVICE_PIXEL_RATIO;\n})();\n/**\n * Debug mode is enabled when one of the two following conditions is true:\n *\n *  1. A 'model-viewer-debug-mode' query parameter is present in the current\n *     search string\n *  2. There is a global object ModelViewerElement with a debugMode property set\n *     to true\n */\nexport const isDebugMode = (() => {\n  const debugQueryParameterName = 'model-viewer-debug-mode';\n  const debugQueryParameter = new RegExp(`[?&]${debugQueryParameterName}(&|$)`);\n  return () => self.ModelViewerElement && self.ModelViewerElement.debugMode || self.location && self.location.search && self.location.search.match(debugQueryParameter);\n})();\nexport const timePasses = (ms = 0) => new Promise(resolve => setTimeout(resolve, ms));\n/**\n * @param {EventTarget|EventDispatcher} target\n * @param {string} eventName\n * @param {?Function} predicate\n */\nexport const waitForEvent = (target, eventName, predicate = null) => new Promise(resolve => {\n  function handler(event) {\n    if (!predicate || predicate(event)) {\n      resolve(event);\n      target.removeEventListener(eventName, handler);\n    }\n  }\n  target.addEventListener(eventName, handler);\n});","map":{"version":3,"names":["HAS_WEBXR_DEVICE_API","HAS_WEBXR_HIT_TEST_API","IS_WEBXR_AR_CANDIDATE","deserializeUrl","url","toFullUrl","assertIsArCandidate","missingApis","push","Error","join","partialUrl","URL","window","location","toString","throttle","fn","ms","timer","throttled","args","self","setTimeout","flush","clearTimeout","debounce","step","edge","value","clamp","lowerLimit","upperLimit","Math","max","min","CAPPED_DEVICE_PIXEL_RATIO","resolveDpr","HAS_META_VIEWPORT_TAG","_a","document","documentElement","getAttribute","includes","top","metas","head","Array","from","querySelectorAll","meta","name","console","warn","devicePixelRatio","isDebugMode","debugQueryParameterName","debugQueryParameter","RegExp","ModelViewerElement","debugMode","search","match","timePasses","Promise","resolve","waitForEvent","target","eventName","predicate","handler","event","removeEventListener","addEventListener"],"sources":["/Users/leandrodisconzi/CascadeProjects/geodome-website/node_modules/@google/model-viewer/lib/utilities.js"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { HAS_WEBXR_DEVICE_API, HAS_WEBXR_HIT_TEST_API, IS_WEBXR_AR_CANDIDATE } from './constants.js';\nexport const deserializeUrl = (url) => (!!url && url !== 'null') ? toFullUrl(url) : null;\nexport const assertIsArCandidate = () => {\n    if (IS_WEBXR_AR_CANDIDATE) {\n        return;\n    }\n    const missingApis = [];\n    if (!HAS_WEBXR_DEVICE_API) {\n        missingApis.push('WebXR Device API');\n    }\n    if (!HAS_WEBXR_HIT_TEST_API) {\n        missingApis.push('WebXR Hit Test API');\n    }\n    throw new Error(`The following APIs are required for AR, but are missing in this browser: ${missingApis.join(', ')}`);\n};\n/**\n * Converts a partial URL string to a fully qualified URL string.\n *\n * @param {String} url\n * @return {String}\n */\nexport const toFullUrl = (partialUrl) => {\n    const url = new URL(partialUrl, window.location.toString());\n    return url.toString();\n};\n/**\n * Returns a throttled version of a given function that is only invoked at most\n * once within a given threshold of time in milliseconds.\n *\n * The throttled version of the function has a \"flush\" property that resets the\n * threshold for cases when immediate invocation is desired.\n */\nexport const throttle = (fn, ms) => {\n    let timer = null;\n    const throttled = (...args) => {\n        if (timer != null) {\n            return;\n        }\n        fn(...args);\n        timer = self.setTimeout(() => timer = null, ms);\n    };\n    throttled.flush = () => {\n        if (timer != null) {\n            self.clearTimeout(timer);\n            timer = null;\n        }\n    };\n    return throttled;\n};\nexport const debounce = (fn, ms) => {\n    let timer = null;\n    return (...args) => {\n        if (timer != null) {\n            self.clearTimeout(timer);\n        }\n        timer = self.setTimeout(() => {\n            timer = null;\n            fn(...args);\n        }, ms);\n    };\n};\n/**\n * @param {Number} edge\n * @param {Number} value\n * @return {Number} 0 if value is less than edge, otherwise 1\n */\nexport const step = (edge, value) => {\n    return value < edge ? 0 : 1;\n};\n/**\n * @param {Number} value\n * @param {Number} lowerLimit\n * @param {Number} upperLimit\n * @return {Number} value clamped within lowerLimit..upperLimit\n */\nexport const clamp = (value, lowerLimit, upperLimit) => Math.max(lowerLimit, Math.min(upperLimit, value));\n// The DPR we use for a \"capped\" scenario (see resolveDpr below):\nexport const CAPPED_DEVICE_PIXEL_RATIO = 1;\n/**\n * This helper analyzes the layout of the current page to decide if we should\n * use the natural device pixel ratio, or a capped value.\n *\n * We cap DPR if there is no meta viewport (suggesting that user is not\n * consciously specifying how to scale the viewport relative to the device\n * screen size).\n *\n * The rationale is that this condition typically leads to a pathological\n * outcome on mobile devices. When the window dimensions are scaled up on a\n * device with a high DPR, we create a canvas that is much larger than\n * appropriate to accommodate for the pixel density if we naively use the\n * reported DPR.\n *\n * This value needs to be measured in real time, as device pixel ratio can\n * change over time (e.g., when a user zooms the page). Also, in some cases\n * (such as Firefox on Android), the window's innerWidth is initially reported\n * as the same as the screen's availWidth but changes later.\n *\n * A user who specifies a meta viewport, thereby consciously creating scaling\n * conditions where <model-viewer> is slow, will be encouraged to live their\n * best life.\n */\nexport const resolveDpr = (() => {\n    // If true, implies that the user is conscious of the viewport scaling\n    // relative to the device screen size.\n    const HAS_META_VIEWPORT_TAG = (() => {\n        var _a;\n        // Search result pages sometimes do not include a meta viewport tag even\n        // though they are certainly modern and work properly with devicePixelRatio.\n        if ((_a = document.documentElement.getAttribute('itemtype')) === null || _a === void 0 ? void 0 : _a.includes('schema.org/SearchResultsPage')) {\n            return true;\n        }\n        if (window.self !== window.top) {\n            // iframes can't detect the meta viewport tag, so assume the top-level\n            // page has one.\n            return true;\n        }\n        const metas = document.head != null ?\n            Array.from(document.head.querySelectorAll('meta')) :\n            [];\n        for (const meta of metas) {\n            if (meta.name === 'viewport') {\n                return true;\n            }\n        }\n        return false;\n    })();\n    if (!HAS_META_VIEWPORT_TAG) {\n        console.warn('No <meta name=\"viewport\"> detected; <model-viewer> will cap pixel density at 1.');\n    }\n    return () => HAS_META_VIEWPORT_TAG ? window.devicePixelRatio :\n        CAPPED_DEVICE_PIXEL_RATIO;\n})();\n/**\n * Debug mode is enabled when one of the two following conditions is true:\n *\n *  1. A 'model-viewer-debug-mode' query parameter is present in the current\n *     search string\n *  2. There is a global object ModelViewerElement with a debugMode property set\n *     to true\n */\nexport const isDebugMode = (() => {\n    const debugQueryParameterName = 'model-viewer-debug-mode';\n    const debugQueryParameter = new RegExp(`[?&]${debugQueryParameterName}(&|$)`);\n    return () => (self.ModelViewerElement &&\n        self.ModelViewerElement.debugMode) ||\n        (self.location && self.location.search &&\n            self.location.search.match(debugQueryParameter));\n})();\nexport const timePasses = (ms = 0) => new Promise(resolve => setTimeout(resolve, ms));\n/**\n * @param {EventTarget|EventDispatcher} target\n * @param {string} eventName\n * @param {?Function} predicate\n */\nexport const waitForEvent = (target, eventName, predicate = null) => new Promise(resolve => {\n    function handler(event) {\n        if (!predicate || predicate(event)) {\n            resolve(event);\n            target.removeEventListener(eventName, handler);\n        }\n    }\n    target.addEventListener(eventName, handler);\n});\n//# sourceMappingURL=utilities.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}